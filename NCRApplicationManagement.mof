//-----------------------------------------------------------------------------
// File Name  : NCRApplicationManagement.mof
//-----------------------------------------------------------------------------
// Copyright © 2012 NCR Corporation, Duluth, Georgia, all rights reserved.
//-----------------------------------------------------------------------------
// All revision information is updated automatically from source code control
// change records - please do not manually edit.
//-----------------------------------------------------------------------------
// Purpose    : Contains the mof definition of all the the NCR Application 
//              Management WMI Classes
//-----------------------------------------------------------------------------
// $Log: NCRApplicationManagement.mof  $
// Revision 1.6 2012/05/09 18:00:35IST Breen, Ashley (ae515074) 
// Updated NCR_ATM class:
//  - changed property "persistsOOSOnReboot" to be "PersistsOOSOnReboot" (initial caps)
//  - in ResetATM and ResetATMEnhanced, changed parameter "reason" to be "Reason" (initial caps)
//  for consistency.
// Revision 1.5 2012/04/19 14:23:01BST Breen, Ashley (ae515074) 
// Added AdditionalData parameter to NCR_ATM ResetATMEnhanced method. This is required to allow the 
// Critical Exception Handler to pass stack trace data to be logged under NCR_RestartMetrics.
// Updated descriptions in NCR_ATM and NCR_RestartMetrics classes to match AppMgmt FAS.
// Revision 1.4 2012/04/19 13:55:48BST Breen, Ashley (ae515074) 
// Added a method to NCR_ATM class that will shut down the terminal rather than reset it.
// Required to allow Supervisor SMSupportTasks to shutdown the SST through WMI.
// Revision 1.3 2012/04/19 13:29:16BST Breen, Ashley (ae515074) 
// Added reason "Device Auto Recovery" to the NCR_RestartReason class to allow the DeviceAutoRecovery
//  component to specify a sensible reason when using the NCR_ATM::ResetATMEnhanced method to reset 
// the SST.
// Revision 1.2 2012/02/03 10:31:08GMT Edwards, Alan (ae162000) 
// Defect 588759 - AppManMOF: Remove the key qualifier on PD events. Key values on events does not make sense.
// Revision 1.1 2011/12/20 09:48:52GMT Savage, Gerard (gs515590) 
// Initial revision
// Member added to project f:/NCR/FSD/SelfService/SPL/Architecture/AIModules/WMI/ApplicationManagement/project.pj
// --- Added comments ---  GS515590 [Dec 20, 2011 4:55:44 AM EST]
// rename
// Revision 1.41 2011/10/21 10:59:31BST Savage, Gerard (gs515590) 
// updated to remove SNMPPropertyOffset from CurrencyTriggers property of NCR_InstalledCurrency, as requested by RFC 578305
// Revision 1.40 2011/10/19 16:17:00BST Edwards, Alan (ae162000) 
// RFC 577004 - ISONet 04.05: "NCR_CurrencyReplenishmentTrigger" WMI Event definition has to be updated  in MOF file to include SNMPGroup and SNMPTrapClass qualifiers. (ref  484173)
// Revision 1.39 2011/10/17 16:02:32BST Savage, Gerard (gs515590) 
// added SNMP modifiers to NCR_CurrencyReplenishmentTrigger
// Revision 1.38 2011/09/01 16:49:59BST Edwards, Alan (ae162000) 
// RFC 567343 - WMICore: Remove NCR_ManagementAgent from Application Management MOF
// Revision 1.37 2011/03/07 10:05:11GMT Savage, Gerard (GS515590) 
// Updated MOF to add definitions for NCR_BillInRetained and NCR_CoinInRetained
// Revision 1.36 2011/01/06 15:06:45GMT Patton, Gordon (GP515503) 
// Removed NCR_TransactionFlowPoint and NCR_SessionFlowPoint classes.
// Updated NCR_ConsumerApplicationMetrics and NCR_ServiceElementMetrics to add new properties for cancel/timeout States and Counts.
// Updated NCR_ConsumerApplicationMetrics and NCR_ServiceElementMetrics to remove CancelCount and TimeoutCount methods.
// Revision 1.35 2010/10/04 14:58:50BST Savage, Gerard (GS515590) 
// Activate ISONet is monitored by GASPER . The gasper station needs access to a property showing which currency needs replenishment and is the reason for a service not available.   For example when a machine has Euro and ForeignCurency, and the Euro cassettes are empty, an Integer property is required providing this information to gasper. At the same time the ATM can be in service and conduct transactions with ForeignCurrency. 
// After a email discussion (see attachment) , the following is proposed
// NCR_InstalledCurrency introduces a new boolean property Unavailable that can be used to for the scenario described above. The full class definition then becomes
// Revision 1.34 2010/07/12 10:05:01BST Edwards, Alan (AE162000) 
// RFC 472972 - Update MOF for CRM's TMSPromote WMI implementation RFC 469312
// Revision 1.33 2010/07/01 19:57:34IST Savage, Gerard (gs515590) 
// updated for RFCs: 470870, 457107, 457106, 432433
// Revision 1.32 2010/02/02 17:05:08GMT Grant, Kevin (kg185015) 
// 456242 - Correct names of operations on NCR_FinancialContentCard class
// Revision 1.31 2010/01/19 18:27:08GMT McConnell, Paul (PM410007) 
// Added new classes NCR_ArchiveManager and NCR_ArchiveManagerArchiveNowComplete
// Revision 1.30 2009/12/08 16:13:22GMT Grant, Kevin (kg185015) 
// RFC 451785 - MOF: some status properties are defined as string arrays but should be integer arrays.
// Revision 1.29 2009/12/08 15:14:50GMT Edwards, Alan (AE162000) 
// RFC 451785 - MOF: some status properties are defined as string arrays but should be integer arrays.
// Revision 1.28 2009/12/08 10:24:51GMT Savage, Gerard (GS515590) 
// Added new property to NCR_ServiceElementComplete to display 'ResultAsText'. Also updated 
// Result property to support any result integer - previously it was an enumeration
// Revision 1.27 2009/12/03 11:52:43GMT Grant, Kevin (kg185015) 
// Added xfsCIMSubDeviceNumber and xfsCDMSubDeviceNumber properties
// Revision 1.26 2009/11/26 15:50:22GMT Savage, Gerard (GS515590) 
// NCR_SessionStarted and NCR_SessionComplete events have properties SessionStartTime and 
// SessionCompleteTime . These were declared in MOF as 'date' type (invalid type) properties. 
// These were changed to be of type 'datetime'.
// Revision 1.25 2009/11/26 15:43:41GMT Savage, Gerard (GS515590) 
// changed NCR_ServiceElementComplete Fee & Value properties to have type 'real32'
// Revision 1.24 2009/11/26 15:29:10GMT Savage, Gerard (GS515590) 
// delete duplicat properties for NCR_ConsumerApplicationMetrics and NCR_ServiceElementMetrics
// Revision 1.23 2009/11/20 06:52:37GMT Prasad, E (ep185001) 
// Updated MOF to provide metric information of marketing campaigns - NCR_GenericCampaignMetricInfo
// Revision 1.22 2009/11/20 12:06:04IST Prasad, E (ep185001) 
// Updated MOF to provide metric information of customer responses to targeted campaigns - NCR_CampaignOfferMetricInfo
// Revision 1.21 2009/09/22 14:56:26IST Grant, Kevin (kg185015) 
// Add missing xfsIPMMICRInoperative value to enumeration for xfsIPMMICRReaderStatus property
// Revision 1.20 2009/07/10 14:21:17BST Edwards, Alan (AE162000) 
// RFC 435584 - update NCR_InstalledCurrency to be backwards compatible
// Revision 1.19 2009/07/03 13:07:57BST Grant, Kevin (kg185015) 
// Update NCR_InstalledCurrency class to comply with current WMI spec
// Revision 1.18 2009/07/03 11:40:17BST Savage, Gerard (GS515590) 
// added missing operationd for NCR_InstalledCurrency
// Revision 1.17 2009/06/29 17:02:14BST Savage, Gerard (GS515590) 
// added XFS VDM class definition
// Revision 1.16 2009/06/24 09:09:21BST Savage, Gerard (GS515590) 
// fixed error in NCR_ManagementAgent class and added new definitions for XFS devices (CEU, CRD, BCR, IPM)
// Revision 1.15 2009/06/19 17:33:49BST Savage, Gerard (GS515590) 
// updated to reflect class changes made for revision J of the Application Management Architecture Spec
// Revision 1.14 2009/01/19 12:58:48GMT Edwards, Alan (AE162000) 
// RFC 414126 - Add LastAccessTime[] property to NCR_StateTransitionMetric
// plus removed breaking changes added in revisions 1.12 and 1.13
// Revision 1.13 2008/10/13 15:06:08BST Savage, Gerard (GS515590) 
// Updated description inconsistencies
// Revision 1.12 2008/10/13 09:47:13BST Savage, Gerard (GS515590) 
// Updated wmi definitions for Activate24BI
// Revision 1.11 2008/09/08 12:03:56BST Edwards, Alan (AE162000) 
// RFC 409760 - ApplicationManagement: MOF: remove WMI/DMTF datetime format from descriptions.
// Revision 1.10 2008/09/01 14:28:37BST Edwards, Alan (AE162000) 
// Defect 409141 - remove the "Complete" method defined by the class "NCR_PDInvestigation"
// Revision 1.9 2008/08/11 10:33:21BST Edwards, Alan (AE162000) 
// Defect 404661 - xfsDevice does not define a ValueMap "value" for the Value xfsDevOnline
// Revision 1.8 2008/06/25 15:00:21BST Edwards, Alan (AE162000) 
// RFC 402163 - Rename the method parameter names of NCR ATM to avoid a name clash in MIB file.
// Revision 1.7 2008/06/16 12:54:25BST Edwards, Alan (AE162000) 
// Defect 401588 - NCR Service Element Availability Changed event incorrectly named.
// Revision 1.6 2008/05/09 14:36:45BST Fraser, Donald (df515107) 
// RFC 392386. Added an UnavailabilityDescriptions property to class NCR_ConsumerApplication
// Revision 1.5 2008/04/30 16:33:24BST ae162000 
// Defect 396578 - duplicate trap id for PD events
// Revision 1.4 2008/04/29 12:10:28BST ns162002 
// 396578: Update to correct definitions of WMIPD events in accordance with rev E of AS
// Revision 1.3 2008/04/14 10:27:00BST gs515590 
// Added Availability properties to the NCR_ConnectedHost class.
// Revision 1.2 2008/03/03 17:12:31GMT gs515590 
// ré-fórmáttéd ánd úpdátéd thé XFS WMÍ clássés tó ínclúdé thé SNMP Qúálífíérs
// Revision 1.1 2008/02/25 09:29:04GMT gs515590 
// Initial revision
// Member added to project f:/NCR/FSD/SelfService/SPL/Architecture/AIModules/WMI/MOF/project.pj
// --- Added comments ---  gs515590 [2008/02/25 09:30:00Z]
// reconciled all Application Management WMI Class definitions into one MOF file


// AIModel Created that will contain all WMI Class definitions in one Application Management MOF File

// Declare an instance of the __Win32Provider so as to "register" the
// Provider
#pragma namespace ("\\\\.\\Root\\CIMV2")

// These statements globally (within this MOF) instruct WMI to automatically apply the Flavours specified to the Qualifier
Qualifier Key	             : ToSubClass ToInstance;
Qualifier Locale             : ToSubClass ToInstance;
Qualifier Read               : ToSubClass ToInstance;
Qualifier Dynamic            : ToSubClass ToInstance;
Qualifier Provider           : ToSubClass ToInstance;
Qualifier Implemented        : ToSubClass ToInstance;
Qualifier Association        : ToSubClass ToInstance;
Qualifier SNMPPropertyOffset : ToSubClass ToInstance;
Qualifier SNMPMethodOffset   : ToSubClass ToInstance;   
Qualifier SNMPGroup          : ToSubClass ToInstance;
Qualifier SNMPConcreteClass  : ToSubClass ToInstance;
Qualifier SNMPTrapClass  	 : ToSubClass ToInstance;
Qualifier Description : ToSubClass ToInstance Amended EnableOverride;
Qualifier DisplayName : ToSubClass ToInstance Amended EnableOverride;
Qualifier ValueMap    : ToSubClass ToInstance Amended EnableOverride;
Qualifier Values      : ToSubClass ToInstance Amended EnableOverride;

class NCR_SPL_Event : __ExtrinsicEvent
{
};

[Description("The general NCR Event superclass for all Application Management events.")]
class NCR_ApplicationManagementEvent : NCR_SPL_Event
{
};

[Description("Internal event utilized by WMI Core. This event will never be fired.")]
class NCR_ProviderLoaderEvent : NCR_SPL_Event
{
};

instance of __Win32Provider as $P
{
    Name    = "NCR_WMICoreProvider" ;
    ClsId   = "{2A484489-41FC-48a0-BD82-3FB306307990}" ;
    HostingModel = "NetworkServiceHost";
} ;    


instance of __InstanceProviderRegistration
{
    Provider = $P;
    SupportsPut = FALSE;
    SupportsGet = TRUE;
    SupportsDelete = FALSE;
    SupportsEnumeration = TRUE;
};


// define that same provider supports method invocation
instance of __MethodProviderRegistration
{
    Provider = $P;
};


instance of __Win32Provider as $Q
{
   Name  = "NCR_WMICoreEventProvider";
   Clsid = "{C5F32B12-C23A-4d87-AF3F-27CEDAE38C1E}";
   HostingModel = "NetworkServiceHost";
};


instance of __EventProviderRegistration
{
    Provider = $Q;

    EventQueryList = { "select * from NCR_SPL_Event"};
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////
//////			Consumer and Transaction Management - Group 1
//////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

[ Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("The NCR-specific Application Management subclass from CIM_LogicalElement.")]
class NCR_LogicalElement : CIM_LogicalElement
{
	[read: ToSubClass ToInstance, key,
	Description("Any sub-class must define this attribute as a Key."): ToSubClass ToInstance,
	SNMPPropertyOffset(1)]
	string Name ;

	[read: ToSubClass ToInstance,
	SNMPPropertyOffset(2)]
	string Caption;

};

[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("A Service Element represents any service that can be offered to a consumer. Typically anything that might appear on a consumer selection menu is represented as a Service Element."), 
 SNMPGroup(1),
 SNMPConcreteClass(1)]
class NCR_ServiceElement : NCR_LogicalElement
{
	[read: ToSubClass ToInstance, 
	 Description("Reports whether the ServiceElement is available or not."),
	SNMPPropertyOffset(1) ]
	boolean Availability;

	[read: ToSubClass ToInstance, 
	 Description("An array of strings which contains a series of structured text descriptions describing the reason for the unavailability of this Service Element or any dependent resources."),
	SNMPPropertyOffset(2) ]
	string UnavailabilityDescriptions[];

	[read: ToSubClass ToInstance, 
	 Description("An array of strings which contains a series of structured text descriptions describing the all dependent resources which are available to this Service Element. A Service element may be unavailable even when sub resources are available to it."),
	 SNMPPropertyOffset(3) ]
	string AvailableResources[];

	[read: ToSubClass ToInstance, 
	 Description("Describes the name of the translet associated with this Service Element. The availability of this translet can be queried via NCR_Translet."),
	 SNMPPropertyOffset(4) ]
	string TransletName[];
	
	[read: ToSubClass ToInstance, 
	 Description("Reports whether the ServiceElement is currently Disabled as a result of a call to the Disable operation"),
	 SNMPPropertyOffset(5) ]
	boolean Disabled;	
	
	[read: ToSubClass ToInstance, 
	 Description("Summary of service element state. Note that many of these can occur at the same time. They will be reported in priority from the beginning of the enumeration (i.e. if there is a HWError and NoComms, then HWError is reported).  "),
	 ValueMap {"1", "2", "3", "4", "5"} : ToSubClass ToInstance,
	 Values {"Available", "HWError", "NoComms", "TransletUnavailable", "Unknown"} : ToSubClass ToInstance, 	 
	SNMPPropertyOffset(6) ]
	uint32 StateSummary;		
		
	[read: ToSubClass ToInstance, 
	 Description("Returns an enumerated array that described the list of devices that are used by the transaction, but are currently unavailable"),
	 ValueMap {"1", "2", "3", "4", "5",  "6",  "7",  "8",  "9",  "10",  "11",  "12",  "13",  "14",  "15",  "16" } : ToSubClass ToInstance,
	 Values {"PTR", "IDC", "CDM", "PIN", "CHK", "DEP", "TTU", "SIU", "VDM", "CAM", "ALM", "CEU", "CIM", "CRD", "BCR", "IPM"} : ToSubClass ToInstance, 	 
	SNMPPropertyOffset(7) ]	
	uint32 UnavailableDevices[];

	[implemented: ToSubClass, 
	Description("This operation allows a WMI client to make a Service Element unavailable / available . Note that this is persistent across resets"), 
	SNMPMethodOffset(1)]
	void Disable([Description("Set to TRUE when the service element should not be available (. Set to FALSE to make a service element available after a previous request by the client to force unavailability. This returns the Service Element for normal resource negotiation locally."), in]boolean Inhibit);

};

[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("This represents a logical XFS device. It describes the underlying XFS service associated with this logical device, as well as the associated NCR WMI device classes."), 
 SNMPGroup(1),
 SNMPConcreteClass(2)]
class NCR_ManagedDevice : NCR_LogicalElement
{
	[read: ToSubClass ToInstance, 
	 Description("The XFS Class Name for the associated XFS logical service (logical device)."), 
	 SNMPPropertyOffset(1) ]
	string XFSClassName;

	[read: ToSubClass ToInstance, 
	Description("Reports whether the associated device is an NCR device, and therefore whether NCR WMI information is available."),
	SNMPPropertyOffset(2) ]
	boolean IsNCRDevice ;

	[read: ToSubClass ToInstance ToInstance, 
	 Description("Reports the high level (vendor-independent) status of the device. Does not include replenishment information."),
	 ValueMap {"0", "1", "2", "3", "4", "5", "6" } : ToSubClass ToInstance ,
	 Values {"Online", "Offline", "PowerOff", "NoDevice", "HWError", "UserError", "Busy" } : ToSubClass ToInstance,
	 SNMPPropertyOffset(3)]
	uint32 DeviceStatus;

	[read: ToSubClass ToInstance, 
	 Description("This property will return an array of strings where each string contains the key attribute of an instance of NCR_DeviceReference (KeyId property)."), 
	 SNMPPropertyOffset(4)]
	string NCRDeviceView[];

	[read: ToSubClass ToInstance, 
	 Description("The name for the associated XFS logical service for this device (for example, 'CashDispenser')."), 
	 SNMPPropertyOffset(5)]
	string XFSLogicalServiceName;

	[implemented: ToSubClass, 
	Description("This operation allows a WMI client to make a device unavailable / available for normal resource negotiation. Removes a 'bad actor' device from transaction availability."), 
	SNMPMethodOffset(1)]
	void Disabled([Description("Set to TRUE when the associated device should not be available (but will allow testing to be carried out). Set to FALSE to make a device available after a previous request by the client to force unavailability. This returns the device for normal resource negotiation locally."), in]boolean Inhibit);

	[implemented: ToSubClass, 
	Description("will invoke a 24v reset on the corresponding device. Operation returns failed return code(1) if 24V is not available (i.e. not NCR hardware)"), 
	SNMPMethodOffset(2)]
	uint32 HardReset();
};

[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("For NCR hardware, describes the specific subclass of NCR_Device for the device instance described by this class. This allows more device-specific information to be available to WMI clients."), 
 SNMPGroup(1),
 SNMPConcreteClass(3)]
class NCR_DeviceReference 
{
	[read: ToSubClass ToInstance, 
	 Description("Contains the (key attribute) instance name of an NCR_Device."), 
	 SNMPPropertyOffset(3)]
	string DeviceInstance;

	[read: ToSubClass ToInstance, 
	 Description("The name of the specific subclass of NCR_Device representing this instance. Exposing this information allows WMI clients access to more detailed information about the device."), SNMPPropertyOffset(2) ]
	string DeviceClass ;

	[read: ToSubClass ToInstance, 
	 Key, 
	 Description("The key attribute identifying each NCR_DeviceReference. This is required because there is no guarantee that each NCR_Device::DeviceInstance value is unique across devices."), SNMPPropertyOffset(1) ]
	string KeyId;
};


[Dynamic:ToInstance, Provider("NCR_WMICoreProvider"), 
 Description("Represents a channel application.")]
class NCR_ChannelApplication : NCR_LogicalElement
{
	[read: ToSubClass ToInstance, 
	Description("This property uniquely identifies the process which contains this NCR_ChannelApplication. The property contains the same name as is held in the associated process's NCR_ApplicationProcess::Name property."), 
	SNMPPropertyOffset(1)]
	string ProcessName;
};


[Dynamic:ToInstance, Provider("NCR_WMICoreProvider"), 
 Description("This is a logical consumer application component with responsibility to deliver consumer transactions."),
 SNMPGroup(1),
 SNMPConcreteClass(4)]
class NCR_ConsumerApplication : NCR_ChannelApplication
{
	[read: ToSubClass ToInstance, 
	 Description("This method describes an 'out-of-service' reason for this consumer application."), 
	 SNMPPropertyOffset(1)]
	string OutOfServiceReason;
	
	[read: ToSubClass ToInstance, 
	 Description("The start of the last completed consumer session for this application."), 
	 SNMPPropertyOffset(2)]
	datetime LastSession;
	
	[read: ToSubClass ToInstance, 
	 Description("An array that contains a list of the names of NCR_ServiceElement's that are supported by this application. Name held here is the same as NCR_ServiceElement::Name property."), 
	 SNMPPropertyOffset(3)]
	string ConsumerServiceSet[];
	
	[read: ToSubClass ToInstance, 
	 Description("Describes the current state of the application."),
	 ValueMap {"1", "2", "3", "4", "5"} : ToSubClass ToInstance,
	 Values {"InService", "ConsumerSessionActive", "OutOfService", "NotRunning", "Suspended"} : ToSubClass ToInstance, 
	 SNMPPropertyOffset(4)]
	uint32 CurrentMode;
	
	[read: ToSubClass ToInstance, 
	 Description("An array of strings which contains a series of readable text descriptions describing the reason for the unavailability of this Consumer Application."),
	SNMPPropertyOffset(5) ]
	string UnavailabilityDescriptions[];
	
	[read: ToSubClass ToInstance, 
	 Description("Summary of application state. Note that many of these can occur at the same time. They will be reported in priority from the beginning of the enumeration (i.e. if there is a HW Error and InSupervisor, then InSupervisor is reported). "),
	 ValueMap {"1", "2", "3", "4", "5", "6", "7", "8" } : ToSubClass ToInstance,
	 Values {"InService", "InSupervisor", "Disabled", "HWError", "NoComms","MissingTerminalId", "MissingSecurityKey", "Unknown"} : ToSubClass ToInstance, 	 
	SNMPPropertyOffset(6) ]
	uint32 ApplicationStateSummary;	

	[read: ToSubClass ToInstance, 
	 Description("Returns an enumerated array that described the list of devices that are used by the application, but are currently unavailable"),
	 ValueMap {"1", "2", "3", "4", "5",  "6",  "7",  "8",  "9",  "10",  "11",  "12",  "13",  "14",  "15",  "16" } : ToSubClass ToInstance,
	 Values {"PTR", "IDC", "CDM", "PIN", "CHK", "DEP", "TTU", "SIU", "VDM", "CAM", "ALM", "CEU", "CIM", "CRD", "BCR", "IPM"} : ToSubClass ToInstance, 	 
	SNMPPropertyOffset(7) ]	
	uint32 UnavailableDevices[];
	
	[implemented: ToSubClass, 
	Description("This operation allows a WMI client to disable a Consumer Application (i.e. no services offered). Note that call to Disable(false) will not necessarily put application back in service. Will only remove disable lock. Note that this is persistent across resets"), 
	SNMPMethodOffset(1)]
	void Disable([Description("Set to TRUE when the application should not be available (. Set to FALSE to make a consumer application available after a previous request by the client to force unavailability. This returns the consumer applicaton for normal resource negotiation locally."), in]boolean Inhibit);
	
};




[Dynamic:ToInstance, Provider("NCR_WMICoreProvider"), 
 Description("This represents an application process."), 
 SNMPGroup(1),
 SNMPConcreteClass(5)]
class NCR_ApplicationProcess : NCR_LogicalElement
{
	[read: ToSubClass ToInstance, 
	 Description("Describes the unique process identifier that is associated with this process (as defined in Win32_Process.ProcessId)."),
	 SNMPPropertyOffset(1)]
	uint32 ProcessId;
};

[Dynamic:ToInstance, Provider("NCR_WMICoreProvider"), 
 Description("This represents the process responsible for Heartbeat Management on the ATM."),  
 SNMPGroup(1),
 SNMPConcreteClass(6)]
class NCR_HeartBeatProcess : NCR_LogicalElement
{
	[read: ToSubClass ToInstance, 
	 Description("Defines, in seconds, the interval at which the HeartBeat Process will generate a heartbeat. A value of zero indicates no heartbeat."),
	 SNMPPropertyOffset(1)]
	uint32 HeartBeatPeriod;


	[implemented: ToSubClass, 
	 Description("This method allows the heartbeat interval (i.e. the interval at the HeartBeat Process reports the NCR_ATMHeartBeat event) property to be set by a consumer of the WMI Class."), 
	 SNMPMethodOffset(1)]
	void set_HeartBeatPeriod([Description("Heartbeat interval in seconds."), in]uint32 HeartBeatInterval);
};

[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("The NCR_Translet class describes the management availability information associated with an AccountTranslet component. Each NCR_Translet is identified via the inherited CIM_LogicalElement::Name. This property is based upon the underlying account translets TransletID. The same value is used by the Account Translet when it reports its ManagedName property via the ManagedResource interface."),
 SNMPGroup(1),
 SNMPConcreteClass(7)]
class NCR_Translet : NCR_LogicalElement
{
	[read: ToSubClass ToInstance, 
	Description("Reports whether the translet is available or not."),
	SNMPPropertyOffset(1) ]
	boolean Availability;

	[read: ToSubClass ToInstance, 
	Description("An array of strings which contains a series of structured text descriptions describing the reason for the unavailability of this translet."),
	SNMPPropertyOffset(2) ]
	string UnavailabilityDescriptions[];
};

[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("This describes all clients that are currently inhibiting Consumer access to terminal. This will typically list all those components that have taken the consumer application out of service to take some parallel activity. For example, to begin a software download")]
class NCR_ConsumerAccessInhibiters : NCR_LogicalElement
{
	[read: ToSubClass ToInstance, 
	Description("A collection of unique identifiers that describe the client components that are currently inhibiting the Consumer Application")]
	string ClientIds[];
};

//////////////////////////////////////////
//////////////////////////////////////////
// Events
//////////////////////////////////////////
//////////////////////////////////////////

[Description("This event class introduces the common attributes supported by all events generated in relation to NCR_ChannelApplication.")]
class NCR_ChannelApplicationEvent : NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, Description("The name of the NCR_ChannelApplication associated with this event as defined in the NCR_ChannelApplication::Name property."), SNMPPropertyOffset(1)]
	string ApplicationName;
};

[Description("This event reports on the success of a WMI client request to make a device represented by NCR_ManagedDevice unavailable (or available) for normal local, resource negotiation."), 
 SNMPGroup(1),
 SNMPTrapClass(1)]
class NCR_ManagedDeviceDisabled : NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	 Description("TRUE when the device is no longer available for local resource negotiation  (i.e. after a call to NCR_ManagedDevice::Disabled(TRUE)). False when the device is available for local resource negotiation (i.e. after a call to NCR_ManagedDevice::Disabled(FALSE))."), 
	 SNMPPropertyOffset(1)]
	boolean Inhibited;

	[read: ToSubClass ToInstance, 
	 Description("Unique Identifier describing the NCR_ManagedDevice instance. This is the key property which uniquely identifies this NCR_ManagedDevice instance within the context of the enclosing application."), 
	 SNMPPropertyOffset(2)]
	string ManagedDeviceName;

};

[Description("This event will be generated when a service element changes its availability from available to unavailable, etc."), 
 SNMPGroup(1),
 SNMPTrapClass(2)]
class NCR_ServiceElementAvailabilityChanged : NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	 Description("The name of the service element as defined in NCR_ServiceElement::Name."), 
	 SNMPPropertyOffset(1)]
	string ServiceElementName;

	[read: ToSubClass ToInstance, 
	 Description("The service element availability. if TRUE then the service element is available, FALSE indicates the service element is unavailable."), 
	 SNMPPropertyOffset(2)]
	boolean Available;

	[read: ToSubClass ToInstance, 
	 Description("The name of the NCR_ConsumerApplication that contains this service element."), 
	 SNMPPropertyOffset(3)]
	string ConsumerApplicationName;
	
	[read: ToSubClass ToInstance, 
	 Description("Summary of service element state. Note that many of these can occur at the same time. They will be reported in priority from the beginning of the enumeration (i.e. if there is a HWError and NoComms, then HWError is reported).  "),
	 ValueMap {"1", "2", "3", "4", "5"} : ToSubClass ToInstance,
	 Values {"Available", "HWError", "NoComms", "TransletUnavailable", "Unknown"} : ToSubClass ToInstance, 	 
	SNMPPropertyOffset(4) ]
	uint32 StateSummary;

	[read: ToSubClass ToInstance, 
	 Description("Returns an enumerated array that described the list of devices that are used by the transaction, but are currently unavailable"),
	 ValueMap {"1", "2", "3", "4", "5",  "6",  "7",  "8",  "9",  "10",  "11",  "12",  "13",  "14",  "15",  "16" } : ToSubClass ToInstance,
	 Values {"PTR", "IDC", "CDM", "PIN", "CHK", "DEP", "TTU", "SIU", "VDM", "CAM", "ALM", "CEU", "CIM", "CRD", "BCR", "IPM"} : ToSubClass ToInstance, 	 
	SNMPPropertyOffset(6) ]	
	uint32 UnavailableDevices[];	
};



[Description("This event is generated by a heartbeat process and represents that the ATM Processor is still active."), 
 SNMPGroup(1),
 SNMPTrapClass(3)]
class NCR_ATMHeartBeat : NCR_ApplicationManagementEvent
{
};


[Description("This event is generated for free-form backwards compatible IApplicationManagement2 application events."), 
 SNMPGroup(1),
 SNMPTrapClass(4)]
class NCR_ApplicationEvent : NCR_ChannelApplicationEvent
{
	[read: ToSubClass ToInstance, 
	 Description("Textual description of the event."), 
	 SNMPPropertyOffset(1)]
	string Reason;
};


[Description("This event is generated when an NCR_ConsumerApplication changes state."), 
 SNMPGroup(1),
 SNMPTrapClass(5)]
class NCR_ConsumerAppModeChange : NCR_ChannelApplicationEvent
{
	[read: ToSubClass ToInstance, 
	Description("Describes the new mode of the consumer application. See NCR_ConsumerMode enumeration class for details."), 
	ValueMap {"1", "2", "3", "4", "5"} ,
	Values {"InService", "ConsumerSessionActive", "OutOfService","NotRunning","Suspended"} , 
	SNMPPropertyOffset(1)]
	uint32 CurrentMode;
	
	[read: ToSubClass ToInstance, 
	 Description("Summary of application state. Note that many of these can occur at the same time. They will be reported in priority from the beginning of the enumeration (i.e. if there is a HW Error and InSupervisor, then InSupervisor is reported). "),
	 ValueMap {"1", "2", "3", "4", "5", "6", "7", "8"} : ToSubClass ToInstance,
	 Values {"InService", "InSupervisor", "Disabled", "HWError", "NoComms","MissingTerminalId", "MissingSecurityKey", "Unknown"} : ToSubClass ToInstance, 	 
	SNMPPropertyOffset(2) ]
	uint32 ApplicationStateSummary;	

		[read: ToSubClass ToInstance, 
	 Description("Returns an enumerated array that described the list of devices that are used by the application, but are currently unavailable"),
	 ValueMap {"1", "2", "3", "4", "5",  "6",  "7",  "8",  "9",  "10",  "11",  "12",  "13",  "14",  "15",  "16" } : ToSubClass ToInstance,
	 Values {"PTR", "IDC", "CDM", "PIN", "CHK", "DEP", "TTU", "SIU", "VDM", "CAM", "ALM", "CEU", "CIM", "CRD", "BCR", "IPM"} : ToSubClass ToInstance, 	 
	SNMPPropertyOffset(7) ]	
	uint32 UnavailableDevices[];
};


[Description("This event will be generated when a translet changes its availability from available to unavailable, etc. Note that this event can occur for transient reasons. For example, a translet  may not be available to a particular consumer and so this event will be generated to indicate unavailability during a session with that consumer. It is recommended that management clients check service availability when no consumer session is active (via NCR_ConsumerApplication.CurrentMode)."), 
 SNMPGroup(1),
 SNMPTrapClass(6)]
class NCR_TransletAvailabilityChange : NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	 Description("The name of the translet as defined in NCR_Translet::Name."), 
	 SNMPPropertyOffset(1)]
	string TransletName;

	[read: ToSubClass ToInstance,  
	 Description("The translet availability. if TRUE then the translet is available, FALSE indicates unavailable."), 
	 SNMPPropertyOffset(2)]
	boolean Available;

	[read: ToSubClass ToInstance, 
	 Description("An array of strings which contains a series of structured text descriptions describing the reason for the unavailability of the translet."), 
	 SNMPPropertyOffset(3)]
	string UnAvailabilityDescriptions[];
};


[Description("This event is generated by a heartbeat process when it detects that a local application process has frozen."), 
 SNMPGroup(1),
 SNMPTrapClass(7)]
class NCR_ApplicationHeartBeatCeased : NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	 Description("Describes the name of the associated application process as defined by NCR_ChannelApplication::ProcessName."), 
	 SNMPPropertyOffset(1)]
	string ApplicationProcessName;
};

[Description("This event is generated as a result of a call to NCR_ManagedDevice::HardReset"), 
 SNMPGroup(1),
 SNMPTrapClass(8)]
class NCR_DeviceHardResetComplete: NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	 Description("Name of device that has been reset"), 
	 SNMPPropertyOffset(1)]
	string ManagedDeviceName;
	
	[read: ToSubClass ToInstance ToInstance, 
	 Description("Reports the high level (vendor-independent) status of the device. "),
	 ValueMap {"0", "1", "2", "3", "4", "5", "6" } : ToSubClass ToInstance ,
	 Values {"Online", "Offline", "PowerOff", "NoDevice", "HWError", "UserError", "Busy" } : ToSubClass ToInstance,
	 SNMPPropertyOffset(2)]
	uint32 Status;	
};

[Description("This event reports on the success of a WMI client request to make a service element represented by NCR_ServiceElement unavailable (or available) "), 
 SNMPGroup(1),
 SNMPTrapClass(9)]
class NCR_ServiceElementDisabled : NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	 Description("TRUE when the Service Element is no longer available (i.e. after a call to NCR_ServiceElement::Disable(TRUE)). False when the service element is available  (i.e. after a call to NCR_ServiceElement::Disable(FALSE))."), 
	 SNMPPropertyOffset(1)]
	boolean Inhibited;

	[read: ToSubClass ToInstance, 
	 Description("Unique Identifier describing the NCR_ServiceElement instance. This is the key property which uniquely identifies this NCR_ServiceElement instance within the context of the enclosing application."), 
	 SNMPPropertyOffset(2)]
	string Name;

};

[Description("This event reports that an application has been inactive (no consumer session) for a long time without being out of service. This event can be used to detect environmental factors that may prevent users from starting a transaction, for example a truck parked in front of an ATM, an ATM where the screen does not function (if this cannot be reported separately), or where the staff have pasted an out of service paper up on the screen, obviously without the central server knowing about it"), 
 SNMPGroup(1),
 SNMPTrapClass(10)]
class NCR_UnexpectedInactivity : NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	 Description("The name of the application associated with the event"), 
	 SNMPPropertyOffset(1)]
	string ApplicationName;

	[read: ToSubClass ToInstance, 
	 Description("The length of time, in minutes, that the application has been inactive"), 
	 SNMPPropertyOffset(2)]
	uint32 InactivityTime;

};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////
//////			Financial Supplies Management - Group 2
//////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



[Dynamic:ToInstance, 
 Description("Represents the financial supplies content (or a subset of the content) held within an ATM. It reports the financial position of the specified subset of the ATM's content."), 
 Provider("NCR_WMICoreProvider")]
class NCR_FinancialSuppliesContent
{
	[read: ToSubClass ToInstance, 
	key,
	Description("This property contains an identifier that can be used to uniquely identify each NCR_FinancialSuppliesContent instance."), 
	SNMPPropertyOffset(1)]
	string ContentIdentifier;

	[read: ToSubClass ToInstance,Description("The timestamp when last replenished."), 
	SNMPPropertyOffset(2)]
	datetime LastReplenishment;
};


[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("This class will report the last time the card capture bin was emptied."),
 SNMPGroup(2),
 SNMPConcreteClass(1)]
class NCR_FinancialContentCard : NCR_FinancialSuppliesContent
{
	[read: ToSubClass ToInstance, 
	 Description("The TriggerValues property holds the set of triggers that are monitored "), 
	 SNMPPropertyOffset(1) ]
	uint32 TriggerValues[];
	
	[read: ToSubClass ToInstance, 
	 Description("The TriggerNames property holds the names of the Triggers held in the corresponding offset of TriggerValues."), 
	 SNMPPropertyOffset(2) ]
	string TriggerNames[];
	
	[implemented: ToSubClass, 
	 Description("This method is used to define a trigger value and an associated, descriptive name."), 
	 SNMPMethodOffset(1)]
	void Set_Trigger([Description("Descriptive name of Trigger to be added. If it already exists it is overwritten"), in]string TriggerName, [Description("The trigger level  to be added."), in]uint32 TriggerAmount);	

	[implemented: ToSubClass, 
	 Description("This method removes the specified trigger name."), 
	 SNMPMethodOffset(2)]
	void Remove_Trigger([Description(" name of Trigger to be removed. ignored if not present"), in]string TriggerName);	
};


[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("Identifes the content as relating to dispensed coins."),  
 SNMPGroup(2),
 SNMPConcreteClass(2)]
class NCR_FinancialContentCoinOut : NCR_FinancialSuppliesContent
{
	[read: ToSubClass ToInstance,Description("Refers to an instance of NCR_Financial Denomination that describes the denomination associated with this class. The name held here is the same as the NCR_FinancialDenomination::Name property."), 
	SNMPPropertyOffset(1)]
	string Denomination;
};


[Dynamic:ToInstance, Provider("NCR_WMICoreProvider"), Description("Identifes the content as relating to notes that have not been dispensed."),  
 SNMPGroup(2),
 SNMPConcreteClass(3)]
class NCR_DispensableBills : NCR_FinancialSuppliesContent
{
	[read: ToSubClass ToInstance,
	Description("Refers to the NCR_Financial Denominations that describes the denomination associated with this class. The name held here is the same as the NCR_FinancialDenomination::Name property."), 
	SNMPPropertyOffset(1)]
	string Denomination;
	

};


[Dynamic:ToInstance, Provider("NCR_WMICoreProvider"), Description("Identifies the content as relating to inserted cash notes."),
 SNMPGroup(2),
 SNMPConcreteClass(4)]
class NCR_FinancialContentCashIn : NCR_FinancialSuppliesContent
{
	[read: ToSubClass ToInstance,
	Description("An array that contains a list of the names of NCR_FinancialDenomination that are supported by this class. Name held here is the same as NCR_FinancialDenomination::Name property."), 
	SNMPPropertyOffset(1)]
	string Denominations[];
};




[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("Exposes the common properties that describe a currency denomination."),    
 SNMPGroup(2),
 SNMPConcreteClass(5)]
class NCR_FinancialDenomination
{
	[read: ToSubClass ToInstance,
	Description("Specifies the ISO 4217 currency identifier for the currency."), 
	SNMPPropertyOffset(2)]
	string CurrencyId;

	[read: ToSubClass ToInstance,
	Description("Unique name identifying a currency denomination type."), 
	SNMPPropertyOffset(1), key]
	string Name;

	[read: ToSubClass ToInstance,
	Description("Returns the ISO 4217 currency identifier exponent for the currency."), 
	SNMPPropertyOffset(3) ]
	uint32 CurrencyExponent;

	[read: ToSubClass ToInstance,
	Description("Specifies the value of the dispensable unit of currency."), 
	SNMPPropertyOffset(4) ]
	uint32 CurrencyValue;

	[read: ToSubClass ToInstance,
	Description("Returns the number of items currently held."), 
	SNMPPropertyOffset(5) ]
	uint32 NumberOfItems;

	[read: ToSubClass ToInstance,
	Description("The number of notes entered for the last replenishment action for this type."), 
	SNMPPropertyOffset(6) ]
	uint32 LastReplenishmentItemCount;

	[read: ToSubClass ToInstance,
	Description("Defines the type of bill (cash, document or coupon)."), 
	ValueMap {"1", "2", "4"} : ToSubClass ToInstance,
	Values {"Cash", "Document", "Coupon"} : ToSubClass ToInstance,
	SNMPPropertyOffset(7) ]
	uint32 Type;

	[read: ToSubClass ToInstance,
	Description(""), 
	SNMPPropertyOffset(8) ]
	string TriggerNames[];	

	[read: ToSubClass ToInstance,
	Description(""), 
	SNMPPropertyOffset(9) ]
	uint32 TriggerValues[];	
	
	
	[implemented: ToSubClass, 
	 Description("This method is used to define a trigger value and an associated, descriptive name."), 
	 SNMPMethodOffset(1)]
	void Set_Trigger([Description("Descriptive name of Trigger to be added. If it already exists it is overwritten"), in]string TriggerName, [Description("The trigger level  to be added."), in]uint32 TriggerAmount);	

	[implemented: ToSubClass, 
	 Description("This method removes the specified trigger name."), 
	 SNMPMethodOffset(2)]
	void Remove_Trigger([Description(" name of Trigger to be removed. ignored if not present"), in]string TriggerName);		
};




[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("The NCR_ReplenishDenomProfile contains all relevant information that will allow a CS to enter the required replenishment information for a cash in cash unit (cassette)."), 
 SNMPGroup(2),
 SNMPConcreteClass(6)]
class NCR_ReplenishDenomProfile
{
	[read: ToSubClass ToInstance,
	Description("Specifies the ISO 4217 currency identifier for the currency."), 
	SNMPPropertyOffset(2)]
	string CurrencyId;

	[read: ToSubClass ToInstance,
	Description("Unique name identifying a currency replenishment activity (e.g. $5 notes for cassette 2)."), 
	SNMPPropertyOffset(1), 
	key]
	string Name;

	[read: ToSubClass ToInstance,
	Description("Returns the ISO 4217 currency identifier exponent for the currency."), 
	SNMPPropertyOffset(3) ]
	uint32 CurrencyExponent;

	[read: ToSubClass ToInstance,
	Description("Specifies the value of the dispensable unit of currency."), 
	SNMPPropertyOffset(4) ]
	uint32 CurrencyValue;

	[read: ToSubClass ToInstance,
	Description("Returns the number of items that this replenishment activity will contain."), 
	SNMPPropertyOffset(5) ]
	uint32 NumberOfItems;

	[read: ToSubClass ToInstance,
	Description("The bill type contained in the cash-in unit."), 
	ValueMap {"1", "2", "4"} : ToSubClass ToInstance,
	Values {"Cash", "Document", "Coupon"} : ToSubClass ToInstance,
	SNMPPropertyOffset(6) ]
	uint32 Type;
};



[Dynamic:ToInstance, Provider("NCR_WMICoreProvider"), 
 Description("Manages the valuable media replenishment activity."), 
 SNMPGroup(2),
 SNMPConcreteClass(7)]
class NCR_ReplenishmentSchedule
{
	[read: ToSubClass ToInstance, 
	 key, 
	 Description("Unique Identifier for this singleton class. Always returns one."), 
	 SNMPPropertyOffset(1)]
	uint32 Id;

	[read: ToSubClass 
	 ToInstance,
	 Description("Date on next scheduled replenishment activity."), 
	 SNMPPropertyOffset(2)]
	datetime NextScheduleDate;

	[implemented: ToSubClass, 
	 Description("Creates NCR_ReplenishDenomProfiles. The operation parameters are used to set the profile's property values."), 
	 SNMPMethodOffset(1)]
	void Create_Replenishment([in]string Name, [in]uint32 CurrencyExponent, [in]uint32 CurrencyValue, [in]string CurrencyId, [in]uint32 NumberOfItems);

	[implemented: ToSubClass,
 	 Description("Deletes all NCR_ReplenishDenomProfile instances. Typically called after a replenishment activity when the profiles are no longer required."), 
	 SNMPMethodOffset(2)]
	void Clear();

	[implemented: ToSubClass, 
	 Description("Allows remote setting of the next schedule date for replenishment. All instances of NCR_ReplenishDenomProfile should be used on replenishment activity on or before this date."), 
	 SNMPMethodOffset(3)]
	void Set_ReplenishmentDate([in]datetime Visit);

};


[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("Identifies the content as relating to deposited media (i.e. envelopes, bags or documents such as cheques)."),
 SNMPGroup(2),
 SNMPConcreteClass(8)]
class NCR_FinancialContentIn : NCR_FinancialSuppliesContent
{
	[read: ToSubClass ToInstance,
	 Description("This reports the value of the media which must be met or exceeded in the container before the associated event (NCR_DepositValueExceeded) is triggered. The event is triggered when the value in NCR_FinancialSuppliesContent::TotalValue exceeds this property value."), 
	 SNMPPropertyOffset(1) ]
	uint32 ContentTriggerValue;

	[read: ToSubClass ToInstance,
	 Description("Returns the total value for all items in this subset of the content. Defined in multiples of CurrencyValue."), 
	 SNMPPropertyOffset(2) ]
	uint32 TotalValue;

	[implemented: ToSubClass, 
	 Description("This method is used to set a value which, when met or exceeded will trigger an event that reports that the contents of the anonymous valuable content container (e.g. depository) has exceeded the specified value.The event is triggered when the value in NCR_FinancialSuppliesContent::TotalValue exceeds this property value."), 
	 SNMPMethodOffset(1)]
	void set_ContentTriggerValue([Description("The trigger level amount."), in]uint32 TriggerAmount);
};



[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("Each instance of this class describes a dispensable currency installed on the SST."),
 SNMPGroup(2),
 SNMPConcreteClass(9)]
class NCR_InstalledCurrency 
{
	[read: ToSubClass ToInstance,
	 key, 
	 Description("Specifies the ISO 4217 currency identifier for the currency."), 
	 SNMPPropertyOffset(1)]
	string CurrencyId;

	[read: ToSubClass ToInstance, 
	 Description("The CurrencyTriggers property holds the set of triggers that are monitored for this currency.") ]
	uint32 CurrencyTriggers[];
	
	[read: ToSubClass ToInstance, 
	 Description("The TriggerValues property holds the set of triggers that are monitored for this currency."), 
	 SNMPPropertyOffset(2)]
	uint32 TriggerValues[];

	[read: ToSubClass ToInstance, 
	 Description("The TriggerNames property holds the names of the Triggers held in the corresponding offset of TriggerValues."), 
	 SNMPPropertyOffset(3)]
	string TriggerNames[];
	
	[read: ToSubClass ToInstance, 
	 Description("The Unavailable property reports true when the currency cannot be dispensed for any reason"), 
	 SNMPPropertyOffset(4) ]
	boolean Unavailable;	
	
	[implemented: ToSubClass, 
	 Description("This method is used to define a trigger value and an associated, descriptive name.")]
	void Set_CurrencyTrigger([Description("Descriptive name of Trigger to be added. If it already exists it is overwritten"), in]string TriggerName, [Description("The trigger level  to be added."), in]uint32 TriggerAmount);	

	[implemented: ToSubClass, 
	 Description("This method removes the specified trigger name.")]
	void Remove_CurrencyTrigger([Description(" name of Trigger to be removed. ignored if not present"), in]string TriggerName);		
};




//////////////////////////////////////////
//////////////////////////////////////////
// Events
//////////////////////////////////////////
//////////////////////////////////////////

[Description("This event introduces the behaviour for events indicating valuable media capture.")]
class NCR_ValuableMediaRetained : NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	 Description("Contains any descriptive text associated with the NCR_ValuableMediaRetained event."), 
	 SNMPPropertyOffset(1)]
	string Description;
};


[Description("This event is generated after a deposit when the value of the media within the device has exceeded the specified value. This event can occur for anonymous deposits or document (e.g. cheque deposits). This is unrelated to the physical capacity of the associated device bin."),    
 SNMPGroup(2),
 SNMPTrapClass(1)]
class NCR_DepositValueExceeded : NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
 	 Description("Identifies the  NCR_FinancialSuppliesContent instance that is associated with this event (matches NCR_FinancialSuppliesContent::ContentIdentifier)."), 
	 SNMPPropertyOffset(1)]
	string ContentIdentifier;
};


[Description("Event generated when valuable documents (e.g. cheques) are retained. This indicates that, though the associated device is not in error, the application has detected suspect behaviour which means the cheque is retained without further processing."), 
 SNMPGroup(2),
 SNMPTrapClass(2)]
class NCR_DocumentRetained : NCR_ValuableMediaRetained 
{
};


[Description("Event generated when coins are retained."),  
 SNMPGroup(2),
 SNMPTrapClass(3)]
class NCR_CoinOutRetained : NCR_ValuableMediaRetained 
{
};


[Description("Event generated when a card is retained."),  
 SNMPGroup(2),
 SNMPTrapClass(4)]
class NCR_CardRetained : NCR_ValuableMediaRetained 
{
	[read: ToSubClass ToInstance,
	Description("Describes the reason that a card was retained"), 
	ValueMap {"1", "2", "3", "4", "5"} : ToSubClass ToInstance,
	Values {"Expired", "HotCard", "HostRequest", "PowerDown", "Unknown"} : ToSubClass ToInstance, 
	SNMPPropertyOffset(1)]
	uint32 CaptureReason;
};


[Description("Generated when bills have been dispensed to the exit slot of the ATM (and exposed to the consumer) which are subsequently retracted."),  
 SNMPGroup(2),
 SNMPTrapClass(5)]
class NCR_BillOutRetained : NCR_ValuableMediaRetained 
{
	[read: ToSubClass ToInstance,
	Description("Identifies the type of note that has been retained i.e. cash, valuable documents (e.g. tickets) or coupons without face value."), 
	ValueMap {"1", "2", "4"} : ToSubClass ToInstance,
	Values {"Cash", "Document", "Coupon"} : ToSubClass ToInstance, 
	SNMPPropertyOffset(1)]
	uint32 Type;
	

};

[Description("Event generated when deposited bills are retained. This indicates that, though the associated device is not in error, the application has detected suspect behaviour which means the bill(s) are retained without further processing")]
class NCR_BillInRetained : NCR_ValuableMediaRetained 
{
};

[Description("Event generated when deposited coins are retained. This indicates that, though the associated device is not in error, the application has detected suspect behaviour which means the coin(s) are retained without further processing")]
class NCR_CoinInRetained : NCR_ValuableMediaRetained 
{
};


[Description("This event is generated when the total value of the described currency drops below a trigger value defined in NCR_InstalledCurrency. This is unrelated to the physical capacity of the associated device bin."),  SNMPGroup(2),
 SNMPTrapClass(6)]
class NCR_CurrencyTriggerReached : NCR_ApplicationManagementEvent 
{
	[read: ToSubClass ToInstance, 
	 Description("Specifies the ISO 4217 currency identifier for the currency."), 
	 SNMPPropertyOffset(1)]
	string CurrencyId;

	
	[read: ToSubClass ToInstance, 
	 Description("The name of the trigger threshold which has been crossed."), 
	 SNMPPropertyOffset(2)]
	string TriggerName;

	
	[read: ToSubClass ToInstance, 
	 Description("The currency value threshold which has been crossed."), 
	 SNMPPropertyOffset(3) ]
	uint32 TriggerReached;
};

[Description("This event is generated after a replenishment and reports the highest defined trigger value that was crossed as a result of the replenishment"),  SNMPGroup(2),
 SNMPTrapClass(8)]
class NCR_CurrencyReplenishmentTrigger : NCR_ApplicationManagementEvent 
{
	[read: ToSubClass ToInstance, 
	 Description("Specifies the ISO 4217 currency identifier for the currency."), 
	 SNMPPropertyOffset(1)]
	string CurrencyId;

	
	[read: ToSubClass ToInstance, 
	 Description("The name of the highest trigger threshold which has been crossedas a result of the replenishment"), 
	 SNMPPropertyOffset(2)]
	string TriggerName;

	
	[read: ToSubClass ToInstance, 
	 Description("The currency value threshold which has been crossed."), 
	 SNMPPropertyOffset(3) ]
	uint32 TriggerReached;
};

[Description("This event is generated when the number of cards captured passes a trigger value described in NCR_FinancialContentCard. This is unrelated to the physical capacity of the associated device bin."),  SNMPGroup(2),
 SNMPTrapClass(9)  ]
class NCR_CardCaptureTriggerReached : NCR_ApplicationManagementEvent 
{
	[read: ToSubClass ToInstance, 
	 Description("The name of the trigger threshold which has been crossed.")]
	string TriggerName;

	
	[read: ToSubClass ToInstance, 
	 Description("The currency value threshold which has been crossed.")]
	uint32 TriggerReached;
};


[Description("This event is generated when the total value of the described denomination drops below a trigger value defined in NCR_FinancialDenomination"),  SNMPGroup(2),
 SNMPTrapClass(7)]
class NCR_DenominationTriggerReached : NCR_ApplicationManagementEvent 
{
	[read: ToSubClass ToInstance, 
	 Description("Specifies the name of the denomination"), 
	 SNMPPropertyOffset(1)]
	string Denomination;
	
	[read: ToSubClass ToInstance, 
	 Description("The name of the trigger threshold which has been crossed."), 
	 SNMPPropertyOffset(2)]
	string TriggerName;

	[read: ToSubClass ToInstance, 
	 Description("The  value threshold which has been crossed."), 
	 SNMPPropertyOffset(3) ]
	uint32 TriggerReached;
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////
//////			Channel Usability Management - Group 3
//////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



[Dynamic:ToInstance, Provider("NCR_WMICoreProvider"), 
 Description("This class supplies any relevant metric information which can be used for reviewing application usability."),  
 SNMPGroup(3),
 SNMPConcreteClass(1)]
class NCR_ConsumerApplicationMetrics : CIM_StatisticalInformation
{
	[read: ToSubClass ToInstance, 
	key,
	Description("Any sub-class must define this attribute as a Key."): ToSubClass ToInstance,
	SNMPPropertyOffset(1)]
	string Name ;

	[read: ToSubClass ToInstance,
	SNMPPropertyOffset(2)]
	string Caption;

	[read: ToSubClass ToInstance,
	Description("The number of sessions completed successfully since last count reset."), 
	SNMPPropertyOffset(3)]
	uint32 SessionCount;

	[read: ToSubClass ToInstance,
	Description("The timestamp of last count reset."), 
	SNMPPropertyOffset(4)]
	datetime ResetCountsDate;

	[read: ToSubClass ToInstance,
	Description("The count of all transactions that have occurred for this channel application since last count reset."), 
	SNMPPropertyOffset(5)]
	uint32 NumberOfTransactions;

	[read: ToSubClass ToInstance,
	Description("The timestamp of the last successfully completed transaction for this channel application since last count reset."), 
	SNMPPropertyOffset(6)]
	datetime LastTransaction;

	[read: ToSubClass ToInstance,
	Description("This count is used to describe the number of failed sessions will occur, in sequence, before an event may be generated."), 
	SNMPPropertyOffset(7)]
	uint32 FailedSessionTrigger;
	
	[read: ToSubClass ToInstance,
	Description("The number of times a consumer session has failed to complete successfully since last count reset."), 
	SNMPPropertyOffset(8)]
	uint32 FailedSessionCount;


	[read: ToSubClass ToInstance,
	Description("Minimum time taken to complete a consumer session"), 
	SNMPPropertyOffset(9)]
	uint32 MinDuration;
	
	[read: ToSubClass ToInstance,
	Description("Maximum time to complete a consumer session"), 
	SNMPPropertyOffset(10)]
	uint32 MaxDuration;
	
	[read: ToSubClass ToInstance,
	Description("Average time to complete a consumer session"), 
	SNMPPropertyOffset(11)]
	uint32 AverageDuration;
	
	[read: ToSubClass ToInstance,
	Description("The states at which the consumer cancelled the session. The number and order of entries in CancelStates is the same as in CancelCounts."), 
	SNMPPropertyOffset(12)]
	string CancelStates[];
	
	[read: ToSubClass ToInstance,
	Description("The number of times each state in CancelStates has been triggered. The number and order of entries in CancelCounts is the same as in CancelStates."), 
	SNMPPropertyOffset(13)]
	uint32 CancelCounts[];
	
	[read: ToSubClass ToInstance,
	Description("The states that timed out waiting for a consumer response (resulting in a failed session). The number and order of entries in TimeoutStates is the same as in TimeoutCounts."), 
	SNMPPropertyOffset(14)]
	string TimeoutStates[];
	
	[read: ToSubClass ToInstance,
	Description("The number of times each state in TimeoutStates has been triggered. The number and order of entries in TimeoutCounts is the same as in TimeoutStates."), 
	SNMPPropertyOffset(15)]
	uint32 TimeoutCounts[];
	
	[implemented: ToSubClass, 
	Description("Reset all counts to zero."), 
	SNMPMethodOffset(1)]
	void ResetCounts();
	
	[implemented: ToSubClass, 
	Description("Sets the value of the FailedSessionTrigger property. Allows management clients to define when they want NCR_FailedSessionTrigger events. For example, if you wish to detect every consumer cancel or timeout then this value should be set to one."), 
	SNMPMethodOffset(2)]
	void set_FailedSessionTrigger([Description("Defines the number of failed sessions that have to occur, in sequence, before an event may be generated."), in]uint32 Trigger);		

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////			
//////	CancelCount and TimeoutCount removed for RFC 473786. No implementation of NCR_TransactionFlowPoint or NCR_SessionFlowPoint
//////	was ever available so 'non-breaking' change.
//////			
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//	[implemented: ToSubClass, 
//	Description("The number of times a cancel has occurred at the specified session point since last count reset."), 
//	SNMPMethodOffset(3)]
//	uint32 CancelCount([Description("Defines the session stage this count is associated with. This value will match the NCR_SessionFlowPoint::Name property of one of the NCR_SessionFlowPoints instances."), in]string FlowPoint);

//	[implemented: ToSubClass, 
//	Description("The number of times a timeout has occurred at the specified session point since last count reset."), 
//	SNMPMethodOffset(4)]
//	uint32 TimeoutCount([Description("Defines the session stage this count is associated with. This value will match the NCR_SessionFlowPoint::Name property of one of the NCR_SessionFlowPoints instances."), in]string FlowPoint);

};

[Dynamic:ToInstance, Provider("NCR_WMICoreProvider"), Description("Contains an engagement-specific metric. The Name property describes the metric measurement and the MetricValue property contains its current value. Each instance is basically key\value pair that describe a metric and its associated value."),  SNMPGroup(3),
 SNMPConcreteClass(2)]
class NCR_ApplicationMetrics : CIM_StatisticalInformation
{
	[read: ToSubClass ToInstance, 
	key,
	Description("Name of metric being measured."): ToSubClass ToInstance,
	SNMPPropertyOffset(1)]
	string Name ;

	[read: ToSubClass ToInstance,
	SNMPPropertyOffset(2)]
	string Caption;

	[read: ToSubClass ToInstance,
	Description("The MetricValue property contains the Metric's current value."), 
	SNMPPropertyOffset(3)]
	string MetricValue;
	
	[read: ToSubClass ToInstance,
	Description("The timestamp of last count reset."), 
	SNMPPropertyOffset(4)]
	datetime ResetCountsDate;

	[implemented: ToSubClass, 
	Description("Resets the value for the Metric."), 
	SNMPMethodOffset(1)]
	void ResetMetricValue([Description("The new value of the metric value."), in]string NewValue);
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////			
//////	NCR_TransactionFlowPoint and NCR_SessionFlowPoint removed for RFC 473786. No implementation these classes were ever available so 
//////	'non-breaking' change.
//////			
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//  [Dynamic:ToInstance, 
//   Provider("NCR_WMICoreProvider"), 
//   Description("Class that defines a transaction stage."),  
//   SNMPGroup(3),
//   SNMPConcreteClass(3)]
//  class NCR_TransactionFlowPoint
//  {
//  	[read: ToSubClass ToInstance, 
//  	key,
//  	Description("Name of a flow point."), 
//  	SNMPPropertyOffset(1)]
//  	string Name ;
//  };

//  [Dynamic:ToInstance, Provider("NCR_WMICoreProvider"), 
//   Description("Class that defines a session stage."),  
//   SNMPGroup(3),
//   SNMPConcreteClass(4)]
//  class NCR_SessionFlowPoint
//  {
//  	[read: ToSubClass ToInstance, 
//  	key,
//  	Description("Name of a flow point."), 
//  	SNMPPropertyOffset(1)]
//  	string Name ;
//  };


[Description("Class that defines a session termination reason, e.g. customer cancel, customer timeout."),  
 SNMPGroup(3),
 SNMPConcreteClass(5)]
class NCR_TerminationReason
{
	[read: ToSubClass ToInstance, 
	key,
	Description("Name of a termination reason."), 
	SNMPPropertyOffset(1)]
	string Reason ;
};

instance of NCR_TerminationReason
{
	Reason = "Customer Cancel";
};

instance of NCR_TerminationReason
{
	Reason = "Timeout";
};

instance of NCR_TerminationReason
{
	Reason = "Resource Failure";
};

[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("This class supplies any relevant metric information which can be used for reviewing Service element (transaction) usability."),  
 SNMPGroup(3),
 SNMPConcreteClass(6)]
class NCR_ServiceElementMetrics : CIM_StatisticalInformation
{
	[read: ToSubClass ToInstance, 
	key,
	Description("Any sub-class must define this attribute as a Key."): ToSubClass ToInstance,
	SNMPPropertyOffset(1)]
	string Name ;

	[read: ToSubClass ToInstance, 
	SNMPPropertyOffset(2)]
	string Caption;

	[read: ToSubClass ToInstance,
	Description("The timestamp of last count reset."), 
	SNMPPropertyOffset(3)]
	datetime ResetCountsDate;

	[read: ToSubClass ToInstance,
	Description("The timestamp of last time this service element was used."), 
	SNMPPropertyOffset(4)]
	datetime LastTransaction;

	[read: ToSubClass ToInstance,
	Description("The number of times the Service Element has completed successfully since last count reset."), 
	SNMPPropertyOffset(5)]
	uint32 TransactionCount;

	[read: ToSubClass ToInstance,
	Description("The number of times the specified Service Element has failed to complete successfully since last count reset."), 
	SNMPPropertyOffset(6)]
	uint32 FailedTransactionCount;

	[read: ToSubClass ToInstance,
	Description("This count is used to describe the number of failed transactions will occur before an event may be generated. A transaction has failed when it is terminated before successful completion, e.g. via a consumer cancel or timeout, or a device failure.This count is reset to zero after the NCR_FailedTransactionTrigger is generated."), 
	SNMPPropertyOffset(7)]
	uint32 FailedTransactionTrigger;

	[read: ToSubClass ToInstance,
	Description("Minimum time taken to complete this transaction.Times in seconds"), 
	SNMPPropertyOffset(8)]
	uint32 MinDuration;
	
	[read: ToSubClass ToInstance,
	Description("Maximum time to complete this transacton. Times in seconds"), 
	SNMPPropertyOffset(9)]
	uint32 MaxDuration;
	
	[read: ToSubClass ToInstance,
	Description("Average time to complete the transaction. Times in seconds"), 
	SNMPPropertyOffset(10)]
	uint32 AverageDuration;
	
	[read: ToSubClass ToInstance,
	Description("The states at which the consumer cancelled the session. The number and order of entries in CancelStates is the same as in CancelCounts."), 
	SNMPPropertyOffset(11)]
	string CancelStates[];
	
	[read: ToSubClass ToInstance,
	Description("The number of times each state in CancelStates has been triggered. The number and order of entries in CancelCounts is the same as in CancelStates."), 
	SNMPPropertyOffset(12)]
	uint32 CancelCounts[];
	
	[read: ToSubClass ToInstance,
	Description("The states that timed out waiting for a consumer response (resulting in a failed session). The number and order of entries in TimeoutStates is the same as in TimeoutCounts."), 
	SNMPPropertyOffset(13)]
	string TimeoutStates[];
	
	[read: ToSubClass ToInstance,
	Description("The number of times each state in TimeoutStates has been triggered. The number and order of entries in TimeoutCounts is the same as in TimeoutStates."), 
	SNMPPropertyOffset(14)]
	uint32 TimeoutCounts[];

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////			
//////	CancelCount and TimeoutCount removed for RFC 473786. No implementation of NCR_TransactionFlowPoint or NCR_SessionFlowPoint was ever 
//////	available so 'non-breaking' change.
//////			
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
//	[implemented: ToSubClass, 
//	Description("The number of times a timeout has occurred at the specified transaction point since last count reset."), 
//	SNMPMethodOffset(3)]
//	uint32 TimeoutCount([Description("Defines the transaction stage this count is associated with. This value will match the NCR_TransactionFlowPoint::Name property of one of the NCR_TransactionFlowPoints instances."), in]string FlowPoint);

//	[implemented: ToSubClass, 
//	Description("The number of times a cancel has occurred at the specified transaction point since last count reset."), 
//	SNMPMethodOffset(2)]
//	uint32 CancelCount([Description("Defines the transaction stage this count is associated with. This value will match the NCR_TransactionFlowPoint::Name property of one of the NCR_TransactionFlowPoints instances."), in]string FlowPoint);
	
	[implemented: ToSubClass, 
	Description("Resets all metric counts for the specified Service Element. Service Element name is specified via the Name property of each instance."), 
	SNMPMethodOffset(1)]
	void ResetCounts();

	[implemented: ToSubClass, 
	Description("Sets the value of the FailedTransactionTrigger property. Allows management clients to define when they want NCR_FailedTransactionTrigger events. For example, if you wish to detect every consumer cancel or timeout then this value should be set to one."), 
	SNMPMethodOffset(4)]
	void set_FailedTransactionTrigger([Description("Defines the number of failed transactions that have to occur before an event may be generated."), in]uint32 Trigger);
	
};

[Description("This class defines an SST reset reason, for example, Supervisor Reset, Management Reset."),  
 SNMPGroup(3),
 SNMPConcreteClass(7)]
class NCR_RestartReason
{
	[read: ToSubClass ToInstance, 
	key,
	Description("The restart reason"), 
	SNMPPropertyOffset(1)]
	string Reason ;
};

instance of NCR_RestartReason
{
	Reason = "Unexpected Exception";
};

instance of NCR_RestartReason
{
	Reason = "Supervisor Reset";
};

instance of NCR_RestartReason
{
	Reason = "Management Reset";
};


instance of NCR_RestartReason
{
	Reason = "Software Download Reset";
};

instance of NCR_RestartReason
{
	Reason = "UPS Reset";
};

instance of NCR_RestartReason
{
	Reason = "Local Maintenance Application Reset";
};

instance of NCR_RestartReason
{
	Reason = "Scheduled Reset";
};

instance of NCR_RestartReason
{
	Reason = "Heartbeat Failure Reset";
};

instance of NCR_RestartReason
{
	Reason = "Unknown Reset";
};

instance of NCR_RestartReason
{
	Reason = "Device Auto Recovery";
};

[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("This class defines a session stage. It describes the number of times the terminal has restarted for the reasons decribed in the NCR_RestartReason class."),  
 SNMPGroup(3),
 SNMPConcreteClass(8)]
class NCR_RestartMetrics : CIM_StatisticalInformation
{
	[read: ToSubClass ToInstance, 
	key,
	Description("The identifier defined or used by the management network to identify the SST"): ToSubClass ToInstance,
	SNMPPropertyOffset(1)]
	string Name ;	

	[read: ToSubClass ToInstance, 
	Description("The restart reason. This value matches the Reason property of one of the NCR_ResetReason instances and the corresponding index in the Count property array reports the number of resets of that type."): ToSubClass ToInstance,
	SNMPPropertyOffset(2)]
	string RestartType[];
	
	[read: ToSubClass ToInstance, 
	Description("The number of resets of the reset reason described by the corresponding index of the RestartType property."): ToSubClass ToInstance,
	SNMPPropertyOffset(3)]
	uint32 Count[] ;

	[read: ToSubClass ToInstance, 
	Description("A free-form string that includes additional information describing the reset. For unexpected exceptions, this contains the stack trace."): ToSubClass ToInstance,
	SNMPPropertyOffset(4)]
	string RestartData;	

	[read: ToSubClass ToInstance,
	Description("The date and time when the counts were last reset."), 
	SNMPPropertyOffset(5)]
	datetime LastResetDate;

	[read: ToSubClass ToInstance,
	Description("The last restart reason that occurred. This value matches the Reason property of one of the NCR_ResetReason instances.")]
	string LastRestartType;
	
	[implemented: ToSubClass, 
	Description("Resets the value for this metric."), 
	SNMPMethodOffset(1)]
	void ResetCounts();	
	
};

[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description(""),  
 SNMPGroup(3),
 SNMPConcreteClass(9)]
class NCR_ConsumerActivityMetric : CIM_StatisticalInformation
{
	[read: ToSubClass ToInstance, 
	key,
	Description("Any sub-class must define this attribute as a Key."): ToSubClass ToInstance,
	SNMPPropertyOffset(1)]
	string Name ;

	[read: ToSubClass ToInstance,
	Description("The number of times the consumer cancelled the session in the state described by the corresponding index of StateName for the reason specified in Reason"), 
	SNMPPropertyOffset(2)]
	uint32 Count[];
	
	[read: ToSubClass ToInstance,
	Description("Date and time when counts were last reset"), 
	SNMPPropertyOffset(3)]
	datetime LastResetDate;

	[read: ToSubClass ToInstance,
	Description("The termination reason (see NCR_TerminationReason) associated with the metrics described for the instance"), 
	SNMPPropertyOffset(4)]
	string Reason;	

	[read: ToSubClass ToInstance,
	Description("Describes the set of States that are being counted"), 
	SNMPPropertyOffset(5)]
	string StateName[];
	
	[read: ToSubClass ToInstance,
	Description("Total number of sessions cancelled for the reason described in the Reason property"), 
	SNMPPropertyOffset(6)]
	uint32 Total;
	
	[implemented: ToSubClass, 
	Description("Resets  metric counts"), 
	SNMPMethodOffset(1)]
	void Reset();	
};


[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description(""),  
 SNMPGroup(3),
 SNMPConcreteClass(10)]
class NCR_StateTransitionMetric : CIM_StatisticalInformation
{
	[read: ToSubClass ToInstance, 
	key,
	Description("Any sub-class must define this attribute as a Key."): ToSubClass ToInstance,
	SNMPPropertyOffset(1)]
	string Name ;

	[read: ToSubClass ToInstance,
	Description("The number of times consumer accessed this application state"), 
	SNMPPropertyOffset(2)]
	uint32 Count[];
	
	[read: ToSubClass ToInstance,
	Description("Date and time when counts were last reset"), 
	SNMPPropertyOffset(3)]
	datetime LastResetDate;

	[read: ToSubClass ToInstance,
	Description("Average time spent in the state defined in the corresponding index of StateName.Times in seconds"), 
	SNMPPropertyOffset(4)]
	uint32 AverageTime[];	

	[read: ToSubClass ToInstance,
	Description("Describes the set of States that are being counted"), 
	SNMPPropertyOffset(5)]
	string StateName[];
	
	[read: ToSubClass ToInstance,
	Description("Maximum time spent in the state defined in the corresponding index of StateName.Times in seconds"), 
	SNMPPropertyOffset(6)]
	uint32 MaximumTime[];

	[read: ToSubClass ToInstance,
	Description("Minimum time spent in the state defined in the corresponding index of StateName.Times in seconds"), 
	SNMPPropertyOffset(7)]
	uint32 MinimumTime[];

	[read: ToSubClass ToInstance,
	Description("The last access time for each state being tracked by the application."), 
	SNMPPropertyOffset(8)]
	datetime LastAccessTime[];
	
	[implemented: ToSubClass, 
	Description("Resets  metric counts"), 
	SNMPMethodOffset(1)]
	void Reset();	
};


[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("Provides metric information on customer responses to targeted campaigns"),
 SNMPGroup(3),
 SNMPConcreteClass(11)]
class NCR_CampaignOfferMetricInfo : CIM_StatisticalInformation
{
	[read: ToSubClass ToInstance, 
	key,
	Description("Name of package being measured"): ToSubClass ToInstance,
	SNMPPropertyOffset(1)]
	string Name ;

	[read: ToSubClass ToInstance,
	Description("Count of number of consumers who accepted the offer"), 
	SNMPPropertyOffset(2)]
	uint32 NumberOfAccepts;
	
	[read: ToSubClass ToInstance,
	Description("Count of number of consumers who deferred the offer for decision later"), 
	SNMPPropertyOffset(3)]
	uint32 NumberOfDefers;

	[read: ToSubClass ToInstance,
	Description("Count of number of consumers who declined the offer"), 
	SNMPPropertyOffset(4)]
	uint32 NumberOfDeclines;	

	[read: ToSubClass ToInstance,
	Description("Count the number of customer who did not responsed to the offer [Response - timeout] or Message is shown to user and customer cancelled the offer."),
	SNMPPropertyOffset(5)]
	uint32 NumberOfFailuresToComplete;

	[read: ToSubClass ToInstance,
	Description("Names of the coupons printed in the campaign"), 
	SNMPPropertyOffset(6)]
	string CouponName[];

	[read: ToSubClass ToInstance,
	Description("The number of times the coupon, described by the corresponding index of CouponName, was printed by the consumer"), 
	SNMPPropertyOffset(7)]
	uint32 CouponPrintCount[];

	[read: ToSubClass ToInstance,
	Description("The type of the offer - TargetedOffer"), 
	SNMPPropertyOffset(8)]
	string Type;

	[implemented: ToSubClass, 
	Description("Resets  metric counts"), 
	SNMPMethodOffset(1)]
	void ResetCounts();	
};

[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("Provides metric information on customer responses to marketing campaigns"),
 SNMPGroup(3),
 SNMPConcreteClass(12)]
class NCR_GenericCampaignMetricInfo: CIM_StatisticalInformation
 {

	[read: ToSubClass ToInstance, 
	key,
	Description("Name of campaign being measured"): ToSubClass ToInstance,
	SNMPPropertyOffset(1)]
	string Name;

	[read: ToSubClass ToInstance,
	Description("Names of the screens displayed in the campaign"), 
	SNMPPropertyOffset(2)]
	string ScreenName[];

	[read: ToSubClass ToInstance,
	Description("The number of times the screen, described by the corresponding index of SscreenName, was displayed to the consumer"), 
	SNMPPropertyOffset(3)]
	uint32 ScreenDisplayCount[];

	[read: ToSubClass ToInstance,
	Description("Names of the coupons printed in the campaign"), 
	SNMPPropertyOffset(4)]
	string CouponName[];

	[read: ToSubClass ToInstance,
	Description("The number of times the coupon, described by the corresponding index of CouponName, was printed by the consumer"), 
	SNMPPropertyOffset(5)]
	uint32 CouponPrintCount[];

	[read: ToSubClass ToInstance,
	Description("The type of the offer - MarketingMessage"), 
	SNMPPropertyOffset(6)]
	string Type;

	[implemented: ToSubClass, 
	Description("Resets  metric counts"), 
	SNMPMethodOffset(1)]
	void ResetCounts();	
 };

 [Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("Allows to query the provider for campaign statistics of a date or within a date range"),
 SNMPGroup(3),
 SNMPConcreteClass(13)]
class NCR_CampaignQuery: CIM_StatisticalInformation
 {
 
	[read: ToSubClass ToInstance, 
	key,
	Description("key to allow the clients to query"): ToSubClass ToInstance,
	SNMPPropertyOffset(1)]
	string Name;
	
	[implemented: ToSubClass, 
	Description("Method to be used by the WMI Client to query the WMI provider for information within the specified date range."), 
	SNMPMethodOffset(1)]
	void QueryDetails([in]string StartDate,[in]string EndDate);	
 };

//////////////////////////////////////////
//////////////////////////////////////////
// Events
//////////////////////////////////////////
//////////////////////////////////////////


[Description("This event is generated after a specified series of failed sessions (see NCR_ConsumerApplicationMetrics::FailesSessionTrigger)."),
 SNMPGroup(3),
 SNMPTrapClass(1)]
class NCR_FailedSessionTrigger : NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	Description("Defines the reason that the session failed. This value will match the NCR_SessionTerminationReason::Reason property of one of the NCR_SessionTerminationReason instances."), 
	SNMPPropertyOffset(1)]
	string Reason;
	
	[read: ToSubClass ToInstance, 
	Description("Defines the transaction stage (state name) where the session terminated."), 
	SNMPPropertyOffset(2)]
	string FlowPoint;
};


[Description("This event is generated after a specified series of failed transactions (see NCR_ServiceElementMetrics::FailedTransactionTrigger)."), 
 SNMPGroup(3),
 SNMPTrapClass(2)]
class NCR_FailedTransactionTrigger : NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	Description("Defines the reason that the transaction failed. This value will match the NCR_TerminationReason::Reason property of one of the NCR_TerminationReason instances."), 
	SNMPPropertyOffset(1)]
	string Reason;
	
	[read: ToSubClass ToInstance, 
	Description("Defines the transaction stage (state name) where the transaction terminated."), 
	SNMPPropertyOffset(2)]
	string FlowPoint;
	
};

[Description("This event is generated when a Service element completes"), 
 SNMPGroup(3),
 SNMPTrapClass(3)]
class NCR_ServiceElementComplete : NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	Description("Any fee associated with the transaction"), 
	SNMPPropertyOffset(1)]
	real32 Fee;

	[read: ToSubClass ToInstance, 
	Description("Name of the transaction"), 
	SNMPPropertyOffset(2)]
	string Name;

	[read: ToSubClass ToInstance, 
	Description("Result of the transaction"), 
	SNMPPropertyOffset(3)]
	uint32 Result;

	[read: ToSubClass ToInstance, 
	Description("user group of the consumer who executed the transaction"), 
	SNMPPropertyOffset(4)]
	string UserGroup;

	[read: ToSubClass ToInstance, 
	Description("The value of the transaction"), 
	SNMPPropertyOffset(5)]
	real32 Value;
	
	[read: ToSubClass ToInstance, 
	Description("Text meaning of the result of the transaction"), 
	SNMPPropertyOffset(6)]
	uint32 ResultAsText;
};

[Description("This event is generated when a Consumer Session starts"), 
 SNMPGroup(3),
 SNMPTrapClass(4)]
class NCR_SessionStarted : NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	Description("The UTC timestamp of the session start"), 
	SNMPPropertyOffset(1)]
	datetime SessionStartTime;
};


[Description("This event is generated when a Consumer Session starts"), 
 SNMPGroup(3),
 SNMPTrapClass(5)]
class NCR_SessionComplete : NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	Description("The language specified on the card for consumer use. Empty if no language defined"), 
	SNMPPropertyOffset(1)]
	string CardLanguage;
	
	[read: ToSubClass ToInstance, 
	Description("The language used for the consumer interaction with the terminal"), 
	SNMPPropertyOffset(2)]
	string DisplayLanguage;

		[read: ToSubClass ToInstance, 
	Description("The duration of the session, in seconds"), 
	SNMPPropertyOffset(3)]
	uint32 SessionDuration;

	[read: ToSubClass ToInstance, 
	Description("The UTC timestamp of the session end"), 
	SNMPPropertyOffset(4)]
	datetime SessionCompleteTime;
	
	[read: ToSubClass ToInstance, 
	Description("User group of the consumer who executed the session"), 
	SNMPPropertyOffset(5)]
	string UserGroup;
	
	[read: ToSubClass ToInstance, 
	Description("Returns true when Audio was used during the session"), 
	SNMPPropertyOffset(6)]
	boolean WasAudioUsed;

	[read: ToSubClass ToInstance, 
	Description("Returns true when a receipt was requested by the user."), 
	SNMPPropertyOffset(7)]
	boolean WasReceiptRequested;
	
};

[Description("This event is generated when the TMSPromote provider is ready with a results instance for the client query."), 
 SNMPGroup(3),
 SNMPTrapClass(6)]
class NCR_QueryReady : NCR_ApplicationManagementEvent
{
	
	[read: ToSubClass ToInstance, 
	Description("Returns a non empty string when an error occurred while populating the result instance."), 
	SNMPPropertyOffset(1)]
	string Error;
	
	[read: ToSubClass ToInstance, 
	Description("Returns the Terminal ID of the machine."), 
	SNMPPropertyOffset(2)]
	string TerminalId;
	
	[read: ToSubClass ToInstance, 
	Description("Returns the date to which the results instance belongs,if results are of more than single day then returns end date"), 
	SNMPPropertyOffset(3)]
	string Date;
	
	[read: ToSubClass ToInstance, 
	Description("Returns the instance ID of the results instance."), 
	SNMPPropertyOffset(4)]
	string InstanceId;

};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////
//////			Systems Management - Group 4
//////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  

[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("This class supplies any relevant information that can be used for controlling the SST."), 
 SNMPGroup(4),
 SNMPConcreteClass(1)]
class NCR_ATM 
{

	[read: ToSubClass ToInstance, 
	Description("The number of application starts caused by this class.")]
	uint32 ApplicationStartCount;

	[read: ToSubClass ToInstance, 
	Description("True if the current behaviour is to persist the out-of-service state across reboots initiated through the ResetATM, ResetATMEnhanced and Shutdown methods.")]	
	boolean PersistsOOSonReboot;	

	[read: ToSubClass ToInstance, 
	Description("The number of SST restarts that have occurred through the ResetATM, ResetAMTEnhanced and Shutdown methods since the count was reset."), 
	SNMPPropertyOffset(2)]
	uint32 ResetATMCount;
	
	[read: ToSubClass ToInstance, 
	Key, 
	Description("The identifier defined or used by the management network to identify the SST (see NCR_TerminalInfo::TerminalId)."), 
	SNMPPropertyOffset(1)]
	string Name;
	
	[implemented: ToSubClass, 
	Description("Reset the ResetATMCount to zero."), 
	SNMPMethodOffset(1)]
	void ResetATMResetCount();

	[implemented: ToSubClass, 
	Description("Allows management clients to request that all consumer applications go out of service."), 
	SNMPMethodOffset(2)]
	void DisableConsumerApplications([Description("When TRUE, the method requests all consumer applications to cease offering services to the consumer. When FALSE, the method cancels a previous management client request for consumer applications to go out of service. Consumer applications subsequently offer service depending on their normal resource availability."), in]boolean OutOfServiceRequest);

	[implemented: ToSubClass, 
	Description("Forces a reset of the SST. It attempts a controlled shutdown by making sure no consumer applications are offering services. If the consumer applications have failed to respond after 300 seconds, the reset proceeds."), 
	SNMPMethodOffset(3)]
	void ResetATM([Description("The NCR_RestartReason::Reason property value that describes the reason for the reset."), in]string Reason);

	[implemented: ToSubClass, 
	Description("Allows management clients to request that all supervisor applications cease to offer service"), 
	SNMPMethodOffset(4)]
	void DisableSupervisorApplications([Description("When TRUE, the method method requests all supervisor applications to cease offering services. When FALSE, the method method cancels a previous management client request for supervisor applications to go out of service. Supervisor applications subsequently offer service depending on their normal resource availability."), in]boolean OutOfServiceRequest);

	[implemented: ToSubClass, 
	Description("Allows management clients to request that all consumer applications go out of service.")]	
	void DisableConsumerApplicationsEnhanced([Description("When TRUE, the method requests all consumer applications to cease offering services to the consumer. When FALSE, The method cancels a previous management client request for consumer applications to go out of service."), in]boolean OutOfServiceRequest, 
	                                         [Description("A text description of the reason for the disable. typically used for logging."), in]string Reason, 
	                                         [Description("The client ID used to identify the client responsible for making the request."), in]string Issuer) ;

	
	[implemented: ToSubClass, 
	Description("Forces a reset of the SST. It attempts a controlled shutdown by making sure no consumer applications are offering services. If the consumer applications have failed to respond after 300 seconds, the reset proceeds.")]	
	void ResetATMEnhanced([Description("TheNCR_RestartReason::Reason property value that describes the reason for the reset."), in]string Reason, 
	                     [Description("The client ID used to identify the client responsible for making the request."), in]string Issuer,
						 [Description("Optional additional information about the reset. When the reset reason is Unexpected Exception, the AdditionalData should contain the stack trace. For all other reset types, the AdditionalData should be empty."), in]string AdditionalData) ;


	[implemented: ToSubClass, 
	Description("This method allows management clients to request that all supervisor applications cease to offer service.")]	
	void DisableSupervisorApplicationsEnhanced([Description("When TRUE, The method requests all supervisor applications to cease offering services. When FALSE, The method cancels a previous management client request for supervisor applications to go out of service."), in]boolean OutOfServiceRequest, 
	                                           [Description("A text description of the reason for the disable. typically used for logging."), in]string Reason, 
	                                           [Description("The client ID used to identify the client responsible for making the request."), in]string Issuer) ;
	
	[implemented: ToSubClass, 
	Description("Restarts (that is, stops and starts) the specified NCR_ChannelApplication instance using a restart agent. No attempt is made to negotiate for resources or display information on the SST screen before or during restart. If required, this may be done either by the restart agent or using the disable methods supported in this class"), 
	SNMPMethodOffset(5)]
	void RestartApplication([Description("The NCR_ChannelApplication::Name property of the application to restart."), in]string AppName);

	[implemented: ToSubClass, 
	Description("Stops the specified NCR_ChannelApplication instance using a restart agent. No attempt is made to negotiate for resources or display information on the SST screen before or during restart. If required, this may be done either by the restart agent or using the disable methods supported in this class."), 
	SNMPMethodOffset(6)]
	void StopApplication([Description("The NCR_ChannelApplication::Name property of the application to stop."), in]string AppName);
	
	[implemented: ToSubClass, 
	Description("Starts the specified NCR_ChannelApplication instance using a restart agent."), 
	SNMPMethodOffset(7)]
	void StartApplication([Description("The NCR_ChannelApplication::Name property of the application to start."), in]string AppName);
	
	[implemented: ToSubClass, 
	Description("Controls whether the out-of-service state is persisted across reboots made through this class (ResetATM, ResetAMTEnhanced, Shutdown).")]
	void PersistOutOfServiceOnReboot([Description("True if the out-of-service state is persisted across reboots made by this class."), in]boolean PersistState);	
	
	[implemented: ToSubClass, 
	Description("Forces a shutdown of the SST. It attempts a controlled shutdown by making sure no consumer applications are offering services. If the consumer applications have failed to respond after 300 seconds, the shutdown proceeds.")]	
	void Shutdown([Description("The NCR_RestartReason::Reason property value that describes the reason for the shutdown."), in]string Reason, 
	                     [Description("The client ID used to identify the client responsible for making the request."), in]string Issuer,
	                     [Description("Optional additional information about the shutdown. When the shutdown reason is Unexpected Exception, the AdditionalData should contain the stack trace. For all other shutdown types, the AdditionalData should be empty."), in]string AdditionalData) ;
};

[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("This class supplies any relevant information which can be used for controlling the ATM."), 
 SNMPGroup(4),
 SNMPConcreteClass(2)]
class NCR_TerminalInfo 
{
	[read: ToSubClass ToInstance, 
	Description("The current time on the SST."), 
	SNMPPropertyOffset(3)]
	datetime CurrentTime;
	
	[read: ToSubClass ToInstance, 
	Description("The standard time zone name."), 
	SNMPPropertyOffset(4)]
	string TimeZone;
	
	[read: ToSubClass ToInstance, 
	Description("An array of displayable strings, each representing a different line in a postal address."), 
	SNMPPropertyOffset(5)]
	string Address[];

	[read: ToSubClass ToInstance, 
	Key, 
	Description("A displayable name of the bank that owns the ATM."), 
	SNMPPropertyOffset(1)]
	string BankName;

	[read: ToSubClass ToInstance, 
	Description("A terminal may be connected to a number of discrete independent networks. E.g. a number of independent remote business services and an independent remote management service. This property returns an array of strings by which this terminal identifies itself to each network it connects to."), 
	SNMPPropertyOffset(2)]
	string TerminalID[];
	
	[read: ToSubClass ToInstance, 
	Description("postcode or zip code describing the location of the terminal"), 
	SNMPPropertyOffset(6)]
	string PostcodeZipCode;	

	[read: ToSubClass ToInstance, 
	Description("manufacturer of the terminal"), 
	SNMPPropertyOffset(7)]
	string TerminalVendor;	

	[read: ToSubClass ToInstance, 
	Description("terminal model"), 
	SNMPPropertyOffset(8)]
	string TerminalModel;	

	[read: ToSubClass ToInstance, 
	Description("Town or City where the terminal is located"), 
	SNMPPropertyOffset(9)]
	string City;	

	[read: ToSubClass ToInstance, 
	Description("Default Language that is used, for example, to define the language used in the attract screens"), 
	SNMPPropertyOffset(10)]
	string DefaultLanguage;	

	[read: ToSubClass ToInstance, 
	Description("District location of the terminal"), 
	SNMPPropertyOffset(11)]
	string District;	

	[read: ToSubClass ToInstance, 
	Description("High level description of terminal location. Can be used to describe where terminal is located"), 
	SNMPPropertyOffset(12)]
	string Location;	

	[read: ToSubClass ToInstance, 
	Description("Describes the type of location where the terminal is installed, e.g. Mall, Train Station, Hospital, etc"), 
	SNMPPropertyOffset(13)]
	string LocationType;	

	[read: ToSubClass ToInstance, 
	Description("Network Identifier string"), 
	SNMPPropertyOffset(14)]
	string NetworkId;	

	[read: ToSubClass ToInstance, 
	Description("State, Region, or Province where the terminal is located"), 
	SNMPPropertyOffset(15)]
	string StateOrProvince;	

	[read: ToSubClass ToInstance, 
	Description("The Street where the terminal is located"), 
	SNMPPropertyOffset(16)]
	string Street;	

	[read: ToSubClass ToInstance, 
	Description("Used to group terminals that are considered the same resource"), 
	SNMPPropertyOffset(17)]
	string Transit;	

	[implemented: ToSubClass, 
	Description("Sets the CurrentTime."), 
	SNMPMethodOffset(1)]
	void set_CurrentTime([Description("The updated CurrentTime."), in]datetime time);

};
 
 
[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("This class gives read-only access to the application configuration properties that are exposed for remote viewing. These will typically be a small subset of properties used to configure the application that may be interesting to management systems"), 
 SNMPGroup(4),
 SNMPConcreteClass(3)]
class NCR_ApplicationConfiguration 
{
	[read: ToSubClass ToInstance, 
	Description("The name of the application associated with these configuration properties"), 
	SNMPPropertyOffset(1)]
	string Name;
	
	[read: ToSubClass ToInstance, 
	Description("A String collection containing the list of property names that can be queried for this application. This list is typically a small subset of properties used to configure the application that may be interesting to management systems. Typically, the instrumented terminal application will be configured to define which properties, and their names, that it will expose. "), 
	SNMPPropertyOffset(2)]
	string PropertyNames[];

	[read: ToSubClass ToInstance, 
	Description("A String collection containing the values of the properties specified in the equivalent array index of the propertyName parameter. "), 
	SNMPPropertyOffset(2)]
	string PropertyValues[];
};
 
[Description("This event is generated when a property of NCR_TerminalInfo has changed."), 
 SNMPGroup(4),
 SNMPTrapClass(1)]
class NCR_TerminalInfoChanged: NCR_ApplicationManagementEvent
{
};

[Description("This event is generated on successful completion of the NCR_ATM::DisableConsumerApplications operation."), 
 SNMPGroup(4),
 SNMPTrapClass(2)]
class NCR_DisabledConsumerApplications: NCR_ApplicationManagementEvent
{
};

[Description("This event is generated on successful completion of the NCR_ATM::DisableSupervisorApplications operation."), 
 SNMPGroup(4),
 SNMPTrapClass(3)]
class NCR_DisabledSupervisorApplications: NCR_ApplicationManagementEvent
{
};

[Description("This event is generated when an application restart is initiated as a result of a call to NCR_ATM::RestartApplication."),  
 SNMPGroup(4),
 SNMPTrapClass(4)]
class NCR_ApplicationRestarted: NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	Description("The name of the application as defined in NCR_ChannelApplication::Name that has started."), 
	SNMPPropertyOffset(1)]
	string Name;
};

[Description("This event is generated when an application started."),  
 SNMPGroup(4),
 SNMPTrapClass(5)]
class NCR_ApplicationStarted: NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	Description("The name of the application as defined in NCR_ChannelApplication::Name that has started."), 
	SNMPPropertyOffset(1)]
	string Name;
};

[Description("This event is generated when an application has stopped as a result of a call to NCR_ATM::StopApplication."),  
 SNMPGroup(4),
 SNMPTrapClass(6)]
class NCR_ApplicationStopped: NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	Description("The name of the application as defined in NCR_ChannelApplication::Name that has stopped."), 
	SNMPPropertyOffset(1)]
	string Name;
};

[Description("This event is generated when there was an attempt to stop, start or restart an application a result of a operation on NCR_ATM, and that attempt has failed."),  
 SNMPGroup(4),
 SNMPTrapClass(7)]
class NCR_ApplicationRestartAgentFailed: NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	Description("The name of the application as defined in NCR_ChannelApplication::Name that has failed to start, restart or stop."), 
	SNMPPropertyOffset(1)]
	string Name;
	
	[read: ToSubClass ToInstance, 	
	Description ("Describes the action that has failed, i.e. Start, Stop or Retart of the application."),
	ValueMap {"0", "1", "2"} : ToSubClass,	
	Values {"Start", "Restart", "Stop"} , 
	SNMPPropertyOffset(2)]
	sint32 Action;	
};


[Description("An application has generated a Critical Exception."),  
 SNMPGroup(4),
 SNMPTrapClass(8)]
class NCR_ApplicationCriticalExceptionOccurred: NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	Description("The name of the application as defined in NCR_ChannelApplication::Name that has generated a critical exception"), 
	SNMPPropertyOffset(1)]
	string Name;
	
	[read: ToSubClass ToInstance, 	
	Description ("Details of the critical exception"),
	SNMPPropertyOffset(2)]
	string Description;	
};

[Description("This event is generated when a request has been made to reset the ATM. This event will be fired before the ATM is reset. "),  
 SNMPGroup(4),
 SNMPTrapClass(9)]
class NCR_SoftResetRequested: NCR_ApplicationManagementEvent
{

};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////
//////			Problem Determination Management - Group 5
//////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


[Dynamic:ToInstance, Provider("NCR_WMICoreProvider"), 
 Description("Represents a PD investigation on the SST."),  
 SNMPGroup(5),
 SNMPConcreteClass(1)]
class NCR_PDInvestigation
{
	[read: ToSubClass ToInstance, 
	key, 
	SNMPPropertyOffset(1), 
	Description("Unique representation of the Investigations GUID in registry format.")]
	string UniqueId ;

	[read: ToSubClass ToInstance, 
	SNMPPropertyOffset(2), 
	Description("User supplied name for the Investigation.")]
	string Name;

	[read: ToSubClass ToInstance, 
	SNMPPropertyOffset(3), 
	Description("The timestamp when the investigation was created.")]
	datetime CreationDate;

	[read: ToSubClass ToInstance, 
	SNMPPropertyOffset(4), 
	Description("The timestamp when the Investigation was completed.")]
	datetime ClosureDate;

	[read: ToSubClass ToInstance, 
	SNMPPropertyOffset(5), 
	Description("Representation of the creator's UniqueId.")]
	string CreatorId;

	[read: ToSubClass ToInstance, 
	SNMPPropertyOffset(6), 
	Description("Represents the Investigation's current state."), 
	ValueMap {"0", "1", "2", "3", "4", "5"} : ToSubClass ToInstance,
	Values {"Active", "Collecting", "Stopped", "Gathering", "Gathered", "Complete"} : ToSubClass ToInstance]
	uint32 State;

	[read: ToSubClass ToInstance, 
	SNMPPropertyOffset(7), 
	Description("FALSE indicates that the Investigation contains some unrecognised configuration information.")]
	boolean ValidInvestigation;
	
	[implemented: ToSubClass, 
	SNMPMethodOffset(1), 
	Description("Starts collecting data.")]
	boolean Start();

	[implemented: ToSubClass, 
	SNMPMethodOffset(2), 
	Description("Stops collecting and gathers data. This is an asynchronous activity.")]
	boolean Stop();
	
	[implemented: ToSubClass, 
	SNMPMethodOffset(3), 
	Description("Stops collecting, gathers data, and marks the investigation as complete. This is an asynchronous activity.")]
	boolean Close();
	
	[implemented: ToSubClass, 
	SNMPMethodOffset(4), 
	Description("Stops collecting data.")]
	boolean Pause();
	
	[implemented: ToSubClass, 
	SNMPMethodOffset(5), 
	Description("Starts collecting data.")]
	boolean Restart();	
		
	[implemented: ToSubClass, 
	SNMPMethodOffset(6), 
	Description("Abandon the investigation.")]
	boolean Abandon();
};


[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("PD Investigations are controlled via this (singleton) class."),  
 SNMPGroup(5),
 SNMPConcreteClass(2)]
class NCR_PDInvestigationCollection
{
	[read: ToSubClass ToInstance, 
	 key, 
	 SNMPPropertyOffset(1), 
	 Description("Unique Identifier for this singleton class. Always returns one.")]
	uint32 Id;

	[read: ToSubClass ToInstance, 
	 SNMPPropertyOffset(2), 
	 Description("Number of PD Investigations controlled by this class.")]
	uint32 Count ;

	[read: ToSubClass ToInstance, 
	 SNMPPropertyOffset(3), 
	 Description("Returns the NCR_PDInvestigation::UniqueID that identifies the currently active PD Investigation.")]
	string ActiveInvestigation;

	[implemented: ToSubClass, 
	 SNMPMethodOffset(1), 
	 Description("Creates an NCR_PDInvestigation from the specified NCR_PDInvestigationTemplate. This will return FALSE if- another investigation is active or an invalid template was specified.")]
	boolean CreateFromTemplate([in, Description("Specifies the NCR_PDInvestigationTemplate::UniqueId of the tempalte to base this investigation upon.")] string InvestigationTemplate, [out, Description("Returns the NCR_PDInvestigation::UniqueId of the investigation created.")] string PDInvestigation);

	[implemented: ToSubClass, 
	 SNMPMethodOffset(2), 
	 Description("Remove the Investigation from the system, deleting any associated files.")]
	boolean Remove([in, Description("The NCR_PDInvestigation::UniqueId of the investigation to be removed.")] string PDInvestigation);
	
	[implemented: ToSubClass, 
	 SNMPMethodOffset(3), 
	 Description("Export an Investigation to the specified directory. This is an asynchronous operation.")]
	boolean Export([in, Description("The NCR_PDInvestigation::UniqueId of the investigation to be exported.")] string PDInvestigation, [in, Description("The directory where the investigation is to be exported to.")] string Destination, [in, Description("When True, this parameter will result in the specified investigation being exported as a CAB file. When False, the investigation will be exported as a standard collection of PD investigation files.")] boolean ExportAsCAB, [in, Description("The name of the CAB file to be created.")] string CABName);
	
	[implemented: ToSubClass, 
	 SNMPMethodOffset(4), 
	 Description("Cancel the running export operation and delete any transfer files. This method will return when the cancel has finished processing. No further events will be sent by the export operation.")]
	boolean CancelExport();

	[implemented: ToSubClass, 
	SNMPMethodOffset(5), 
	Description("This triggers an upload request via the software management infrastructure.")]
	boolean RequestArchiveUpload([in, Description("The directory where the CAB PD investigation is to be uploaded from.")] string Location, [in, Description("The name of the CAB file that contains the investigation to be uploaded.")] string CABName);
};


[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("A template consists of a list of selected data sources and their configuration."),  
 SNMPGroup(5),
 SNMPConcreteClass(3)]
class NCR_PDInvestigationTemplate
{
	[read: ToSubClass ToInstance, 
	key, 
	Description("The GUID of the template in registry format."), 
	SNMPPropertyOffset(1)]
	string UniqueId;

	[read: ToSubClass ToInstance, 
	Description("User supplied name for the Template."), 
	SNMPPropertyOffset(2)]
	string Name;

	[read: ToSubClass ToInstance, 
	Description("The timestamp the Template was created."), 
	SNMPPropertyOffset(3)]
	datetime CreationDate;
	
	[read: ToSubClass ToInstance, 
	Description("The timestamp the Template was last modified."), 
	SNMPPropertyOffset(4)]
	datetime LastModificationDate;
	
	[read: ToSubClass ToInstance, 
	Description("Set if the Template is fixed."), 
	SNMPPropertyOffset(5)]
	uint32 Fixed;

	[read: ToSubClass ToInstance, 
	Description("Indicates if all template data sources are present, allowing template to be run."), 
	SNMPPropertyOffset(6)]
	uint32 Runnable;
};

[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("PD Investigations are controlled via this (singleton) class."), 
 SNMPGroup(5),
 SNMPConcreteClass(4)]
class NCR_PDInvestigationTemplateCollection
{
	[read: ToSubClass ToInstance, 
	key, 
	Description("Unique Identifier for this singleton class. Always returns one."), 
	SNMPPropertyOffset(1)]
	uint32 Id;

	[read: ToSubClass ToInstance, 
	Description("Number of PD Templates controlled by this class."), 
	SNMPPropertyOffset(2)]
	uint32 Count ;

	[implemented: ToSubClass, 
	Description("Remove the Investigation from the system, deleting any associated files."), 
	SNMPMethodOffset(1)]
	boolean Remove(
		[Description("The NCR_PDInvestigationTemplate::UniqueId of the investigation to be removed."), in] 
		string PDInvestigationTemplate);
	
	[implemented: ToSubClass, 
	Description("Import a Template to the specified directory. This is an asynchronous operation."), 
	SNMPMethodOffset(2)]
	boolean Import(
		[Description("The directory where the investigation is to be exported to."), in] 
		string Source, 
		[Description("When True, this parameter specifies the template(s) being imported are CAB files. When False, the templates will be in uncompressed format."), in] 
		boolean AsCAB, 
		[Description("If a directory is specifed then all templates in the folder will be imported. If specifying a file, which must be a CAB file, then only the specified CAB file will be imported."), in] 
		string SourceName);
		
	[implemented: ToSubClass, 
	Description("Cancel the running import operation and delete any transfer files. This method will return when the cancel has finished processing. No further events will be sent by the export operation."), 
	SNMPMethodOffset(3)]
	boolean CancelImport();
};

[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("Archive Manager is controlled via this (singleton) class."),  
 SNMPGroup(5),
 SNMPConcreteClass(5)]
class NCR_ArchiveManager
{
	[read: ToSubClass ToInstance, 
	 key, 
	 Description("Unique Identifier for this singleton class. Always returns one."), 
	 SNMPPropertyOffset(1)]
	 uint32 Id;
		
	[implemented: ToSubClass, 
	Description("This invokes all configured Archive Manager providers to collect trace information."), 
	SNMPMethodOffset(1)]
	void ArchiveNow();
};

//////////////////////////////////////////
//////////////////////////////////////////
// Events
//////////////////////////////////////////
//////////////////////////////////////////



[Description("This is returned to report the result of an operation invoked by NCR_PDInvestigation.Abandon."),   
 SNMPGroup(5),
 SNMPTrapClass(1)]
class NCR_PDInvestigationAbandonComplete : NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	Description("Contains the asociated NCR_PDInvestigation::UniqueId."), 
	SNMPPropertyOffset(1)]
	string UniqueId;

	[read: ToSubClass ToInstance, 
	Description("This property will contain the descriptive name of the investigation."),
	SNMPPropertyOffset(2)]
	string Name;	
	
	[read: ToSubClass ToInstance, 
	Description("Completion code for the operation. The completion code will be one of the return codes defined for the operation (see the FS for APTRA Problem Determination for more details)."), SNMPPropertyOffset(3)]
	uint32 Status;	
	
	[read: ToSubClass ToInstance, 
	Description("The timestamp when the operation completed."), 
	SNMPPropertyOffset(4)]
	datetime Time;	
};



[Description("This is returned to report the result of the completion of the operation invoked by NCR_PDInvestigation.Close."),   
 SNMPGroup(5),
 SNMPTrapClass(2)]
class NCR_PDInvestigationCloseComplete : NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	Description("Contains the asociated NCR_PDInvestigation::UniqueId."), 
	SNMPPropertyOffset(1)]
	string UniqueId;

	[read: ToSubClass ToInstance, 
	Description("This property will contain the descriptive name of the investigation."),
	SNMPPropertyOffset(2)]
	string Name;	
	
	[read: ToSubClass ToInstance, 
	Description("Completion code for the operation. The completion code will be one of the return codes defined for the operation (see the FS for APTRA Problem Determination for more details)."), 
	SNMPPropertyOffset(3)]
	uint32 Status;	
	
	[read: ToSubClass ToInstance, 
	Description("The timestamp when the operation completed."), 
	SNMPPropertyOffset(4)]
	datetime Time;	
};



[Description("This is returned to report the result of the completion of the operation invoked by NCR_PDInvestigation.Stop"),   
 SNMPGroup(5),
 SNMPTrapClass(3)]
class NCR_PDInvestigationStopComplete : NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	Description("Contains the asociated NCR_PDInvestigation::UniqueId."), 
	SNMPPropertyOffset(1)]
	string UniqueId;

	[read: ToSubClass ToInstance, 
	Description("This property will contain the descriptive name of the investigation."),
	SNMPPropertyOffset(2)]
	string Name;	
	
	[read: ToSubClass ToInstance, 
	Description("Completion code for the operation. The completion code will be one of the return codes defined for the operation (see the FS for APTRA Problem Determination for more details)."), 
	SNMPPropertyOffset(3)]
	uint32 Status;	
	
	[read: ToSubClass ToInstance, 
	Description("The timestamp when the operation completed."), 
	SNMPPropertyOffset(4)]
	datetime Time;	
};



[Description("This is returned to report the result of the completion of the operation invoked by NCR_PDInvestigation.Export or CancelExport."),   
 SNMPGroup(5),
 SNMPTrapClass(4)]
class NCR_PDInvestigationExportComplete : NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	Description("Contains the asociated NCR_PDInvestigation::UniqueId."), 
	SNMPPropertyOffset(1)]
	string UniqueId;

	[read: ToSubClass ToInstance, 
	Description("This property will contain the descriptive name of the investigation."),
	SNMPPropertyOffset(2)]
	string Name;	
	
	[read: ToSubClass ToInstance,
	Description("Completion code for the operation. The completion code will be one of the return codes defined for the operation (see the FS for APTRA Problem Determination for more details)."), 
	SNMPPropertyOffset(3)]
	uint32 Status;	
	
	[read: ToSubClass ToInstance, 
	Description("The timestamp when the operation completed."), 
	SNMPPropertyOffset(4)]
	datetime Time;	
	
	[read: ToSubClass ToInstance, 
	Description("This parameter gives the full path and filename of the exported file"), 
	SNMPPropertyOffset(5)]
	string Path;		
};


[Description("This is returned to report the result of the completion of the operation invoked by NCR_PDInvestigation.Import or CancelImport."),   
 SNMPGroup(5),
 SNMPTrapClass(5)]
class NCR_PDTemplateImportComplete : NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	Description("Completion code for the operation. The completion code will be one of the return codes defined for the operation (see the FS for APTRA Problem Determination for more details)."), 
	SNMPPropertyOffset(1)]
	uint32 Status;	
	
	[read: ToSubClass ToInstance, 
	Description("The timestamp when the operation completed."), 
	SNMPPropertyOffset(2)]
	datetime Time;	
};


[Description("This is returned to report the result of an operation invoked by NCR_ArchiveManager.ArchiveNow."),   
 SNMPGroup(5),
 SNMPTrapClass(6)]
class NCR_ArchiveManagerArchiveNowComplete : NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	Description("This property is an array containing the full path for each archived CAB file."), 
	SNMPPropertyOffset(1)]
	string FilePaths[];

	[read: ToSubClass ToInstance, 
	Description("The timestamp when the operation completed."),
	SNMPPropertyOffset(2)]
	datetime Time;
};


[Description("This is returned to report start of an operation invoked by NCR_ArchiveManager.ArchiveNow."),   
 SNMPGroup(5),
 SNMPTrapClass(7)]
class NCR_ArchiveManagerArchiveNowStart : NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	Description("The timestamp when the operation started."),
	SNMPPropertyOffset(1)]
	datetime Time;
};


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////
//////			Security Management - Group 6
//////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


[Dynamic:ToInstance, 
 Description("Represents a HICS object that provides information on Symmetric Keys, RSA Keys and Certificates installed on the SST."), 
 Provider("NCR_WMICoreProvider")]
class NCR_SecurityObject
{
	[read: ToSubClass ToInstance, key, Description("The name of the Security Object This name is unique within an SST."), 
	SNMPPropertyOffset(1)]
	string Name ;

	[read: ToSubClass ToInstance, Description("Indicates if the Security Object is active."), 
	SNMPPropertyOffset(2)]
	boolean Active;

	[read: ToSubClass ToInstance, Description("Indicates if this object can be changed: TRUE: the security object can be loaded / deleted. FALSE: the object is factory pre-loaded and cannot be altered."), 
	SNMPPropertyOffset(3)]
	boolean Changeable;

};


[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("Represents a SecurityObject that provides access to Certificates."),   
 SNMPGroup(6),
 SNMPConcreteClass(1)]
class NCR_Certificate : NCR_SecurityObject
{
	[read: ToSubClass ToInstance, 
	Description("Indicates the use for this object "), 
	BitMap{"0", "1", "2", "3", "4", "5", "6", "7"} ,
	BitValues{"EnCrypt","KeyEncryption","DigitalSignatureGen","DigitalSignatureVerify","PinBlockGeneration","LocalPinVerification","DeCrypt", "KeyDecryption"},
	SNMPPropertyOffset(1)]
	uint32 RSAUse ;
};


[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("Represents a SecurityObject that provides access to RSA keys."),    
 SNMPGroup(6),
 SNMPConcreteClass(2)]
class NCR_RSAKeyPair : NCR_SecurityObject
{
	[read: ToSubClass ToInstance, 
	Description("Indicates the use for this object "), 
	BitMap{"0", "1", "2", "3", "4", "5", "6", "7"} ,
	BitValues{"EnCrypt","KeyEncryption","DigitalSignatureGen","DigitalSignatureVerify","PinBlockGeneration","LocalPinVerification","DeCrypt", "KeyDecryption"},
	SNMPPropertyOffset(1)]
	uint32 RSAUse ;
};

[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("Represents a SecurityObject that provides access to Symmetric keys."),    
 SNMPGroup(6),
 SNMPConcreteClass(3)]
class NCR_SymmetricKey : NCR_SecurityObject
{
	[read: ToSubClass ToInstance, 
	Description("Indicates the use for this object"), 
	BitMap{"0", "1", "2", "3", "4"} ,
	BitValues{"Crypt", "KeyEncryption", "PinBlockGeneration", "LocalPinVerification", "MACing" } ,
	SNMPPropertyOffset(1)]
	uint32 SymmetricKeyUse ;
};

[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("Represents a component supporting key management"),    
 SNMPGroup(6),
 SNMPConcreteClass(4)]
class NCR_SecurityKeyManager
{
	[read: ToSubClass ToInstance, 
	Description("Reports the capabilities of this object"), 
	BitMap{"0", "1", "2"} ,
	BitValues{"RemoteInitialKeyLoadRSASigned","RemoteInitialKeyLoadCert","RemoteInitialKeyLoadGIECB","MultiPartKeyLoad","RemoteInitialKeyLoadEnhancedRSASigned","SecureKeyEntry"} ,
	SNMPPropertyOffset(2)]
	uint32 Capabilities ;

	[read: ToSubClass ToInstance, 
	key, 
	Description("The unique identifier for the secure PIN Pad device if available. Empty string "" otherwise."), 
	SNMPPropertyOffset(1)]
	string EppId;

};


//////////////////////////////////////////
//////////////////////////////////////////
// Events
//////////////////////////////////////////
//////////////////////////////////////////




[Description(""),    
 SNMPGroup(6),
 SNMPTrapClass(1)]
class NCR_SecurityObjectCreated : NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	Description("The Name of the Security Object"), 
	SNMPPropertyOffset(1)]
	string Name;
};


[Description("Generated when an a NCR_SecurityObject changes Active state. The associated Security object can be queried for its new state"),     
 SNMPGroup(6),
 SNMPTrapClass(2)]
class NCR_SecurityObjectStateChange :NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	Description("The Name of the Security Object"), 
	SNMPPropertyOffset(1)]
	string Name;
};


[Description("Generated when an a NCR_SecurityObject is deleted"),     
 SNMPGroup(6),
 SNMPTrapClass(3)]
class NCR_SecurityObjectDeleted : NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	Description("The Name of the Security Object"), 
	SNMPPropertyOffset(1)]
	string Name;
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////
//////			Supervisor Management - Group 7
//////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("Represents a logical supervisor application with responsibility to deliver supervisor functionality."),     
 SNMPGroup(7),
 SNMPConcreteClass(1)]
class NCR_Supervisor : NCR_ChannelApplication
{
	[read: ToSubClass ToInstance, 
	Description("The timestamp of the start of the last completed supervisor session for this application."), 
	SNMPPropertyOffset(1) ]
	datetime LastSession;
	
	[read: ToSubClass ToInstance, 
	Description("The identifier of the supervisor who last completed a supervisor session with this application."), 
	SNMPPropertyOffset(2) ]
	string LastUser;
	
	[read: ToSubClass ToInstance, 
	Description("Describes the current mode of this supervisor application. See the NCR_SupervisorMode enumeration class for details."), 
	ValueMap {"1", "2", "3", "4", "5", "6", "7"}: ToSubClass ToInstance,
	Values {"InService", "InUse", "OutOfService", "NotRunning", "InDiagnostics", "InNonValuableReplenishment", "InValuableReplenishment"} : ToSubClass ToInstance,
	SNMPPropertyOffset(3) ]
	uint32 CurrentMode;
	
	[implemented: ToSubClass, 
	Description("Request to exit supervisor remotely. If this cannot be achieved because of a non-responsive task (eg in diagnostics), then the return code of this operation will report that exit will not be attempted. Return code of zero indicates sucess, One indicates no attempt to exit. Use existing events to report supervisor mode exit"), 
	SNMPMethodOffset(1)]
	uint32 RequestExit( );
	
};



[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("This class can be used to find all supervisor tasks available on the ATM. It is used in associated with the NCR_SupervisorTaskEvent classes to report supervisor task activity."), 
 SNMPGroup(7),
 SNMPConcreteClass(2)]
class NCR_SupervisorTask : NCR_LogicalElement
{
};



//////////////////////////////////////////
//////////////////////////////////////////
// Events
//////////////////////////////////////////
//////////////////////////////////////////


[Description("This event is generated when an NCR_Supervisor changes state"), 
 SNMPGroup(7),
 SNMPTrapClass(1)]
class NCR_SupervisorModeChange : NCR_ChannelApplicationEvent
{
	[read: ToSubClass ToInstance, 
	Description("Describes the name of the current user of Supervisor. This contains an empty string, when no user is associated with the event (for example, when the supervisor application changes to the NCR_SupervisorMode::InActive state"), 
	SNMPPropertyOffset(1)]
	string User;
	
	[read: ToSubClass ToInstance, 
	Description("Describes the new mode of the supervisor application."), 
	ValueMap {"1", "2", "3", "4", "5", "6", "7"} ,
	Values {"InService", "InUse", "OutOfService","NotRunning","InDiagnostics", "InNonValuableReplenishment", "InValuableReplenishment"} , 
	SNMPPropertyOffset(2)]
	uint32 CurrentMode;
};

[Description("This event class is generated to describe a Supervisor task event. it encapsulates the information relevant to a supervisor activity.")]
class NCR_SupervisorTaskEvent : NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	Description("Identifies the unique user or group of users (e.g. FLM users) who are associated with this supervisor event"), 
	SNMPPropertyOffset(1)]
	string User;

	[read: ToSubClass ToInstance, 
	Description("The timestamp of the time the action occured"), 
	SNMPPropertyOffset(2)]
	datetime Time;

	[read: ToSubClass ToInstance, 
	Description("The name of the supervisor task which caused this event. See description in NCR_SupervisorTask."), 
	SNMPPropertyOffset(3)]
	string SupervisorTaskName;
};


[Description("Indicates that the task has begun."), 
 SNMPGroup(7),
 SNMPTrapClass(2)]
class NCR_SupervisorTaskStart: NCR_SupervisorTaskEvent 
{
};


[Description("Indicates that the task has completed"), 
 SNMPGroup(7),
 SNMPTrapClass(3)]
class NCR_SupervisorTaskComplete: NCR_SupervisorTaskEvent 
{
};




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////
//////			Fraud Management - Group 8
//////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("This class describes a suspected fraud attempt at the ATM"),  
 SNMPGroup(8),
 SNMPConcreteClass(1)]
class NCR_FraudElement 
{
	[read: ToSubClass ToInstance, 
	key, 
	Description("The Index of this particular NCR_FraudElement. Unique within an ATM system."), 
	SNMPPropertyOffset(1)]
	uint32 Index ;

	[read: ToSubClass ToInstance, 
	Description("A free-format description of the suspected fraud attempt."), 
	SNMPPropertyOffset(2)]
	string Description ;

	[read: ToSubClass ToInstance , 
	Description("Describes the probability that the fraud attempt is actual fraud (as opposed to, for example, device or sensor error)."), 
	ValueMap {"0", "1", "2", "3"}: ToSubClass ToInstance,
	Values {"None", "Low", "Medium", "High"}: ToSubClass ToInstance,
	SNMPPropertyOffset(3)]
	uint32 Probability;

	[read: ToSubClass ToInstance, 
	Description("A free-format description of the action that has been taken at the ATM as a result of the suspected fraud."), 
	SNMPPropertyOffset(4)]
	string Action ;

	[read: ToSubClass ToInstance, 
	Description("A free-format description of the ATM element that has identified the potential fraud. This could hold, for example, the name of the application that identified suspicious device behaviour."), 
	SNMPPropertyOffset(5)]
	string Source ;

	[read: ToSubClass ToInstance, 
	Description("Number of NCR_FraudElement instances that will be maintained"), 
	SNMPPropertyOffset(6)]
	uint32 NumEntries ;
};



//////////////////////////////////////////
//////////////////////////////////////////
// Events
//////////////////////////////////////////
//////////////////////////////////////////


[Description("This event class is generated when a suspected fraud attempt is occuring."),   
 SNMPGroup(8),
 SNMPTrapClass(1)]
class NCR_FraudEvent : NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	Description("the Index of the NCR_FraudElement instance that describes this event"), 
	SNMPPropertyOffset(1)]
	uint32 Index;
};




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////
//////			Host Status Management - Group 9
//////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("This class describes a reference to a 'connected' Host (e.g. an IFX Server)"),   
 SNMPGroup(9),
 SNMPConcreteClass(1)]
class NCR_ConnectedHost 
{
	[read: ToSubClass ToInstance, 
	key, 
	Description("Unique identifying string that represents this Host."), 
	SNMPPropertyOffset(1)]
	string Name ;
	
	[read: ToSubClass ToInstance, 
	 Description("Reports whether the Host is available or not."),
	SNMPPropertyOffset(2) ]
	boolean Availability;

	[read: ToSubClass ToInstance, 
	 Description("An array of strings which contains a series of structured text descriptions describing the reason for the unavailability of this Host."),
	SNMPPropertyOffset(3) ]
	string UnavailabilityDescriptions[];	
	
	[read: ToSubClass ToInstance, 
	 Description("time that connection last dropped"),
	SNMPPropertyOffset(4) ]
	datetime ConnectionDroppedTime;		
};



[Dynamic:ToInstance, Provider("NCR_WMICoreProvider"), 
 Description("This class describes a reference to a connectionless Host (e.g. a web service)"),    
 SNMPGroup(9),
 SNMPConcreteClass(2)]
class NCR_ConnectionlessHost 
{
	[read: ToSubClass ToInstance, 
	key, 
	Description("Unique identifying string that represents this Host."), 
	SNMPPropertyOffset(1)]
	string Name ;

	[read: ToSubClass ToInstance, 
	Description("Reports TRUE when the last attempt to communicate with the Host was successful. FALSE otherwise"), 
	SNMPPropertyOffset(2)]
	boolean LastAccessSuccessful ;
	
	[read: ToSubClass ToInstance, 
	 Description("time of last successful connection"),
	SNMPPropertyOffset(3) ]
	datetime LastSuccessfulConnection;
};

//////////////////////////////////////////
//////////////////////////////////////////
// Events
//////////////////////////////////////////
//////////////////////////////////////////


[Description("This event is generated when the connection to the host has changed state (lost or connected)."),    
 SNMPGroup(9),
 SNMPTrapClass(1)]
class NCR_HostStateChange : NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	Description("The unique identifying string for this host"), 
	SNMPPropertyOffset(1)]
	string Name ;
	
	[read: ToSubClass ToInstance, 
	Description("Reports TRUE when the host connection is established, reports FALSE if connection lost"), 
	SNMPPropertyOffset(2)]
	boolean Connected ;
};


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////
//////			Inventory Component Management - Group 10
//////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





[Dynamic:ToInstance, 
 Description("This class represents an Installable Item."), 
 Provider("NCR_WMICoreProvider")]
class NCR_InstalledItem 
{
	[read: ToSubClass ToInstance, 
	key, 
	Description("The name of the item"), 
	SNMPPropertyOffset(1)]
	string Name ;

	[read: ToSubClass ToInstance, 
	Description("The Description of the item"), 
	SNMPPropertyOffset(2)]
	string Description ;

	[read: ToSubClass ToInstance, 
	Description("The maximum diskspace required by the item in KB."), 
	SNMPPropertyOffset(3)]
	uint32 Diskspace ;

	[read: ToSubClass ToInstance, 
	Description("The version of the item"), 
	SNMPPropertyOffset(4)]
	string Version ;
};



[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("This class is used to describe a deliverable componentas described in the Aggregate Installer documentation."),    
 SNMPGroup(10),
 SNMPConcreteClass(1)]
class NCR_AggregateComponent : NCR_InstalledItem
{
	[read: ToSubClass ToInstance, 
	Description("Full path to the readme file associated with the item"), 
	SNMPPropertyOffset(1)]
	string Readme ;

	[read: ToSubClass ToInstance, 
	Description("String description of the type of component, eg Aggregate, Component, etc"), 
	SNMPPropertyOffset(2)]
	string ItemType ;

	[read: ToSubClass ToInstance, 
	Description("Described whether the item is active or not "), 
	SNMPPropertyOffset(3)]
	boolean Active ;

	[read: ToSubClass ToInstance, 
	Description("The profile or configuration set used during installation"), 
	SNMPPropertyOffset(4)]
	string Profile ;
};


[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("This class encapsulates the components that are contained within a distributable software aggregate."),     
 SNMPGroup(10),
 SNMPConcreteClass(2)]
class NCR_Aggregate : NCR_AggregateComponent
{
	[read: ToSubClass ToInstance, 
	Description("This contains the list of NCR_AggregateComponents::Name for all installed items associated with this software distribution. If it is not known which components are contained within this distribution then the array is empty"), 
	SNMPPropertyOffset(1)]
	string ComponentList[] ;
};


[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("This class is used to describe a deliverable file for APTRA Activate"),     
 SNMPGroup(10),
 SNMPConcreteClass(3)]
class NCR_ApplicationFile : NCR_InstalledItem
{
	[read: ToSubClass ToInstance, 
	Description("The location on disk of the file"), 
	SNMPPropertyOffset(1)]
	string Location ;

	[read: ToSubClass ToInstance, 
	Description("The MD5 Checksum value of the file associated with this item. This property is a string that contains the checksum in 32 character hexadecimal format.  "), 
	SNMPPropertyOffset(2)]
	string Md5Checksum ;
	
	[read: ToSubClass ToInstance, 
	Description("Date & Timestamp of item installation"), 
	SNMPPropertyOffset(3)]
	datetime Timestamp;
};


[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("All configuration files associated with an application will be described in an applications NCR_ApplicationConfigFile enumeration"),     
 SNMPGroup(10),
 SNMPConcreteClass(4)]
class NCR_ApplicationConfigFile : NCR_ApplicationFile
{

};


[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("This class is used to describe a binary (i.e. assembly file) for APTRA Activate. All assemblies located within the running application directory will be described in an enumeration of this class"),     
 SNMPGroup(10),
 SNMPConcreteClass(5)]
class NCR_InstalledAssembly : NCR_ApplicationFile
{
	[read: ToSubClass ToInstance, 
	Description("The name of the company who produced the assembly."), 
	SNMPPropertyOffset(1)]
	string Company ;

	[read: ToSubClass ToInstance, 
	Description("The name of the product that contains this assembly "), 
	SNMPPropertyOffset(2)]
	string Product ;
	
	[read: ToSubClass ToInstance, 
	Description("The Public Key Token for the assembly"), 
	SNMPPropertyOffset(3)]
	string PublicKeyToken;
};


[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description(""),     
 SNMPGroup(10),
 SNMPConcreteClass(6)]
class NCR_PrimaryApplicationAssembly : NCR_InstalledAssembly
{

};

//////////////////////////////////////////
//////////////////////////////////////////
// Events
//////////////////////////////////////////
//////////////////////////////////////////


[Description("This event may be generated when a remote or local software installation begins. This means that the software has begun to be downloaded / copied."),     
 SNMPGroup(10),
 SNMPTrapClass(1)]
class NCR_SoftwareInstallationStart : NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	Description("Uniquely identifies this Distribution "), 
	SNMPPropertyOffset(1)]
	string DistributionIdentifier ;
	
	[read: ToSubClass ToInstance, 
	Description("Identifies the aggregate package that describes what is contained within the installation component"), 
	SNMPPropertyOffset(2)]
	string AggregateIdentifier ;
};

[Description("This event may be generated when a remote or local software installation stops."),      
 SNMPGroup(10),
 SNMPTrapClass(2)]
class NCR_SoftwareInstallationStop : NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	Description("Uniquely identifies this Distribution "), 
	SNMPPropertyOffset(1)]
	string DistributionIdentifier ;
};



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////
//////			FE Tracking Management - Group 11
//////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("A Ticket encapsulates the information associated with a particular FE function at the ATM. It encapsulates the original status code describing a problem the ATM has identified, the resulting Action code which describes the recommended FE activity to resolve the issue, the Resolution code which describes the activity the FE actually made to resolve the problem."),      
 SNMPGroup(11),
 SNMPConcreteClass(1)]
class NCR_Ticket 
{
	[read: ToSubClass ToInstance, 
	key,
	Description("Unique Identifier for an instance (assigned by NCR_TicketFactory)."), 
	SNMPPropertyOffset(1)]
	string UniqueId ;

	[read: ToSubClass ToInstance, 
	Description("Free-format description of the ticket type or classification"), 
	SNMPPropertyOffset(2)]
	string Type ;

	[read: ToSubClass ToInstance, 
	Description("Status information that was received originally by the management console that resulted in the ticket being raised"), 
	SNMPPropertyOffset(3)]
	string StatusCode ;

	[read: ToSubClass ToInstance, 
	Description("Action code that describes the recommended FE activity to resolve the ticket"), 
	SNMPPropertyOffset(4)]
	string ActionCode ;

	[read: ToSubClass ToInstance, 
	Description("Free-format description of any additional detail describing the ticket"), 
	SNMPPropertyOffset(5)]
	string Detail ;

	[read: ToSubClass ToInstance, 
	Description("Describes the action the engineer has taken to resolve the problem associated with this ticket"), 
	SNMPPropertyOffset(6)]
	string Resolution ;
	
	[implemented: ToSubClass, 
	Description("Operation to  set the Resolution Code that describes the action taken to resolve the problem. Typically entered by the FE."), 
	SNMPMethodOffset(1)]
	void set_Resolution([Description("Describes the action the engineer has taken to resolve the problem associated with this ticket."), in]string Type);
	
};


[Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"), 
 Description("The NCR_TicketFactory enables remote management applications to create ticket information locally at the ATM for subsequent viewing by the FE."),       
 SNMPGroup(11),
 SNMPConcreteClass(2)]
class NCR_TicketFactory
{
	[read: ToSubClass ToInstance, 
	key, 
	Description("Unique Identifier for this singleton class. Always returns one"), 
	SNMPPropertyOffset(1)]
	uint32 Id;

	[implemented: ToSubClass, 
	Description("Creates the ticket and returns the unique identifier for the ticket (as contained within NCR_Ticket.UniqueId property)."), 
	SNMPMethodOffset(1)]
	void Create_NCR_Ticket([Description("Defines the Type attribute"), in]string Type, [Description("Defines the StatusCode attribute"), in]string StatusCode, [Description("Defines the ActionCode attribute"), in]string ActionCode, [Description("Defines the Detail attribute"), in]string Detail);
	
};

//////////////////////////////////////////
//////////////////////////////////////////
// Events
//////////////////////////////////////////
//////////////////////////////////////////


[Description("Class definition used to group and classify all events associated with CS dispatch activity")]
class NCR_InterventionEvent : NCR_ApplicationManagementEvent
{
	[read: ToSubClass ToInstance, 
	Description("The unique identifier for the engineer"), 
	SNMPPropertyOffset(1)]
	string EngineerIdentifier ;
};


[Description("This event class is generated when a CS logs onto the ATM to resolve some issue."),       
 SNMPGroup(11),
 SNMPTrapClass(1)]
class NCR_EngineerArrived : NCR_InterventionEvent 
{
	[read: ToSubClass ToInstance, 
	Description("The timestamp of the time the engineer logged onto the ATM to resolve an issue described by a set of NCR_Tickets."), 
	SNMPPropertyOffset(1)]
	datetime ArrivalTime ;
};


[Description("This event class is generated when a CS departs the ATM after a visit."),       
 SNMPGroup(11),
 SNMPTrapClass(2)]
class NCR_EngineerCompleted : NCR_InterventionEvent 
{
	[read: ToSubClass ToInstance, 
	Description("The timestamp of the time the engineer departed the ATM."), 
	SNMPPropertyOffset(1)]
	datetime CompletionTime ;
};


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////
//////			XFS Management - Group 12
//////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//=========================================================================================
// NCR_XFSDevice
//=========================================================================================
[Description	("Parent class for NCR XFS device-related classes. Used by clients to identify NCR XFS classes"),
 Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider")]
class NCR_XFSDevice
{
};


//=========================================================================================
// NCR_XFSSubDevice
//=========================================================================================
[Description	("Parent class for NCR XFS sub device classes. Used by clients to identify NCR XFS classes"),
 Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider")]
class NCR_XFSSubDevice
{
};


//=========================================================================================
// xfsDevice
//=========================================================================================
[Description	("It is intended to provide unchangeable information about each managed "
		"service and their associated physical devices installed on the system."),
 Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider")]
class xfsDevice : NCR_XFSDevice
{
	[read: ToSubClass, 
	key,
	SNMPPropertyOffset(1),	
	Description	("The name of the management service.")]
	string xfsManagedServiceName;

	[read: ToSubClass, 
	SNMPPropertyOffset(2),	
	Description	("The identifier of the XFS class.")]
	sint32 xfsManagedServiceClass;

	[read: ToSubClass, 
	SNMPPropertyOffset(3),	
	Description	("The identifier of the XFS type.")]
	sint32 xfsManagedServiceType;

	[read: ToSubClass, 
	SNMPPropertyOffset(4),	
	Description	("The name of the physical device or devices associated with this "
			 "managed service. It is a Display String field. Where more than "
			 "one physical device is associated with the managed service, each "
			 "physical device name is comma separated.")]
	string xfsManagedServicePhysicalDeviceName;

	[read: ToSubClass, 
	SNMPPropertyOffset(5),	
	Description	("The vendor name of the service provider.")]
	string xfsManagedServiceVendor;

	[read: ToSubClass,
	SNMPPropertyOffset(6),	
	Description	("The XFS class release. It is a 32 bit numerical field. The "
			 "low-order word contains the version number, while the high-order "
			 "word must be set to zero. In the low-order word, the low-order "
			 "byte specifies the major version number and the high-order byte "
			 "specifies the minor version number. The major version number is "
			 "equal to the value of the XFS device class release node.")]
	sint32 xfsManagedServiceClassRelease;

	[read: ToSubClass, 
	SNMPPropertyOffset(7),	
	Description	("Defines how many sub-devices the service has.")]
	uint32 xfsManagedServiceNumberSubDevices;

	[read: ToSubClass,	
	ValueMap {"0", "1", "2", "3", "4", "5", "6"} : ToSubClass ToInstance ,
	Values {"xfsDevOnline", "xfsDevOffline", "xfsDevPowerOff", "xfsDevNoDevice", "xfsDevHWError", "xfsDevUserError", "xfsDevBusy"} ,	
	Description	("This property contains the device state. "
			"Allowed values are: "
			"xfsDevOnline(0) The device is present, powered on and online "
				"(i.e., operational, not busy processing a request and not"
				"in an error state)."
			"xfsDevOffline(1) The device is offline "
				"(e.g., the operator has taken the device offline by "
				"turning a switch or pulling out the device)."
			"xfsDevPowerOff(2) The device is powered off or physically not "
				"connected."
			"xfsDevNoDevice(3) There is no device intended to be there; "
				"e.g. this type of self service machine does not contain "
				"such a device or it is internally not configured."
			"xfsDevHWError(4) The device is present but inoperable due to a "
				"hardware fault that prevents it from being used."
			"xfsDevUserError(5) The device is present but a person is "
				"preventing proper device operation. The application "
				"should suspend the device operation or remove the "
				"device from service until the service provider generates"
				"a device state change event indicating the condition of "
				"the device has changed e.g. the error is removed."
			"xfsDevBusy(6) The device is busy and unable to process an "
				"Execute command at this time."),
	SNMPPropertyOffset(8)]
	sint32 xfsManagedServiceStatusDevice;

    [Description    ("It contains the vendor dependent additional device status information."),
	SNMPPropertyOffset(9),	
    read: ToSubClass]
    string xfsExtraStatus[];	
};

//=========================================================================================
// xfsSubDevice
//=========================================================================================
[Description	("The sub-device table provides access to the device status values for sub "
				"devices within a service class."),
 Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider")]
class xfsSubDevice : NCR_XFSSubDevice
{
	[read: ToSubClass, 
	SNMPPropertyOffset(1),	
	key, 
	Description	("the name of the managed service that the subdevice belongs to")]
	string xfsSubDeviceManagedServiceNamePlusTypePlusIndex;
};




//=========================================================================================
// xfsEvent
//=========================================================================================
[Description	("XFS Event.")]
class xfsEvent : NCR_ApplicationManagementEvent
{
	[Description	("This property contains the system generating the "
			 "alarm, it is a Display String field. It corresponds to "
			 "lpszWorkstationName in the event data from the service provider."),
	SNMPPropertyOffset(1) ]
	string xfsEventSysName;

	[Description	("This property represents the managed service name "
			 "generating the alarm. The agent derives "
			 "this field from the error event."),
	SNMPPropertyOffset(2) ]
	string xfsEventManagedServiceName;

	[Description	("This property represents the XFS service class identifier "
			"generating the alarm. It corresponds to the class identifier for the class name."),
	SNMPPropertyOffset(3) ]
	sint32 xfsEventManagedServiceClass;

	[Description	("This property represents the XFS service class name "
			"generating the alarm. It corresponds to the three character representation of the XFS service class "
			"name, and it is useful for human interpretation of a trap."),
	SNMPPropertyOffset(4) ]
	string xfsEventManagedServiceClassName;

	[Description	("This property represents the XFS type identifier generating the alarm. It "
			"corresponds to the type identifier as defined in the "
			"WFS_INF_XXX_CAPABILITIES.fwType field, or zero if device class does "
			"not support this field."),
	SNMPPropertyOffset(5) ]
	sint32 xfsEventManagedServiceType;


	[Description	("This property represents the physical device name or "
			 "names associated with the managed service generating the alarm. "
			 "It corresponds to the physical device "
			 "name or names identified by the managed service."),
	SNMPPropertyOffset(6) ]
	string xfsEventPhysicalDeviceName;

	[Description	("This property represents the XFS device vendor name of "
					 "the device generating the alarm. It corresponds to the vendor name for the service provider. "),
	SNMPPropertyOffset(7) ]
	string xfsEventDeviceVendor;


	[Description	("This property represents the XFS event generating the alarm. It corresponds "
					 "to u.dwEventID in the event data from the service provider. "),
	SNMPPropertyOffset(8) ]
	sint32 xfsEventXFSEvent;

	[Description	("The date and time when the event was generated. "),
	SNMPPropertyOffset(9) ]
	datetime xfsEventDate;

	[Description	("This property represents the vendor-defined version of the "
					 "service provider generating the alarm. "),
	SNMPPropertyOffset(10) ]
	string xfsEventSPVersion;
};

//=========================================================================================
// xfsCommandFailedEvent
//=========================================================================================
[Description	("This event is generated when the response to an XFS execute command indicates an error (i.e. the XFS return value is not WFS_SUCCESS)."),       
 SNMPGroup(12),
 SNMPTrapClass(1)]
class xfsCommandFailedEvent:  xfsEvent
{
	[Description	("The XFS command code that describes the command that failed.") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsCommand;

	[Description	("The failed return code that XFS returned on completion of the command") ,
	SNMPPropertyOffset(2) ]
	sint32 xfsReturnCode;
	
};



//=========================================================================================
// xfsErrorEvent
//=========================================================================================
[Description	("Hardware and software errors are also reported as system events to the "
		 "XFS Provider."),       
 SNMPGroup(12),
 SNMPTrapClass(2)]
class xfsErrorEvent : xfsEvent
{

	[Description	("This property represents the suggested action, and "
 			 "corresponds to dwAction in the event data from the service "
			 "provider.") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsErrorEventSuggestedAction;

	[Description	("This property represents the description associated to "
			"the alarm (this description is vendor dependent), corresponding "
			"to lpbDescription in the event data from the service provider.") ,
	SNMPPropertyOffset(2) ]
	sint32 xfsErrorEventDescription[];

	[Description	("This property represents the application ID associated "
			"with the session that generated the error event, and corresponds to "
			"lpszAppID in the event data from the service provider.") ,
	SNMPPropertyOffset(3) ]
	string xfsErrorEventAppId;

	[Description	("This property represents XFSError code when the exception "
 			 "occurrs provided in iXFSError object.") ,
	SNMPPropertyOffset(4) ]
	sint32 xfsErrorCode;

    [Description    ("It contains the vendor dependent additional device status information."
                     "The first array is the M-Status MData information"
                     "The second array is the Gasper information"),
    read: ToSubClass ,
	SNMPPropertyOffset(5) ]
    string xfsStatusExtraStatus[];
};



//=========================================================================================
// xfsDeviceStatusChangeEvent
//=========================================================================================
[Description	("Status changes of managed services are reported as system events to the "
		"XFS Agent.")]
class xfsDeviceStatusChangeEvent : xfsEvent
{

	[Description	("This property represents the current state of the "
			"physical device managed by the service, and corresponds to dwState"
			"in the event data from the service provider.") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsDSCEventManagedServiceStatus;
	
    [Description    ("It contains the vendor dependent additional device status information."),
    read: ToSubClass ,
	SNMPPropertyOffset(2) ]
    string xfsExtraStatus[];	
};

//=========================================================================================
// xfsIDC
//=========================================================================================
[Description	("States. IDC specific device class status."),
 Dynamic:ToInstance, Provider("NCR_WMICoreProvider"),       
 SNMPGroup(12),
 SNMPConcreteClass(1)]
class xfsIDC : xfsDevice
{
	[ValueMap {"1", "2", "3", "4", "5", "6", "7"} ,
	Values {"xfsIDCMediaPresent", "xfsIDCMediaNotPresent", "xfsIDCMediaJammed",
		"xfsIDCMediaNotSupported", "xfsIDCMediaUnknown", "xfsIDCMediaEntering",
		"xfsIDCMediaLatched"} ,
	read: ToSubClass,
	Description	("It contains the media state. It is a numeric type field. "),
	SNMPPropertyOffset(1) ]
	sint32 xfsIDCStatusMedia;

	[ValueMap {"1", "2", "3", "4"} ,
	Values {"xfsIDCRetainBinOK", "xfsIDCRetainBinNotSupported", "xfsIDCRetainBinFull",
		"xfsIDCRetainBinHigh"} ,
	read: ToSubClass,
	Description	("It contains the state of the ID card unit retain bin."),
	SNMPPropertyOffset(2) ]
	sint32 xfsIDCStatusRetainBin;

	[ValueMap {"1", "2", "3"} ,
	Values {"xfsIDCSecurityNotSupported", "xfsIDCSecurityNotReady",
		"xfsIDCSecurityOpen"} ,
	read: ToSubClass,
	Description	("It contains the state of the security unit. "),
	SNMPPropertyOffset(3) ]
	sint32 xfsIDCStatusSecurity;

	[Description	("It contains the number of cards retained. It is a numeric type "
			"field. The number of cards retained;"
			"applicable only to motor driven ID card units for non-motorized "
			"card units this value is 0."), read: ToSubClass,
	SNMPPropertyOffset(4) ]
	sint32 xfsIDCStatusCardRetained;

	[ValueMap {"0", "1", "2", "3", "4", "5", "6", "7"} ,
	Values {"xfsIDCChipOnline", "xfsIDCChipPoweredOff", "xfsIDCChipBusy",
		"xfsIDCChipNoDevice", "xfsIDCChipHwError", "xfsIDCChipNoCard",
		"xfsIDCChipNotSupported", "xfsIDCChipUnknown"} ,
	read: ToSubClass,
	Description	("It contains the state of the chip controlled by this service. "),
	SNMPPropertyOffset(5) ]
	sint32 xfsIDCStatusChipPower;
	
	[implemented: ToSubClass, 
	Description("This method will negotiate for access to the device (using, for example, the APTRA Resource Management component)  and, when available, will invoke the XFS Reset command. The xfsIDCResetCompleteEvent is generated on completion of the operation."), 
	SNMPMethodOffset(1)]
	void xfsIDCReset([Description("The number of seconds to wait for successful negotiation of the device. If access to the device is not achieved within this time then the xfsIDCResetNegotiationTimeoutEvent will be generated."), in]sint32 WaitTime, [Description("Specifies the action to be performed on any user card found within the ID card unit "), in]sint32 Action);
	
};

//=========================================================================================
// xfsCEU
//=========================================================================================
[Description	("Status for CEU device."),
 Dynamic:ToInstance, Provider("NCR_WMICoreProvider")]
class xfsCEU : xfsDevice
{
	[ValueMap {"0", "1", "2", "3", "4", "5", "6","7","8","9","10","11"} ,
	Values	{"xfsCEUMediaPresent", "xfsCEUMediaNotPresent", "xfsCEUMediaJammed",
			"xfsCEUMediaNotSupported", "xfsCEUMediaUnknown", "xfsCEUMediaEntering",
			"xfsCEUMediaTopperFail","xfsCEUMediaInHopper","xfsCEUMediaOutHopper",
			"xfsCEUMediaMSRE","xfsCEUMediaRetained"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("contains the media state. ")]
	sint32 xfsCEUStatusMedia;
	
	[ValueMap {"1", "4", "2", "3"} ,
	Values	{"xfsCEURetainBinOK", "xfsCEURetainBinNotSupported", "xfsCEURetainBinFull",
			"xfsCEURetainBinHigh" } ,
	Read(TRUE), 
	Write(FALSE),
	Description	("contains the state of the CEU retain bin")]
	sint32 xfsCEUStatusRetainBin;
	
	[ValueMap {"1", "4", "2", "3"} ,
	Values	{"xfsCEUOutputBinOK", "xfsCEUOutputBinNotSupported", "xfsCEUOutputBinFull",
			"xfsCEUOutputBinHigh" } ,
	Read(TRUE), 
	Write(FALSE),
	Description	("contains the state of the CEU output bin")]
	sint32 xfsCEUStatusOutputBin;
	
	[ValueMap {"1", "4", "2", "3"} ,
	Values	{"xfsCEUInputBinOK", "xfsCEUInputBinNotSupported", "xfsCEUInputBinEmpty",
			"xfsCEUInputBinLow" } ,
	Read(TRUE), 
	Write(FALSE),
	Description	("")]
	sint32 xfsCEUStatusInputBin;
	
	[Read(TRUE), 
	Write(FALSE),
	Description	("The total number of cards, including those in input bin, output bin, and retain bin")]
	uint32 xfsCEUTotalCards;
	
	[Read(TRUE), 
	Write(FALSE),
	Description	("The total number of output bin cards.")]
	uint32 xfsCEUOutputCards;
	
	[Read(TRUE), 
	Write(FALSE),
	Description	("The total number of retain bin cards")]
	uint32 xfsCEURetainCards;

	[implemented: ToSubClass, Description("This method will negotiate for access to the device (using, for example, the APTRA Resource Management component) and, when available, will invoke the XFS Reset command. ") ]
	void xfsCEUReset([Description("The number of seconds to wait for successful negotiation of the device"), in]sint32 WaitTime, [Description("Specifies the action to be performed if deposited media is detected during the reset operation"), in]sint32 Action);

};

[Description	("Status changes of managed services are reported as system events to the XFS Agent.")]
class xfsCEUDeviceStatusChangeEvent : xfsDeviceStatusChangeEvent
{
	[ValueMap {"0", "1", "2", "3", "4", "5", "6","7","8","9","10","11"} ,
	Values	{"xfsCEUMediaPresent", "xfsCEUMediaNotPresent", "xfsCEUMediaJammed",
			"xfsCEUMediaNotSupported", "xfsCEUMediaUnknown", "xfsCEUMediaEntering",
			"xfsCEUMediaTopperFail","xfsCEUMediaInHopper","xfsCEUMediaOutHopper",
			"xfsCEUMediaMSRE","xfsCEUMediaRetained"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("contains the media state. ")]
	sint32 xfsCEUStatusMedia;
	
	[ValueMap {"1", "4", "2", "3"} ,
	Values	{"xfsCEURetainBinOK", "xfsCEURetainBinNotSupported", "xfsCEURetainBinFull",
			"xfsCEURetainBinHigh" } ,
	Read(TRUE), 
	Write(FALSE),
	Description	("contains the state of the CEU retain bin")]
	sint32 xfsCEUStatusRetainBin;
	
	[ValueMap {"1", "4", "2", "3"} ,
	Values	{"xfsCEUOutputBinOK", "xfsCEUOutputBinNotSupported", "xfsCEUOutputBinFull",
			"xfsCEUOutputBinHigh" } ,
	Read(TRUE), 
	Write(FALSE),
	Description	("contains the state of the CEU output bin")]
	sint32 xfsCEUStatusOutputBin;
	
	[ValueMap {"1", "4", "2", "3"} ,
	Values	{"xfsCEUInputBinOK", "xfsCEUInputBinNotSupported", "xfsCEUInputBinEmpty",
			"xfsCEUInputBinLow" } ,
	Read(TRUE), 
	Write(FALSE),
	Description	("")]
	sint32 xfsCEUStatusInputBin;
	
	[Read(TRUE), 
	Write(FALSE),
	Description	("The total number of cards, including those in input bin, output bin, and retain bin")]
	uint32 xfsCEUTotalCards;
	
	[Read(TRUE), 
	Write(FALSE),
	Description	("The total number of output bin cards.")]
	uint32 xfsCEUOutputCards;
	
	[Read(TRUE), 
	Write(FALSE),
	Description	("The total number of retain bin cards")]
	uint32 xfsCEURetainCards;
};

[Description	("Indicates that the device could not be negotiated for within the time specified in the Reset operation"),       
 SNMPGroup(12),
 SNMPTrapClass(7)]
class xfsCEUResetNegotiationTimeoutEvent:  xfsEvent
{
};

[Description	("Reports the outcome of the Reset operation."),       
 SNMPGroup(12),
 SNMPTrapClass(8)]
class xfsCEUResetCompleteEvent: xfsCEUDeviceStatusChangeEvent
{
	[Description	("The XFS response to the Reset command. ") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsResponse;
};


//=========================================================================================
// xfsCRD
//=========================================================================================
[Description	("Status for CRD device."),
 Dynamic:ToInstance, Provider("NCR_WMICoreProvider")]
class xfsCRD : xfsDevice
{
	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsCRDCUOK", "xfsCRDCUState", "xfsCRDCUStop",
			"xfsCRDCUUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the card units including all retain bins. Allowed values as follows")]
	sint32 xfsCRDDispenserStatus;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsCRDTransportOK", "xfsCRDTransportInoperative", "xfsCRDTransportUnknown",
			"xfsCRDTransportNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("")]
	sint32 xfsCRDTransportStatus;

	[ValueMap {"1", "2", "3", "4", "5", "6"} ,
	Values	{"xfsCRDMediaPresent", "xfsCRDMediaNotPresent", "xfsCRDMediaJammed",
			"xfsCRDMediaNotSupported", "xfsCRDMediaUnknown", "xfsCRDMediaExiting"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of a card that may or may not be present in the device")]
	sint32 xfsCRDMediaStatus;

	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsCRDShutterClosed", "xfsCRDShutterOpen", "xfsCRDShutterJammed",
			"xfsCRDShutterUnknown", "xfsCRDShutterNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the shutter ")]
	sint32 xfsCRDShutterStatus;

	[BitMap {"0", "1", "4", "8", "16", "128", "256","512","1024","2048","4096","8192","16384"} ,
	BitValues	{"xfsCRDGuideLightsNotAvailable", "xfsCRDGuideLightsOff", "xfsCRDGuideLightsSlowFlash",
			"xfsCRDGuideLightsMediumFlash", "xfsCRDGuideLightsQuickFlash", "xfsCRDGuideLightsContinuous",
			"xfsCRDGuideLightsRed","xfsCRDGuideLightsGreen","xfsCRDGuideLightsYellow",
			"xfsCRDGuideLightsBlue","xfsCRDGuideLightsCyan","xfsCRDGuideLightsMagenta",
			"xfsCRDGuideLightsWhite"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("contains the state of the Card Dispenser guidelight")]
	sint32 xfsCRDCardDispenserGuideLights;
	
	[BitMap {"0", "1", "4", "8", "16", "128", "256","512","1024","2048","4096","8192","16384"} ,
	BitValues	{"xfsCRDGuideLightsNotAvailable", "xfsCRDGuideLightsOff", "xfsCRDGuideLightsSlowFlash",
			"xfsCRDGuideLightsMediumFlash", "xfsCRDGuideLightsQuickFlash", "xfsCRDGuideLightsContinuous",
			"xfsCRDGuideLightsRed","xfsCRDGuideLightsGreen","xfsCRDGuideLightsYellow",
			"xfsCRDGuideLightsBlue","xfsCRDGuideLightsCyan","xfsCRDGuideLightsMagenta",
			"xfsCRDGuideLightsWhite"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("contains all guidance light information in the order received from XFS")]
	sint32 xfsCRDAllGuidanceLightCollection[];	

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsCRDDeviceInPosition", "xfsCRDDeviceNotInPosition", "xfsCRDDeviceUnknownPosition",
			"xfsCRDDevicePositionNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the device position")]
	sint32 xfsCRDDevicePositionStatus;

	[Read(TRUE), 
	Write(FALSE),
	Description	("the actual number of seconds required by the device to resume its normal operational state from the current power saving mode")]
	uint32 xfsCRDPowerSaveRecoveryTime;

	[implemented: ToSubClass, Description("This method will negotiate for access to the device (using, for example, the APTRA Resource Management component) and, when available, will invoke the XFS Reset command. ") ]
	void xfsCRDReset([Description("The number of seconds to wait for successful negotiation of the device"), in]sint32 WaitTime, [Description("Specifies the action to be performed if deposited media is detected during the reset operation"), in]sint32 Action);

};

[Description	("Status changes of managed services are reported as system events to the XFS Agent.")]
class xfsCRDDeviceStatusChangeEvent : xfsDeviceStatusChangeEvent
{
	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsCRDCUOK", "xfsCRDCUState", "xfsCRDCUStop",
			"xfsCRDCUUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the card units including all retain bins. Allowed values as follows")]
	sint32 xfsCRDDispenserStatus;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsCRDTransportOK", "xfsCRDTransportInoperative", "xfsCRDTransportUnknown",
			"xfsCRDTransportNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("")]
	sint32 xfsCRDTransportStatus;

	[ValueMap {"1", "2", "3", "4", "5", "6"} ,
	Values	{"xfsCRDMediaPresent", "xfsCRDMediaNotPresent", "xfsCRDMediaJammed",
			"xfsCRDMediaNotSupported", "xfsCRDMediaUnknown", "xfsCRDMediaExiting"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of a card that may or may not be present in the device")]
	sint32 xfsCRDMediaStatus;

	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsCRDShutterClosed", "xfsCRDShutterOpen", "xfsCRDShutterJammed",
			"xfsCRDShutterUnknown", "xfsCRDShutterNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the shutter ")]
	sint32 xfsCRDShutterStatus;

	[BitMap {"0", "1", "4", "8", "16", "128", "256","512","1024","2048","4096","8192","16384"} ,
	BitValues	{"xfsCRDGuideLightsNotAvailable", "xfsCRDGuideLightsOff", "xfsCRDGuideLightsSlowFlash",
			"xfsCRDGuideLightsMediumFlash", "xfsCRDGuideLightsQuickFlash", "xfsCRDGuideLightsContinuous",
			"xfsCRDGuideLightsRed","xfsCRDGuideLightsGreen","xfsCRDGuideLightsYellow",
			"xfsCRDGuideLightsBlue","xfsCRDGuideLightsCyan","xfsCRDGuideLightsMagenta",
			"xfsCRDGuideLightsWhite"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("contains the state of the Card Dispenser guidelight")]
	sint32 xfsCRDCardDispenserGuideLights;
	
	[BitMap {"0", "1", "4", "8", "16", "128", "256","512","1024","2048","4096","8192","16384"} ,
	BitValues	{"xfsCRDGuideLightsNotAvailable", "xfsCRDGuideLightsOff", "xfsCRDGuideLightsSlowFlash",
			"xfsCRDGuideLightsMediumFlash", "xfsCRDGuideLightsQuickFlash", "xfsCRDGuideLightsContinuous",
			"xfsCRDGuideLightsRed","xfsCRDGuideLightsGreen","xfsCRDGuideLightsYellow",
			"xfsCRDGuideLightsBlue","xfsCRDGuideLightsCyan","xfsCRDGuideLightsMagenta",
			"xfsCRDGuideLightsWhite"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("contains all guidance light information in the order received from XFS")]
	sint32 xfsCRDAllGuidanceLightCollection[];	

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsCRDDeviceInPosition", "xfsCRDDeviceNotInPosition", "xfsCRDDeviceUnknownPosition",
			"xfsCRDDevicePositionNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the device position")]
	sint32 xfsCRDDevicePositionStatus;

	[Read(TRUE), 
	Write(FALSE),
	Description	("the actual number of seconds required by the device to resume its normal operational state from the current power saving mode")]
	uint32 xfsCRDPowerSaveRecoveryTime;
};

[Description	("Indicates that the device could not be negotiated for within the time specified in the Reset operation"),       
 SNMPGroup(12),
 SNMPTrapClass(7)]
class xfsCRDResetNegotiationTimeoutEvent:  xfsEvent
{
};

[Description	("Reports the outcome of the Reset operation."),       
 SNMPGroup(12),
 SNMPTrapClass(8)]
class xfsCRDResetCompleteEvent: xfsCRDDeviceStatusChangeEvent
{
	[Description	("The XFS response to the Reset command. ") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsResponse;
};

//=========================================================================================
// xfsBCR
//=========================================================================================
[Description	("Status for BCR device."),
 Dynamic:ToInstance, Provider("NCR_WMICoreProvider")]
class xfsBCR : xfsDevice
{
	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsBCRScannerOn", "xfsBCRScannerOff", "xfsBCRScannerInoperative",
			"xfsBCRScannerUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the scanner status")]
	sint32 xfsBCRScannerStatus;

	[BitMap {"0", "1", "4", "8", "16", "128", "256","512","1024","2048","4096","8192","16384"} ,
	BitValues	{"xfsBCRGuideLightsNotAvailable", "xfsBCRGuideLightsOff", "xfsBCRGuideLightsSlowFlash",
			"xfsBCRGuideLightsMediumFlash", "xfsBCRGuideLightsQuickFlash", "xfsBCRGuideLightsContinuous",
			"xfsBCRGuideLightsRed","xfsBCRGuideLightsGreen","xfsBCRGuideLightsYellow",
			"xfsBCRGuideLightsBlue","xfsBCRGuideLightsCyan","xfsBCRGuideLightsMagenta",
			"xfsBCRGuideLightsWhite"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("contains the state of the BCR guidelight")]
	sint32 xfsBCRGuideLights;
	
	[BitMap {"0", "1", "4", "8", "16", "128", "256","512","1024","2048","4096","8192","16384"} ,
	BitValues	{"xfsBCRGuideLightsNotAvailable", "xfsBCRGuideLightsOff", "xfsBCRGuideLightsSlowFlash",
			"xfsBCRGuideLightsMediumFlash", "xfsBCRGuideLightsQuickFlash", "xfsBCRGuideLightsContinuous",
			"xfsBCRGuideLightsRed","xfsBCRGuideLightsGreen","xfsBCRGuideLightsYellow",
			"xfsBCRGuideLightsBlue","xfsBCRGuideLightsCyan","xfsBCRGuideLightsMagenta",
			"xfsBCRGuideLightsWhite"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("contains all guidance light information in the order received from XFS")]
	sint32 xfsBCRAllGuidanceLightCollection[];
	
	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsBCRDeviceInPosition", "xfsBCRDeviceNotInPosition", "xfsBCRDeviceUnknownPosition",
			"xfsBCRDevicePositionNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the device position")]
	sint32 xfsBCRDevicePositionStatus;

	[Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the actual number of seconds required by the device to resume its normal operational state from the current power saving mode")]
	uint32 xfsBCRPowerSaveRecoveryTime;

	[implemented: ToSubClass, Description("This method will negotiate for access to the device (using, for example, the APTRA Resource Management component) and, when available, will invoke the XFS Reset command. ") ]
	void xfsBCRReset([Description("The number of seconds to wait for successful negotiation of the device"), in]sint32 WaitTime);

};

[Description	("Status changes of managed services are reported as system events to the XFS Agent.")]
class xfsBCRDeviceStatusChangeEvent : xfsDeviceStatusChangeEvent
{
	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsBCRScannerOn", "xfsBCRScannerOff", "xfsBCRScannerInoperative",
			"xfsBCRScannerUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the scanner status")]
	sint32 xfsBCRScannerStatus;

	[BitMap {"0", "1", "4", "8", "16", "128", "256","512","1024","2048","4096","8192","16384"} ,
	BitValues	{"xfsBCRGuideLightsNotAvailable", "xfsBCRGuideLightsOff", "xfsBCRGuideLightsSlowFlash",
			"xfsBCRGuideLightsMediumFlash", "xfsBCRGuideLightsQuickFlash", "xfsBCRGuideLightsContinuous",
			"xfsBCRGuideLightsRed","xfsBCRGuideLightsGreen","xfsBCRGuideLightsYellow",
			"xfsBCRGuideLightsBlue","xfsBCRGuideLightsCyan","xfsBCRGuideLightsMagenta",
			"xfsBCRGuideLightsWhite"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("contains the state of the BCR guidelight")]
	sint32 xfsBCRGuideLights;
	
	[BitMap {"0", "1", "4", "8", "16", "128", "256","512","1024","2048","4096","8192","16384"} ,
	BitValues	{"xfsBCRGuideLightsNotAvailable", "xfsBCRGuideLightsOff", "xfsBCRGuideLightsSlowFlash",
			"xfsBCRGuideLightsMediumFlash", "xfsBCRGuideLightsQuickFlash", "xfsBCRGuideLightsContinuous",
			"xfsBCRGuideLightsRed","xfsBCRGuideLightsGreen","xfsBCRGuideLightsYellow",
			"xfsBCRGuideLightsBlue","xfsBCRGuideLightsCyan","xfsBCRGuideLightsMagenta",
			"xfsBCRGuideLightsWhite"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("contains all guidance light information in the order received from XFS")]
	sint32 xfsBCRAllGuidanceLightCollection[];
	
	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsBCRDeviceInPosition", "xfsBCRDeviceNotInPosition", "xfsBCRDeviceUnknownPosition",
			"xfsBCRDevicePositionNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the device position")]
	sint32 xfsBCRDevicePositionStatus;

	[Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the actual number of seconds required by the device to resume its normal operational state from the current power saving mode")]
	uint32 xfsBCRPowerSaveRecoveryTime;
};

[Description	("Indicates that the device could not be negotiated for within the time specified in the Reset operation"),       
 SNMPGroup(12),
 SNMPTrapClass(7)]
class xfsBCRResetNegotiationTimeoutEvent:  xfsEvent
{
};

[Description	("Reports the outcome of the Reset operation."),       
 SNMPGroup(12),
 SNMPTrapClass(8)]
class xfsBCRResetCompleteEvent: xfsBCRDeviceStatusChangeEvent
{
	[Description	("The XFS response to the Reset command. ") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsResponse;
};

//=========================================================================================
// xfsIPM
//=========================================================================================
[Description	("Status for IPM device."),
 Dynamic:ToInstance, Provider("NCR_WMICoreProvider")]
class xfsIPM : xfsDevice
{
	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsIPMAcceptorBinsOK", "xfsIPMAcceptorBinsState", "xfsIPMAcceptorBinsStop",
			"xfsIPMAcceptorBinsUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the overall acceptor media bins")]
	sint32 xfsIPMAcceptorStatus;

	[ValueMap {"0", "1", "2", "3", "4", "5"} ,
	Values	{"xfsIPMMediaPresent", "xfsIPMMediaNotPresent", "xfsIPMMediaJammed",
			"xfsIPMMediaNotSupported", "xfsIPMMediaUnknown", "xfsIPMMediaPosition"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the media")]
	sint32 xfsIPMMediaStatus;

	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsIPMTonerFull", "xfsIPMTonerLow", "xfsIPMTonerOut",
			"xfsIPMTonerNotSupported", "xfsIPMTonerUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the toner or ink supply or the state of the ribbon of the endorser")]
	sint32 xfsIPMTonerStatus;

	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsIPMInkFull", "xfsIPMInkLow", "xfsIPMInkOut",
			"xfsIPMInkNotSupported", "xfsIPMInkUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the status of the stamping ink")]
	sint32 xfsIPMInkStatus;

	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsIPMScannerOK", "xfsIPMScannerFading", "xfsIPMScannerInoperative",
			"xfsIPMScannerNotSupported", "xfsIPMScannerUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the status of the image scanner that captures images of the front of the media items")]
	sint32 xfsIPMFrontImageScannerStatus;

	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsIPMScannerOK", "xfsIPMScannerFading", "xfsIPMScannerInoperative",
			"xfsIPMScannerNotSupported", "xfsIPMScannerUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the status of the image scanner that captures images of the back of the media items")]
	sint32 xfsIPMBackImageScannerStatus;


	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsIPMMICROK", "xfsIPMMICRFading", "xfsIPMMICRInoperative", "xfsIPMMICRNotSupported",
			"xfsIPMMICRUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the status of the MICR code line reader")]
	sint32 xfsIPMMICRReaderStatus;

	[ValueMap {"0", "1", "2", "3", "4", "5"} ,
	Values	{"xfsIPMStackerEmpty", "xfsIPMStackerNotEmpty", "xfsIPMStackerFull",
			"xfsIPMStackerInoperative", "xfsIPMStackerUnknown", "xfsIPMStackerNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Supplies the state of the stacker (also known as an escrow).")]
	sint32 xfsIPMStackerStatus;

	[ValueMap {"0", "1", "2", "3", "4", "5"} ,
	Values	{"xfsIPMReBuncherEmpty", "xfsIPMReBuncherNotEmpty", "xfsIPMReBuncherFull",
			"xfsIPMReBuncherInoperative", "xfsIPMReBuncherUnknown", "xfsIPMReBuncherNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Supplies the state of the re-buncher (return stacker).")]
	sint32 xfsIPMReBuncherStatus;

	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsIPMFeederEmpty", "xfsIPMFeederNotEmpty", "xfsIPMFeederInoperative",
			"xfsIPMFeederUnknown", "xfsIPMFeederNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Supplies the state of the media feeder")]
	sint32 xfsIPMMediaFeederStatus;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsIPMShutterClosed", "xfsIPMShutterOpen", "xfsIPMShutterJammed",
			"xfsIPMShutterUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the shutter ")]
	sint32 xfsIPMInputPositionShutterStatus;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsIPMPositionEmpty", "xfsIPMPositionNotEmpty", "xfsIPMPositionUnknown",
			"xfsIPMPositionNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The status of the input or output position")]
	sint32 xfsIPMInputPositionStatus;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsIPMTransportOK", "xfsIPMTransportInoperative", "xfsIPMTransporUnknown",
			"xfsIPMTransportNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the transport mechanism")]
	sint32 xfsIPMInputPositionTransportStatus;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsIPMTransportMediaEmpty", "xfsIPMTransportMediaNotEmpty", "xfsIPMTransportMediaUnknown",
			"xfsIPMTransportMediaNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Returns information regarding items which may be present on the transport")]
	sint32 xfsIPMInputPositionTransportMediaStatus;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsIPMShutterClosed", "xfsIPMShutterOpen", "xfsIPMShutterJammed",
			"xfsIPMShutterUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the shutter ")]
	sint32 xfsIPMOutputPositionShutterStatus;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsIPMPositionEmpty", "xfsIPMPositionNotEmpty", "xfsIPMPositionUnknown",
			"xfsIPMPositionNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The status of the input or output position")]
	sint32 xfsIPMOutputPositionStatus;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsIPMTransportOK", "xfsIPMTransportInoperative", "xfsIPMTransporUnknown",
			"xfsIPMTransportNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the transport mechanism")]
	sint32 xfsIPMOutputPositionTransportStatus;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsIPMTransportMediaEmpty", "xfsIPMTransportMediaNotEmpty", "xfsIPMTransportMediaUnknown",
			"xfsIPMTransportMediaNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Returns information regarding items which may be present on the transport")]
	sint32 xfsIPMOutputPositionTransportMediaStatus;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsIPMShutterClosed", "xfsIPMShutterOpen", "xfsIPMShutterJammed",
			"xfsIPMShutterUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the shutter ")]
	sint32 xfsIPMRefusedPositionShutterStatus;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsIPMPositionEmpty", "xfsIPMPositionNotEmpty", "xfsIPMPositionUnknown",
			"xfsIPMPositionNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The status of the input or output position")]
	sint32 xfsIPMRefusedPositionStatus;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsIPMTransportOK", "xfsIPMTransportInoperative", "xfsIPMTransporUnknown",
			"xfsIPMTransportNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the transport mechanism")]
	sint32 xfsIPMRefusedPositionTransportStatus;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsIPMTransportMediaEmpty", "xfsIPMTransportMediaNotEmpty", "xfsIPMTransportMediaUnknown",
			"xfsIPMTransportMediaNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Returns information regarding items which may be present on the transport")]
	sint32 xfsIPMRefusedPositionTransportMediaStatus;
	
	[BitMap {"0", "1", "4", "8", "16", "128", "256","512","1024","2048","4096","8192","16384"} ,
	BitValues	{"xfsIPMGuideLightsNotAvailable", "xfsIPMGuideLightsOff", "xfsIPMGuideLightsSlowFlash",
			"xfsIPMGuideLightsMediumFlash", "xfsIPMGuideLightsQuickFlash", "xfsIPMGuideLightsContinuous",
			"xfsIPMGuideLightsRed","xfsIPMGuideLightsGreen","xfsIPMGuideLightsYellow",
			"xfsIPMGuideLightsBlue","xfsIPMGuideLightsCyan","xfsIPMGuideLightsMagenta",
			"xfsIPMGuideLightsWhite"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Contains the state of the guidelight.")]
	sint32 xfsIPMMediaInGuideLights;
	
	[BitMap {"0", "1", "4", "8", "16", "128", "256","512","1024","2048","4096","8192","16384"} ,
	BitValues	{"xfsIPMGuideLightsNotAvailable", "xfsIPMGuideLightsOff", "xfsIPMGuideLightsSlowFlash",
			"xfsIPMGuideLightsMediumFlash", "xfsIPMGuideLightsQuickFlash", "xfsIPMGuideLightsContinuous",
			"xfsIPMGuideLightsRed","xfsIPMGuideLightsGreen","xfsIPMGuideLightsYellow",
			"xfsIPMGuideLightsBlue","xfsIPMGuideLightsCyan","xfsIPMGuideLightsMagenta",
			"xfsIPMGuideLightsWhite"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Contains the state of the guidelight.")]
	sint32 xfsIPMMediaOutGuideLights;
	
	[BitMap {"0", "1", "4", "8", "16", "128", "256","512","1024","2048","4096","8192","16384"} ,
	BitValues	{"xfsIPMGuideLightsNotAvailable", "xfsIPMGuideLightsOff", "xfsIPMGuideLightsSlowFlash",
			"xfsIPMGuideLightsMediumFlash", "xfsIPMGuideLightsQuickFlash", "xfsIPMGuideLightsContinuous",
			"xfsIPMGuideLightsRed","xfsIPMGuideLightsGreen","xfsIPMGuideLightsYellow",
			"xfsIPMGuideLightsBlue","xfsIPMGuideLightsCyan","xfsIPMGuideLightsMagenta",
			"xfsIPMGuideLightsWhite"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Contains the state of the guidelight.")]
	sint32 xfsIPMMediaRefusedGuideLights;
	
	[BitMap {"0", "1", "4", "8", "16", "128", "256","512","1024","2048","4096","8192","16384"} ,
	BitValues	{"xfsIPMGuideLightsNotAvailable", "xfsIPMGuideLightsOff", "xfsIPMGuideLightsSlowFlash",
			"xfsIPMGuideLightsMediumFlash", "xfsIPMGuideLightsQuickFlash", "xfsIPMGuideLightsContinuous",
			"xfsIPMGuideLightsRed","xfsIPMGuideLightsGreen","xfsIPMGuideLightsYellow",
			"xfsIPMGuideLightsBlue","xfsIPMGuideLightsCyan","xfsIPMGuideLightsMagenta",
			"xfsIPMGuideLightsWhite"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("This collection contains all guidance light information in the order received from XFS")]
	sint32 xfsIPMAllGuidanceLightCollection[];
	
	

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsIPMDeviceInPosition", "xfsIPMDeviceNotInPosition", "xfsIPMDeviceUnknownPosition",
			"xfsIPMDevicePositionNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the device position")]
	sint32 xfsIPMDevicePositionStatus;

	[Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the actual number of seconds required by the device to resume its normal operational state from the current power saving mode")]
	uint32 xfsIPMPowerSaveRecoveryTime;

	[implemented: ToSubClass, Description("This method will negotiate for access to the device (using, for example, the APTRA Resource Management component) and, when available, will invoke the XFS Reset command. ") ]
	void xfsIPMReset([Description("The number of seconds to wait for successful negotiation of the device"), in]sint32 WaitTime, [Description("Specifies the manner in which the media should be handled"), in]sint32 MediaControl, [Description("Number of the retract bin the media is retracted to"), in]sint32 BinNumber);

};

[Description	("Status changes of managed services are reported as system events to the XFS Agent.")]
class xfsIPMDeviceStatusChangeEvent : xfsDeviceStatusChangeEvent
{
	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsIPMAcceptorBinsOK", "xfsIPMAcceptorBinsState", "xfsIPMAcceptorBinsStop",
			"xfsIPMAcceptorBinsUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the overall acceptor media bins")]
	sint32 xfsIPMAcceptorStatus;

	[ValueMap {"0", "1", "2", "3", "4", "5"} ,
	Values	{"xfsIPMMediaPresent", "xfsIPMMediaNotPresent", "xfsIPMMediaJammed",
			"xfsIPMMediaNotSupported", "xfsIPMMediaUnknown", "xfsIPMMediaPosition"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the media")]
	sint32 xfsIPMMediaStatus;

	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsIPMTonerFull", "xfsIPMTonerLow", "xfsIPMTonerOut",
			"xfsIPMTonerNotSupported", "xfsIPMTonerUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the toner or ink supply or the state of the ribbon of the endorser")]
	sint32 xfsIPMTonerStatus;

	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsIPMInkFull", "xfsIPMInkLow", "xfsIPMInkOut",
			"xfsIPMInkNotSupported", "xfsIPMInkUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the status of the stamping ink")]
	sint32 xfsIPMInkStatus;

	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsIPMScannerOK", "xfsIPMScannerFading", "xfsIPMScannerInoperative",
			"xfsIPMScannerNotSupported", "xfsIPMScannerUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the status of the image scanner that captures images of the front of the media items")]
	sint32 xfsIPMFrontImageScannerStatus;

	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsIPMScannerOK", "xfsIPMScannerFading", "xfsIPMScannerInoperative",
			"xfsIPMScannerNotSupported", "xfsIPMScannerUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the status of the image scanner that captures images of the back of the media items")]
	sint32 xfsIPMBackImageScannerStatus;


	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsIPMMICROK", "xfsIPMMICRFading", "xfsIPMMICRInoperative", "xfsIPMMICRNotSupported",
			"xfsIPMMICRUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the status of the MICR code line reader")]
	sint32 xfsIPMMICRReaderStatus;

	[ValueMap {"0", "1", "2", "3", "4", "5"} ,
	Values	{"xfsIPMStackerEmpty", "xfsIPMStackerNotEmpty", "xfsIPMStackerFull",
			"xfsIPMStackerInoperative", "xfsIPMStackerUnknown", "xfsIPMStackerNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Supplies the state of the stacker (also known as an escrow).")]
	sint32 xfsIPMStackerStatus;

	[ValueMap {"0", "1", "2", "3", "4", "5"} ,
	Values	{"xfsIPMReBuncherEmpty", "xfsIPMReBuncherNotEmpty", "xfsIPMReBuncherFull",
			"xfsIPMReBuncherInoperative", "xfsIPMReBuncherUnknown", "xfsIPMReBuncherNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Supplies the state of the re-buncher (return stacker).")]
	sint32 xfsIPMReBuncherStatus;

	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsIPMFeederEmpty", "xfsIPMFeederNotEmpty", "xfsIPMFeederInoperative",
			"xfsIPMFeederUnknown", "xfsIPMFeederNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Supplies the state of the media feeder")]
	sint32 xfsIPMMediaFeederStatus;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsIPMShutterClosed", "xfsIPMShutterOpen", "xfsIPMShutterJammed",
			"xfsIPMShutterUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the shutter ")]
	sint32 xfsIPMInputPositionShutterStatus;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsIPMPositionEmpty", "xfsIPMPositionNotEmpty", "xfsIPMPositionUnknown",
			"xfsIPMPositionNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The status of the input or output position")]
	sint32 xfsIPMInputPositionStatus;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsIPMTransportOK", "xfsIPMTransportInoperative", "xfsIPMTransporUnknown",
			"xfsIPMTransportNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the transport mechanism")]
	sint32 xfsIPMInputPositionTransportStatus;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsIPMTransportMediaEmpty", "xfsIPMTransportMediaNotEmpty", "xfsIPMTransportMediaUnknown",
			"xfsIPMTransportMediaNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Returns information regarding items which may be present on the transport")]
	sint32 xfsIPMInputPositionTransportMediaStatus;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsIPMShutterClosed", "xfsIPMShutterOpen", "xfsIPMShutterJammed",
			"xfsIPMShutterUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the shutter ")]
	sint32 xfsIPMOutputPositionShutterStatus;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsIPMPositionEmpty", "xfsIPMPositionNotEmpty", "xfsIPMPositionUnknown",
			"xfsIPMPositionNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The status of the input or output position")]
	sint32 xfsIPMOutputPositionStatus;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsIPMTransportOK", "xfsIPMTransportInoperative", "xfsIPMTransporUnknown",
			"xfsIPMTransportNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the transport mechanism")]
	sint32 xfsIPMOutputPositionTransportStatus;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsIPMTransportMediaEmpty", "xfsIPMTransportMediaNotEmpty", "xfsIPMTransportMediaUnknown",
			"xfsIPMTransportMediaNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Returns information regarding items which may be present on the transport")]
	sint32 xfsIPMOutputPositionTransportMediaStatus;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsIPMShutterClosed", "xfsIPMShutterOpen", "xfsIPMShutterJammed",
			"xfsIPMShutterUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the shutter ")]
	sint32 xfsIPMRefusedPositionShutterStatus;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsIPMPositionEmpty", "xfsIPMPositionNotEmpty", "xfsIPMPositionUnknown",
			"xfsIPMPositionNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The status of the input or output position")]
	sint32 xfsIPMRefusedPositionStatus;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsIPMTransportOK", "xfsIPMTransportInoperative", "xfsIPMTransporUnknown",
			"xfsIPMTransportNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the transport mechanism")]
	sint32 xfsIPMRefusedPositionTransportStatus;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsIPMTransportMediaEmpty", "xfsIPMTransportMediaNotEmpty", "xfsIPMTransportMediaUnknown",
			"xfsIPMTransportMediaNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Returns information regarding items which may be present on the transport")]
	sint32 xfsIPMRefusedPositionTransportMediaStatus;
	
	[BitMap {"0", "1", "4", "8", "16", "128", "256","512","1024","2048","4096","8192","16384"} ,
	BitValues	{"xfsIPMGuideLightsNotAvailable", "xfsIPMGuideLightsOff", "xfsIPMGuideLightsSlowFlash",
			"xfsIPMGuideLightsMediumFlash", "xfsIPMGuideLightsQuickFlash", "xfsIPMGuideLightsContinuous",
			"xfsIPMGuideLightsRed","xfsIPMGuideLightsGreen","xfsIPMGuideLightsYellow",
			"xfsIPMGuideLightsBlue","xfsIPMGuideLightsCyan","xfsIPMGuideLightsMagenta",
			"xfsIPMGuideLightsWhite"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Contains the state of the guidelight.")]
	sint32 xfsIPMMediaInGuideLights;
	
	[BitMap {"0", "1", "4", "8", "16", "128", "256","512","1024","2048","4096","8192","16384"} ,
	BitValues	{"xfsIPMGuideLightsNotAvailable", "xfsIPMGuideLightsOff", "xfsIPMGuideLightsSlowFlash",
			"xfsIPMGuideLightsMediumFlash", "xfsIPMGuideLightsQuickFlash", "xfsIPMGuideLightsContinuous",
			"xfsIPMGuideLightsRed","xfsIPMGuideLightsGreen","xfsIPMGuideLightsYellow",
			"xfsIPMGuideLightsBlue","xfsIPMGuideLightsCyan","xfsIPMGuideLightsMagenta",
			"xfsIPMGuideLightsWhite"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Contains the state of the guidelight.")]
	sint32 xfsIPMMediaOutGuideLights;
	
	[BitMap {"0", "1", "4", "8", "16", "128", "256","512","1024","2048","4096","8192","16384"} ,
	BitValues	{"xfsIPMGuideLightsNotAvailable", "xfsIPMGuideLightsOff", "xfsIPMGuideLightsSlowFlash",
			"xfsIPMGuideLightsMediumFlash", "xfsIPMGuideLightsQuickFlash", "xfsIPMGuideLightsContinuous",
			"xfsIPMGuideLightsRed","xfsIPMGuideLightsGreen","xfsIPMGuideLightsYellow",
			"xfsIPMGuideLightsBlue","xfsIPMGuideLightsCyan","xfsIPMGuideLightsMagenta",
			"xfsIPMGuideLightsWhite"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Contains the state of the guidelight.")]
	sint32 xfsIPMMediaRefusedGuideLights;
	
	[BitMap {"0", "1", "4", "8", "16", "128", "256","512","1024","2048","4096","8192","16384"} ,
	BitValues	{"xfsIPMGuideLightsNotAvailable", "xfsIPMGuideLightsOff", "xfsIPMGuideLightsSlowFlash",
			"xfsIPMGuideLightsMediumFlash", "xfsIPMGuideLightsQuickFlash", "xfsIPMGuideLightsContinuous",
			"xfsIPMGuideLightsRed","xfsIPMGuideLightsGreen","xfsIPMGuideLightsYellow",
			"xfsIPMGuideLightsBlue","xfsIPMGuideLightsCyan","xfsIPMGuideLightsMagenta",
			"xfsIPMGuideLightsWhite"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("This collection contains all guidance light information in the order received from XFS")]
	sint32 xfsIPMAllGuidanceLightCollection[];

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsIPMDeviceInPosition", "xfsIPMDeviceNotInPosition", "xfsIPMDeviceUnknownPosition",
			"xfsIPMDevicePositionNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the device position")]
	sint32 xfsIPMDevicePositionStatus;

	[Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the actual number of seconds required by the device to resume its normal operational state from the current power saving mode")]
	uint32 xfsIPMPowerSaveRecoveryTime;
};

[Description	("Indicates that the device could not be negotiated for within the time specified in the Reset operation"),       
 SNMPGroup(12),
 SNMPTrapClass(7)]
class xfsIPMResetNegotiationTimeoutEvent:  xfsEvent
{
};

[Description	("Reports the outcome of the Reset operation."),       
 SNMPGroup(12),
 SNMPTrapClass(8)]
class xfsIPMResetCompleteEvent: xfsIPMDeviceStatusChangeEvent
{
	[Description	("The XFS response to the Reset command. ") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsResponse;
};

//=========================================================================================
// xfsCDMSubDevice
//=========================================================================================

//=========================================================================================
//The key for IPM SubDevice should be the name of the managed service that the subdevice 
//belongs to  (xfsSubDeviceManagedServiceName) and suffixed with bin followed by a three 
//digit unsigned ID that represents the bin number (xfsSubDeviceIndex).  
//Example: ipmr1bin001, ipmr1bin001
//=========================================================================================

[Description	("Sub device status for IPM Device."),
 Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider")]

class xfsIPMSubDevice : xfsSubDevice
{
	[Read(TRUE), 
	Write(FALSE),
	Description	("Index number of the media bin structure")]
	uint32 xfsIPMSubDeviceBinNumber;

	[Read(TRUE), 
	Write(FALSE),
	Description	("The physical position name where the bin is inserted")]
	string xfsIPMSubDevicePositionName;

	[ValueMap {"1", "2"} ,
	Values	{"xfsIPMMediaTypeIPM", "xfsIPMMediaTypeCompound"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the type of media the media bin takes")]
	sint32 xfsIMPSubDeviceMediaType;

	[Read(TRUE), 
	Write(FALSE),
	Description	("An application defined Media Bin Identifier")]
	string xfsIMPSubDeviceBinID;

	[Read(TRUE), 
	Write(FALSE),
	Description	("Count of items that have entered the media bin as a result of operations on the IPM interface")]
	uint32 xfsIMPSubDeviceMediaInCount;

	[Read(TRUE), 
	Write(FALSE),
	Description	("Total number of media in the media bin (including items that may have been added via a compound device interface).")]
	uint32 xfsIMPSubDeviceCount;

	[Read(TRUE), 
	Write(FALSE),
	Description	("The number of Retract operations")]
	uint32 xfsIMPSubDeviceRetractOperations;

	[Read(TRUE), 
	Write(FALSE),
	Description	("A capability that specifies whether or not the threshold event  can be generated based on hardware sensors in the device")]
	boolean xfsIMPSubDeviceHardwareSensors;

	[Read(TRUE), 
	Write(FALSE),
	Description	("When xfsIMPSubDeviceCount reaches this value the threshold event will be generated")]
	uint32 xfsIMPSubDeviceMaxItems;

	[Read(TRUE), 
	Write(FALSE),
	Description	("When xfsIMPSubDeviceRetractOperations reaches this value the threshold event will be generated")]
	uint32 xfsIMPSubDeviceMaxRetractOperations;

	[ValueMap {"1", "2", "3","4","5","6"} ,
	Values	{"xfsIPMStatusOK", "xfsIPMStatusFull", "xfsIPMStatusHigh",
			"xfsIPMStatusInoperative", "xfsIPMStatusMissing", "xfsIPMStatusUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Describes the status of the media bin ")]
	uint32 xfsIMPSubDeviceStatus;
};


//=========================================================================================
// xfsIPMSubDeviceStatusChangeEvent
//=========================================================================================
[Description	("Status changes of managed services are reported as system events to the "
		"XFS Agent.")]
class xfsIPMSubDeviceStatusChangeEvent : xfsEvent
{
	[Read(TRUE), 
	Write(FALSE),
	Description	("Index number of the media bin structure")]
	uint32 xfsIPMSubDeviceBinNumber;

	[Read(TRUE), 
	Write(FALSE),
	Description	("The physical position name where the bin is inserted")]
	string xfsIPMSubDevicePositionName;

	[ValueMap {"1", "2"} ,
	Values	{"xfsIPMMediaTypeIPM", "xfsIPMMediaTypeCompound"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the type of media the media bin takes")]
	sint32 xfsIMPSubDeviceMediaType;

	[Read(TRUE), 
	Write(FALSE),
	Description	("An application defined Media Bin Identifier")]
	string xfsIMPSubDeviceBinID;

	[Read(TRUE), 
	Write(FALSE),
	Description	("Count of items that have entered the media bin as a result of operations on the IPM interface")]
	uint32 xfsIMPSubDeviceMediaInCount;

	[Read(TRUE), 
	Write(FALSE),
	Description	("Total number of media in the media bin (including items that may have been added via a compound device interface).")]
	uint32 xfsIMPSubDeviceCount;

	[Read(TRUE), 
	Write(FALSE),
	Description	("The number of Retract operations")]
	uint32 xfsIMPSubDeviceRetractOperations;

	[Read(TRUE), 
	Write(FALSE),
	Description	("A capability that specifies whether or not the threshold event  can be generated based on hardware sensors in the device")]
	boolean xfsIMPSubDeviceHardwareSensors;

	[Read(TRUE), 
	Write(FALSE),
	Description	("When xfsIMPSubDeviceCount reaches this value the threshold event will be generated")]
	uint32 xfsIMPSubDeviceMaxItems;

	[Read(TRUE), 
	Write(FALSE),
	Description	("When xfsIMPSubDeviceRetractOperations reaches this value the threshold event will be generated")]
	uint32 xfsIMPSubDeviceMaxRetractOperations;

	[ValueMap {"1", "2", "3","4","5","6"} ,
	Values	{"xfsIPMStatusOK", "xfsIPMStatusFull", "xfsIPMStatusHigh",
			"xfsIPMStatusInoperative", "xfsIPMStatusMissing", "xfsIPMStatusUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Describes the status of the media bin ")]
	uint32 xfsIMPSubDeviceStatus;

};




//=========================================================================================
// xfsDEP
//=========================================================================================
[Description	("Status for depository device."),
 Dynamic:ToInstance, Provider("NCR_WMICoreProvider"),       
 SNMPGroup(12),
 SNMPConcreteClass(2)]
class xfsDEP : xfsDevice
{
	[ValueMap {"0", "1", "2", "3", "4", "5", "6"} ,
	Values	{"xfsDEPContainerOK", "xfsDEPContainerHigh", "xfsDEPContainerFull",
			"xfsDEPContainerInop", "xfsDEPContainerMissing", "xfsDEPContainerUnknown",
			"xfsDEPContainerNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the depository container state. "),
	SNMPPropertyOffset(1) ]
	sint32 xfsDEPStatusContainer;

	[ValueMap {"0", "3", "5", "6"} ,
	Values	{"xfsDEPTransportOK", "xfsDEPTransportInop", "xfsDEPTransportUnknown",
			"xfsDEPTransportNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the depository transport mechanism. "),
	SNMPPropertyOffset(2) ]
	sint32 xfsDEPStatusTransport;

	[ValueMap {"0", "1", "2", "3", "4", "5", "6", "7"} ,
	Values	{"xfsDEPEnvSupplyOK", "xfsDEPEnvSupplyLow", "xfsDEPEnvSupplyEmpty",
			"xfsDEPEnvSupplyInop", "xfsDEPEnvSupplyMissing", "xfsDEPEnvSupplyUnknown",
			"xfsDEPEnvSupplyNotSupported", "xfsDEPEnvSupplyUnlocked"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the envelope supply unit. "),
	SNMPPropertyOffset(3) ]
	sint32 xfsDEPStatusEnvSupply;

	[ValueMap {"0", "3", "5", "6"} ,
	Values	{"xfsDEPEnvDispenserOK", "xfsDEPEnvDispenserInop", "xfsDEPEnvDispenserUnknown",
			"xfsDEPEnvDispenserNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the envelope dispenser. "),
	SNMPPropertyOffset(4) ]
	sint32 xfsDEPStatusEnvDispenser;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsDEPPrinterOK", "xfsDEPPrinterInop", "xfsDEPPrinterUnknown",
			"xfsDEPPrinterNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the printer."),
	SNMPPropertyOffset(5) ]
	sint32 xfsDEPStatusPrinter;

	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsDEPTonerFull", "xfsDEPTonerLow", "xfsDEPTonerOut", "xfsDEPTonerUnknown",
			"xfsDEPTonerNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the toner (or ink) of the printer. "),
	SNMPPropertyOffset(6) ]
	sint32 xfsDEPStatusToner;

	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsDEPShutterClosed", "xfsDEPShutterOpen", "xfsDEPShutterJammed",
			"xfsDEPShutterUnknown", "xfsDEPShutterNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the shutter or door. "),
	SNMPPropertyOffset(7) ]
	sint32 xfsDEPStatusShutter;

	[Read(TRUE), 
	Write(FALSE),
	Description	("It contains the number of envelopes or bags in the deposit container. It "
				"is a numeric type field."),
	SNMPPropertyOffset(8) ]
	sint32 xfsDEPNumberOfDeposits;
	
	[implemented: ToSubClass, Description("This method will negotiate for access to the device (using, for example, the APTRA Resource Management component) and, when available, will invoke the XFS Reset command. The xfsDEPResetCompleteEvent is generated on completion of the operation"), 
	SNMPMethodOffset(1)]
	void xfsDEPReset([Description("The number of seconds to wait for successful negotiation of the device. If access to the device is not achieved within this time then the xfsDEPResetNegotiationTimeoutEvent will be generated."), in]sint32 WaitTime, [Description("Specifies the action to be performed if deposited media is detected during the reset operation"), in]sint32 Action);
};


//=========================================================================================
// xfsPIN
//=========================================================================================
[Description	("Status for PIN Keypad Device."),
 Dynamic:ToInstance, Provider("NCR_WMICoreProvider"),       
 SNMPGroup(12),
 SNMPConcreteClass(3)]
class xfsPIN : xfsDevice
{
	[ValueMap {"0", "1", "2", "3", "4", "5"} ,
	Values	{"xfsPINEncReady", "xfsPINEncNotReady", "xfsPINEncNotInitialized",
			"xfsPINEncBusy", "xfsPINEncUndefined", "xfsPINEncInitialized"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the encryptor module state. "),
	SNMPPropertyOffset(1) ]
	sint32 xfsPINStatusEncStat;

	[ValueMap {"0", "1", "2", "4"} ,
	Values	{"xfsPINCertNotSupp", "xfsPINCertPrimary", "xfsPINCertSeconday",
			"xfsPINCertNotReady"} ,
	Read(TRUE),
	Write(FALSE),
	Description	("It contains the certificate state. "),
	SNMPPropertyOffset(2) ]
	sint32 xfsPINStatusCertificateState;

	[implemented: ToSubClass, 
	Description("This method will negotiate for access to the device (using, for example, the APTRA Resource Management component) and, when available, will invoke the XFS Reset command. The xfsPINResetCompleteEvent is generated on completion of the operation."), 
	SNMPMethodOffset(1)]
	void xfsPINReset([Description("The number of seconds to wait for successful negotiation of the device. If access to the device is not achieved within this time then the xfsPINResetNegotiationTimeoutEvent will be generated"), in]sint32 WaitTime);
};


//=========================================================================================
// xfsSIU
//=========================================================================================
[Description	("Status for Sensors and Indicators Unit Device."),
 Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"),
 SNMPGroup(12),
 SNMPConcreteClass(4)]
class xfsSIU : xfsDevice
{
	[ValueMap {"0", "1", "2", "4"} ,
	Values	{"xfsSIUOperatorSwitchNotAvailable", "xfsSIUOperatorSwitchRun",
			"xfsSIUOperatorSwitchMaintenance", "xfsSIUOperatorSwitchSupervisor"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the operator switch sensor."),
	SNMPPropertyOffset(1) ]
	sint32 xfsSIUStatusOperatorSwitchSensors;

	[ValueMap {"0", "1", "2"} ,
	Values	{"xfsSIUSensorNotAvailable", "xfsSIUSensorOff", "xfsSIUSensorOn"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the tamper sensor. "),
	SNMPPropertyOffset(2) ]
	sint32 xfsSIUStatusTamperSensors;

	[ValueMap {"0", "1", "2"} ,
	Values	{"xfsSIUSensorNotAvailable", "xfsSIUSensorOff", "xfsSIUSensorOn"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the internal tamper sensor.") ,
	SNMPPropertyOffset(3) ]
	sint32 xfsSIUStatusIntTamperSensors;

	[ValueMap {"0", "1", "2"} ,
	Values	{"xfsSIUSensorNotAvailable", "xfsSIUSensorOff", "xfsSIUSensorOn"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the seismic sensor. "),
	SNMPPropertyOffset(4) ]
	sint32 xfsSIUSeismicSensors;

	[ValueMap {"0", "1", "2"} ,
	Values	{"xfsSIUSensorNotAvailable", "xfsSIUSensorOff", "xfsSIUSensorOn"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the heat sensor. "),
	SNMPPropertyOffset(5) ]
	sint32 xfsSIUStatusHeatSensors;

	[ValueMap {"0", "1", "2"} ,
	Values	{"xfsSIUProximityNotAvailable", "xfsSIUProximityPresent",
			"xfsSIUProximityNotPresent"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the proximity sensor. "),
	SNMPPropertyOffset(6) ]
	sint32 xfsSIUStatusProximitySensors;

	[ValueMap {"0", "1", "2", "4", "8", "16"} ,
	Values	{"xfsSIUAmbLightNotAvailable", "xfsSIUAmbLightVeryDark", "xfsSIUAmbLightDark",
			"xfsSIUAmbLightMediumLight", "xfsSIUAmbLightLight", "xfsSIUAmbLightVeryLight"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the ambient light sensor. "),
	SNMPPropertyOffset(7) ]
	sint32 xfsSIUStatusAmbLightSensors;

	[ValueMap {"0", "1", "2"} ,
	Values	{"xfsSIUEnhancedAudioNotAvailable", "xfsSIUEnhancedAudioPresent",
			"xfsSIUEnhancedAudioNotPresent"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the headphone connected to the Audio Jack. "),
	SNMPPropertyOffset(8) ]
	sint32 xfsSIUStatusEnhancedAudioSensors;

	[Read(TRUE), Write(FALSE),
	Description	("This collection contains all sensor information in the order received from XFS. It allows access to any potential vendor specific sensors."),
	SNMPPropertyOffset(9) ]
	sint32 xfsSIUAllSensorsCollection[];
	
	[ValueMap {"0", "1", "2", "4", "8"} ,
	Values	{"xfsSIUDoorsNotAvailable", "xfsSIUDoorsClosed", "xfsSIUDoorsOpen",
			"xfsSIUDoorsLocked", "xfsSIUDoorsBolted"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the cabinet doors. "),
	SNMPPropertyOffset(10) ]
	sint32 xfsSIUStatusCabinetDoors;

	[ValueMap {"0", "1", "2", "4", "8"} ,
	Values	{"xfsSIUDoorsNotAvailable", "xfsSIUDoorsClosed", "xfsSIUDoorsOpen",
			"xfsSIUDoorsLocked", "xfsSIUDoorsBolted"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the safe doors. "),
	SNMPPropertyOffset(11) ]
	sint32 xfsSIUStatusSafeDoors;

	[ValueMap {"0", "1", "2", "4", "16", "32", "64", "128"} ,
	Values	{"xfsSIUVandalShieldNotAvailable", "xfsSIUVandalShieldClosed",
			"xfsSIUVandalShieldOpen", "xfsSIUVandalShieldLocked",
			"xfsSIUVandalShieldService", "xfsSIUVandalShieldKeyboard",
			"xfsSIUVandalShieldAjar", "xfsSIUVandalShieldJammed"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the vandal shield. "),
	SNMPPropertyOffset(12) ]
	sint32 xfsSIUStatusVandalShieldDoors;
	
	[Read(TRUE), 
	Write(FALSE),
	Description	("This collection contains all door information in the order received from XFS. It allows access to any potential vendor specific sensors."),
	SNMPPropertyOffset(13) ]
	sint32 xfsSIUAllDoorsCollection[];	

	[ValueMap {"0", "1", "2"} ,
	Values	{"xfsSIUIndicatorsNotAvailable", "xfsSIUIndicatorsClosed",
			"xfsSIUIndicatorsOpen"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the open/closed indicator. "),
	SNMPPropertyOffset(14) ]
	sint32 xfsSIUStatusOpenCloseIndicators;

	[ValueMap {"0", "1", "2"} ,
	Values	{"xfsSIUIndicatorsNotAvailable", "xfsSIUIndicarorsOff",
			"xfsSIUIndicatorsOn"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the fascia light. "),
	SNMPPropertyOffset(15) ]
	sint32 xfsSIUStatusFasciaLightIndicators;

	[BitMap{"0", "1", "2", "3", "4", "5", "7"} ,
	BitValues	{"WFS_SIU_OFF", "WFS_SIU_KEYPRESS", "WFS_SIU_NOT_EXCLAMATION",
				"WFS_SIU_NOT_WARNING", "WFS_SIU_NOT_ERROR", "WFS_SIU_NOT_CRITICAL",
				"WFS_SIU_NOT_CONTINUOUS"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the audio indicator. It is a bit-mask numeric "
				"type field."),
	SNMPPropertyOffset(16) ]
	sint32 xfsSIUStatusAudioIndicators;

	[ValueMap {"0", "1", "2"} ,
	Values	{"xfsSIUIndicatorsNotAvailable", "xfsSIUIndicarorsOff",
			"xfsSIUIndicatorsOn"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the internal heating. "),
	SNMPPropertyOffset(17) ]
	sint32 xfsSIUStatusHeatingIndicators;
	
	[Read(TRUE), 
	Write(FALSE),
	Description	("This collection contains all indicator information in the order received from XFS. It allows access to any potential vendor specific sensors."),
	SNMPPropertyOffset(18) ]
	sint32 xfsSIUAllIndicatorsCollection[];	

	[MaxValue(1000), MinValue(0),
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the audio volume control. "),
	SNMPPropertyOffset(19) ]
	sint32 xfsSIUStatusVolumeAux;

	[BitMap{"0", "1", "2", "3", "4"} ,
	BitValues	{"WFS_SIU_AVAILABLE", "WFS_SIU_LOW", "WFS_SIU_ENGAGED",
				"WFS_SIU_POWERING", "WFS_SIU_RECOVERED"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the Uninterruptable Power Supply device. "),
	SNMPPropertyOffset(20) ]
	sint32 xfsSIUStatusUPSAux;

	[BitMap{"0", "1", "2", "3", "4", "5"} ,
	BitValues	{"WFS_SIU_GREEN_LED_ON", "WFS_SIU_GREEN_LED_OFF", "WFS_SIU_AMBER_LED_ON",
				"WFS_SIU_AMBER_LED_OFF", "WFS_SIU_RED_LED_ON", "WFS_SIU_RED_LED_OFF"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the Remote Status Monitor device. "),
	SNMPPropertyOffset(21) ]
	sint32 xfsSIUStatusRemoteStatusMonitorAux;

	[ValueMap {"0", "1", "2"} ,
	Values	{"xfsSIUAuxiliaryNotAvailable", "xfsSIUAuxiliaryOff",
			"xfsSIUAuxiliaryOn"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the Audible Alarm device. "),
	SNMPPropertyOffset(22) ]
	sint32 xfsSIUStatusAudibleAlarmAux;

	[ValueMap {"0", "1", "2", "3", "8", "16", "32"} ,
	Values	{"xfsSIUEnhancedAudioControlAuxNotAvailable",
			"xfsSIUEnhancedAudioControlAuxPublicAudioManaual",
			"xfsSIUEnhancedAudioControlAuxPublicAudioAuto",
			"xfsSIUEnhancedAudioControlAuxPublicAudioSemiAuto",
			"xfsSIUEnhancedAudioControlAuxPrivateAudioManual",
			"xfsSIUEnhancedAudioControlAuxPrivateAudioAuto",
			"xfsSIUEnhancedAudioControlAuxPrivateAudioSemiAuto"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the Audio Jack Controller. "),
	SNMPPropertyOffset(23) ]
	sint32 xfsSIUStatusEnhancedAudioControlAux;
	
	[Read(TRUE), 
	Write(FALSE),
	Description	("This collection contains all auxiliary information in the order received from XFS. It allows access to any potential vendor specific sensors."),
	SNMPPropertyOffset(24) ]
	sint32 xfsSIUAllAuxiliariesCollection[];

	[ValueMap {"0", "1", "4", "8", "16", "32"} ,
	Values	{"xfsSIUGuideLightsNotAvailable", "xfsSIUGuideLightsOff",
			"xfsSIUGuideLightsSlowFlash", "xfsSIUGuideLightsMediumFlash",
			"xfsSIUGuideLightsQuickFlash", "xfsSIUGuideLightsContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the Card Unit (IDC) guidelight. "),
	SNMPPropertyOffset(25) ]
	sint32 xfsSIUStatusCardUnitGuideLights;

	[ValueMap {"0", "1", "4", "8", "16", "32"} ,
	Values	{"xfsSIUGuideLightsNotAvailable", "xfsSIUGuideLightsOff",
			"xfsSIUGuideLightsSlowFlash", "xfsSIUGuideLightsMediumFlash",
			"xfsSIUGuideLightsQuickFlash", "xfsSIUGuideLightsContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the PIN pad unit guidelight. "),
	SNMPPropertyOffset(26) ]
	sint32 xfsSIUStatusPinpadGuideLights;

	[ValueMap {"0", "1", "4", "8", "16", "32"} ,
	Values	{"xfsSIUGuideLightsNotAvailable", "xfsSIUGuideLightsOff",
			"xfsSIUGuideLightsSlowFlash", "xfsSIUGuideLightsMediumFlash",
			"xfsSIUGuideLightsQuickFlash", "xfsSIUGuideLightsContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the Note Dispenser unit guidelight. "),
	SNMPPropertyOffset(27) ]
	sint32 xfsSIUStatusNotesDispenserGuideLights;

	[ValueMap {"0", "1", "4", "8", "16", "32"} ,
	Values	{"xfsSIUGuideLightsNotAvailable", "xfsSIUGuideLightsOff",
			"xfsSIUGuideLightsSlowFlash", "xfsSIUGuideLightsMediumFlash",
			"xfsSIUGuideLightsQuickFlash", "xfsSIUGuideLightsContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the Coin Dispenser unit guidelight. "),
	SNMPPropertyOffset(28) ]
	sint32 xfsSIUStatusCoinDispenserGuideLights;

	[ValueMap {"0", "1", "4", "8", "16", "32"} ,
	Values	{"xfsSIUGuideLightsNotAvailable", "xfsSIUGuideLightsOff",
			"xfsSIUGuideLightsSlowFlash", "xfsSIUGuideLightsMediumFlash",
			"xfsSIUGuideLightsQuickFlash", "xfsSIUGuideLightsContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the Receipt Printer unit guidelight. "),
	SNMPPropertyOffset(29) ]
	sint32 xfsSIUStatusReceiptPrinterGuideLights;

	[ValueMap {"0", "1", "4", "8", "16", "32"} ,
	Values	{"xfsSIUGuideLightsNotAvailable", "xfsSIUGuideLightsOff",
			"xfsSIUGuideLightsSlowFlash", "xfsSIUGuideLightsMediumFlash",
			"xfsSIUGuideLightsQuickFlash", "xfsSIUGuideLightsContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the Passbook Printer unit guidelight. "),
	SNMPPropertyOffset(30) ]
	sint32 xfsSIUStatusPassbookPrinterGuideLights;

	[ValueMap {"0", "1", "4", "8", "16", "32"} ,
	Values	{"xfsSIUGuideLightsNotAvailable", "xfsSIUGuideLightsOff",
			"xfsSIUGuideLightsSlowFlash", "xfsSIUGuideLightsMediumFlash",
			"xfsSIUGuideLightsQuickFlash", "xfsSIUGuideLightsContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the Env Depository unit guidelight. "),
	SNMPPropertyOffset(31) ]
	sint32 xfsSIUStatusEnvDepositoryGuideLights;

	[ValueMap {"0", "1", "4", "8", "16", "32"} ,
	Values	{"xfsSIUGuideLightsNotAvailable", "xfsSIUGuideLightsOff",
			"xfsSIUGuideLightsSlowFlash", "xfsSIUGuideLightsMediumFlash",
			"xfsSIUGuideLightsQuickFlash", "xfsSIUGuideLightsContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the Cheque unit guidelight. "),
	SNMPPropertyOffset(32) ]
	sint32 xfsSIUStatusChequeUnitGuidelights;

	[ValueMap {"0", "1", "4", "8", "16", "32"} ,
	Values	{"xfsSIUGuideLightsNotAvailable", "xfsSIUGuideLightsOff",
			"xfsSIUGuideLightsSlowFlash", "xfsSIUGuideLightsMediumFlash",
			"xfsSIUGuideLightsQuickFlash", "xfsSIUGuideLightsContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the Bill Acceptor unit guidelight. "),
	SNMPPropertyOffset(33) ]
	sint32 xfsSIUStatusBillAcceptorGuideLights;

	[ValueMap {"0", "1", "4", "8", "16", "32"} ,
	Values	{"xfsSIUGuideLightsNotAvailable", "xfsSIUGuideLightsOff",
			"xfsSIUGuideLightsSlowFlash", "xfsSIUGuideLightsMediumFlash",
			"xfsSIUGuideLightsQuickFlash", "xfsSIUGuideLightsContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the Env Dispenser unit guidelight. "),
	SNMPPropertyOffset(34) ]
	sint32 xfsSIUStatusEnvDispenserGuideLights;

	[ValueMap {"0", "1", "4", "8", "16", "32"} ,
	Values	{"xfsSIUGuideLightsNotAvailable", "xfsSIUGuideLightsOff",
			"xfsSIUGuideLightsSlowFlash", "xfsSIUGuideLightsMediumFlash",
			"xfsSIUGuideLightsQuickFlash", "xfsSIUGuideLightsContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the Document Printer unit guidelight. "),
	SNMPPropertyOffset(35) ]
	sint32 xfsSIUStatusDocumentPrinterGuideLights;

	[ValueMap {"0", "1", "4", "8", "16", "32"} ,
	Values	{"xfsSIUGuideLightsNotAvailable", "xfsSIUGuideLightsOff",
			"xfsSIUGuideLightsSlowFlash", "xfsSIUGuideLightsMediumFlash",
			"xfsSIUGuideLightsQuickFlash", "xfsSIUGuideLightsContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the Coin Acceptor unit guidelight. "),
	SNMPPropertyOffset(36) ]
	sint32 xfsSIUStatusCoinAcceptorGuideLights;

	[ValueMap {"0", "1", "4", "8", "16", "32"} ,
	Values	{"xfsSIUGuideLightsNotAvailable", "xfsSIUGuideLightsOff",
			"xfsSIUGuideLightsSlowFlash", "xfsSIUGuideLightsMediumFlash",
			"xfsSIUGuideLightsQuickFlash", "xfsSIUGuideLightsContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the Scanner unit guidelight. "),
	SNMPPropertyOffset(37) ]
	sint32 xfsSIUStatusScannerGuideLights;

	[ValueMap {"0", "1", "4", "8", "16", "32"} ,
	Values	{"xfsSIUGuideLightsNotAvailable", "xfsSIUGuideLightsOff",
			"xfsSIUGuideLightsSlowFlash", "xfsSIUGuideLightsMediumFlash",
			"xfsSIUGuideLightsQuickFlash", "xfsSIUGuideLightsContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the fourteenth Spare device guidelight. "),
	SNMPPropertyOffset(38) ]
	sint32 xfsSIUStatusSpare1GuideLights;

	[ValueMap {"0", "1", "4", "8", "16", "32"} ,
	Values	{"xfsSIUGuideLightsNotAvailable", "xfsSIUGuideLightsOff",
			"xfsSIUGuideLightsSlowFlash", "xfsSIUGuideLightsMediumFlash",
			"xfsSIUGuideLightsQuickFlash", "xfsSIUGuideLightsContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the fifteenth Spare device guidelight. "),
	SNMPPropertyOffset(39) ]
	sint32 xfsSIUStatusSpare2GuideLights;

	[ValueMap {"0", "1", "4", "8", "16", "32"} ,
	Values	{"xfsSIUGuideLightsNotAvailable", "xfsSIUGuideLightsOff",
			"xfsSIUGuideLightsSlowFlash", "xfsSIUGuideLightsMediumFlash",
			"xfsSIUGuideLightsQuickFlash", "xfsSIUGuideLightsContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the sixteenth Spare device guidelight. ") ,
	SNMPPropertyOffset(40) ]
	sint32 xfsSIUStatusSpare3GuideLights;

	[Read(TRUE), 
	Write(FALSE),
	Description	("This collection contains all guidance light information in the order received from XFS. It allows access to any potential vendor specific sensors."),
	SNMPPropertyOffset(41) ]
	sint32 xfsSIUAllGuidanceLightCollection[];	

	[implemented: ToSubClass, 
	Description(""), 
	SNMPMethodOffset(1)]
	void xfsSIUReset([Description(""), in]sint32 WaitTime);

};


//=========================================================================================
// xfsCDM
//=========================================================================================
[Description	("Status for Cash Dispenser Unit Device."),
 Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"),       
 SNMPGroup(12),
 SNMPConcreteClass(5)]
class xfsCDM : xfsDevice
{
	[ValueMap {"1", "2", "3", "5"} ,
	Values	{"xfsCDMDoorNotSupported", "xfsCDMDoorOpen",
			"xfsCDMDoorClosed", "xfsCDMDoorUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The state of the safe door. ") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsCDMStatusSafeDoor;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsCDMDispenserOK", "xfsCDMDispenserCUState",
			"xfsCDMDispenserCUStop", "xfsCDMDispenserCUUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The state of the dispenser. ") ,
	SNMPPropertyOffset(2) ]
	sint32 xfsCDMStatusDispenser;

	[ValueMap {"0", "1", "2", "3", "4", "5"} ,
	Values	{"xfsCDMISEmpty", "xfsCDMISNotEmpty",
			"xfsCDMISNotEmptyCust", "xfsCDMISNotEmptyUnk",
			"xfsCDMISUnknown", "xfsCDMISNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The state of the intermediate stacker. ") ,
	SNMPPropertyOffset(3) ]
	sint32 xfsCDMStatusIntermediateStacker;

	[BitMap{"0", "1", "2", "6", "7", "11", "12"} ,
	BitValues	{"xfsCDMPositionLeft", "xfsCDMPositionRight", "xfsCDMPositionCenter",
				"xfsCDMPositionTop", "xfsCDMPositionBottom", "xfsCDMPositionFront",
				"xfsCDMPositionRear"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Defines the output position as one of the following values") ,
	SNMPPropertyOffset(4) ]
	sint32 xfsCDMStatusPositionName[];
	
	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsCDMShtClosed", "xfsCDMShtOpen",
			"xfsCDMShtJammed", "xfsCDMShtUnknown",
			"xfsCDMShtNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The state of the shutter of the position described in xfsCDMStatusPositionName[]. ") ,
	SNMPPropertyOffset(5) ]
	sint32 xfsCDMStatusPositionShutter[];

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsCDMPSEmpty", "xfsCDMPSNotEmpty",
			"xfsCDMPSUnknown", "xfsCDMPSNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The state of the cash tray of the position described in xfsCDMStatusPositionName[]. ") ,
	SNMPPropertyOffset(6) ]
	sint32 xfsCDMStatusPositionStatus[];

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsCDMTPOK", "xfsCDMTPInop",
			"xfsCDMTPUnknown", "xfsCDMTPNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The state of the transport mechanism of the position described in xfsCDMStatusPositionName[].") ,
	SNMPPropertyOffset(7) ]
	sint32 xfsCDMStatusPositionTransport[];

	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsCDMTPStateEmpty", "xfsCDMTPStateNotEmpty",
			"xfsCDMTPStateNotEmptyCust", "xfsCDMTPStateNotEmptyUnknown",
			"xfsCDMTPStateNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The state of the items in the transport. ") ,
	SNMPPropertyOffset(8) ]
	sint32 xfsCDMStatusPositionTransportStatus[];

	[implemented: ToSubClass, 
	Description(""), 
	SNMPMethodOffset(1)]
	void xfsCDMReset([Description("The number of seconds to wait for successful negotiation of the device. If access to the device is not achieved within this time then the xfsCDMResetNegotiationTimeoutEvent will be generated."), in]sint32 WaitTime, [Description("The Number of the cash unit to which items found inside the CDM are to be moved. If the items are to be moved to an output position this value is 0 and the output position is defined by RetractToPosition."), in]sint32 Number, [Description("Specifies the output position from which to retract the bills"), in]sint32 RetractFromPosition, [Description("If the cash unit specified by Number is a retract cash unit then this field is the logical retract position inside the container into which the cash is to be retracted. Ignored otherwise"), in]sint32 RetractAreaIndex, [Description("The output position to which items are to be moved. If the Number is non-zero then this field will be ignored. "), in]sint32 RetractToPosition);
	
};
//=========================================================================================
// xfsCDMSubDevice
//=========================================================================================

//=========================================================================================
//  The key for CDM SubDevice should be the name of the managed service that the subdevice belongs to
//  (xfsSubDeviceManagedServiceName) and suffix with the chars type ID:
//  "cas" for Cassette; "rej" for Reject bin; "ret" for Retract bin and followed by a three digits unsigned ID
//  (xfsSubDeviceIndex).
//  Example: currencydispenser1cas001, currencydispenser1cas002, currencydispenser1rej001,
//=========================================================================================

[Description	("Sub device status for Cash Dispenser Unit Device."),
 Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"),       
 SNMPGroup(12),
 SNMPConcreteClass(6)]

class xfsCDMSubDevice : xfsSubDevice
{
	[Read(TRUE), 
	Write(FALSE),
	Description	("Index number of the media bin structure")]
	uint32 xfsCDMSubDeviceNumber;
	
	[Read(TRUE), 
	Write(FALSE),
	Description	("Cash unit identifier. .") ,
	SNMPPropertyOffset(1) ]
	string xfsCDMSubDeviceCULUnitID;

	[Read(TRUE), 
	Write(FALSE),
	Description	("A name which helps to identify the logical type of the cash unit.") ,
	SNMPPropertyOffset(2) ]
	string xfsCDMSubDeviceCUName;

	[ValueMap {"1", "2", "3", "4", "5", "6", "7", "8", "11", "12"} ,
	Values	{"xfsCDMTypeNA", "xfsCDMTypeRejectCassette",
			"xfsCDMTypeBillCassette", "xfsCDMTypeCoinCylinder",
			"xfsCDMTypeCoinDispenser", "xfsCDMTypeRetractCassette",
			"xfsCDMTypeCoupon", "xfsCDMTypeDocument",
			"xfsCDMTypeRepContainer", "xfsCDMTypeRecycling"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Type of the cash unit. ") ,
	SNMPPropertyOffset(3) ]
	sint32 xfsCDMSubDeviceCUType;

	[Read(TRUE), 
	Write(FALSE),
	Description	("A three character array storing the ISO format Currency ID. ") ,
	SNMPPropertyOffset(4) ]
	string xfsCDMSubDeviceCUCurrencyID;

	[Read(TRUE), 
	Write(FALSE),
	Description	("Currency exponent in ISO format ") ,
	SNMPPropertyOffset(5) ]
	string xfsCDMSubDeviceCUCurrencyExponent;
	
	[Read(TRUE), 
	Write(FALSE),
	Description	("Supplies the value of a single item in the cash unit.") ,
	SNMPPropertyOffset(6) ]
        sint32 xfsCDMSubDeviceCUValues;

	[Read(TRUE), 
	Write(FALSE),
	Description	("Initial number of items contained in the logical cash unit.") ,
	SNMPPropertyOffset(7) ]
        sint32 xfsCDMSubDeviceCULInitialCount;

	[Read(TRUE), 
	Write(FALSE),
	Description	("Initial number of items contained in the logical cash unit.") ,
	SNMPPropertyOffset(8) ]
        sint32 xfsCDMSubDeviceCULCount;

	[Read(TRUE), 
	Write(FALSE),
	Description	("Number of items from this logical cash unit that went to the "
	"reject cassette.") ,
	SNMPPropertyOffset(9) ]
        sint32 xfsCDMSubDeviceCULRejectCount;

	[Read(TRUE), 
	Write(FALSE),
	Description	("A minimum threshold value for the logical cash unit. Not applicable for "
	"Retract and Reject Cash Units.") ,
	SNMPPropertyOffset(10) ]
        sint32 xfsCDMSubDeviceCUMinimum;

	[Read(TRUE), 
	Write(FALSE),
	Description	("A maximum threshold value for the logical cash unit. It is only "
	"applicable for Reject Cash Units.") ,
	SNMPPropertyOffset(11) ]
        sint32 xfsCDMSubDeviceCULMaximum;

	[Read(TRUE), 
	Write(FALSE),
	Description	("This field does not apply to reject or retract cash units. "
	"TRUE  items cannot be dispensed from the cash unit."
	"FALSE  items can be dispensed from the cash unit.") ,
	SNMPPropertyOffset(12) ]
	sint32 xfsCDMSubDeviceCUAppLock;

	[ValueMap {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"} ,
	Values	{"xfsCDMCUStatusOK", "xfsCDMCUStatusFull",
			"xfsCDMCUStatusHigh", "xfsCDMCUStatusLow",
			"xfsCDMCUStatusEmpty", "xfsCDMCUStatusInop",
			"xfsCDMCUStatusMissing", "xfsCDMCUStatusNoval",
			"xfsCDMCUStatusNoref", "xfsCDMCUStatusManip"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The status of the logical cash unit. ") ,
	SNMPPropertyOffset(13) ]
	sint32 xfsCDMSubDeviceCULogicalStatus;

	[Read(TRUE), 
	Write(FALSE),
	Description	("Specifies whether or not threshold events can be generated based on "
				"hardware sensor in the device. "
				"TRUE  threshold events generated on hardware sensors."
				"FALSE - threshold events NOT generated on hardware sensors,") ,
	SNMPPropertyOffset(14) ]
	sint32 xfsCDMSubDeviceCUHardwareSensor;

	[Read(TRUE), 
	Write(FALSE),
    Description     ("Specifies the number of physical cassettes associated with this logical ID"
                         "The following physical unit properties arrays") ,
	SNMPPropertyOffset(15) ]
    sint32 xfsCDMSubDeviceNumberOfPhysicalCassettes;

    [Read(TRUE), 
	Write(FALSE),
	Description	("A name identifying the physical location of the cash unit within the CDM."
                         "This field can by used by CDMs which are compound with a CIM to identify "
                         "shared cash units.") ,
	SNMPPropertyOffset(16) ]
    string xfsCDMSubDeviceCUPhysicalPositionName[];

	[Read(TRUE), 
	Write(FALSE),
	Description	("Physical Cash unit identifier. ") ,
	SNMPPropertyOffset(17) ]
    string xfsCDMSubDeviceCUPUnitID[];

	[Read(TRUE), 
	Write(FALSE),
	Description	("Initial number of items contained in the physical cash unit") ,
	SNMPPropertyOffset(18) ]
    string xfsCDMSubDeviceCUPInitialCount[];
		
	[Read(TRUE), 
	Write(FALSE),
	Description	("Actual number of items contained in the physical cash unit.") ,
	SNMPPropertyOffset(19) ]
    string xfsCDMSubDeviceCUPCount[];

	[Read(TRUE), 
	Write(FALSE),
	Description	("number of items from this unit that are in the reject bin.") ,
	SNMPPropertyOffset(20) ]
    string xfsCDMSubDeviceCUPRejectCount[];

	[Read(TRUE), 
	Write(FALSE),
	Description	("Maximum number of items the unit can hold") ,
	SNMPPropertyOffset(21) ]
    string xfsCDMSubDeviceCUPMaximum[];

	[Read(TRUE), 
	Write(FALSE),
	Description	("Specifies whether threshold events are generated based on hardware sensors on the device or via counts.") ,
	SNMPPropertyOffset(22) ]
    string xfsCDMSubDeviceCUPHardwareSensor[];
		
	[ValueMap {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"} ,
	Values	{"xfsCDMCUStatusOK", "xfsCDMCUStatusFull",
			"xfsCDMCUStatusHigh", "xfsCDMCUStatusLow",
			"xfsCDMCUStatusEmpty", "xfsCDMCUStatusInop",
			"xfsCDMCUStatusMissing", "xfsCDMCUStatusNoval",
            "xfsCDMCUStatusNoref", "xfsCDMCUStatusManip"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Depreciated, use xfsCDMSubDeviceCUPhysicalStatus2. The status of the physical cash unit. ") ,
	SNMPPropertyOffset(23) ]
    string xfsCDMSubDeviceCUPhysicalStatus[];

	[ValueMap {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"} ,
	Values	{"xfsCDMCUStatusOK", "xfsCDMCUStatusFull",
			"xfsCDMCUStatusHigh", "xfsCDMCUStatusLow",
			"xfsCDMCUStatusEmpty", "xfsCDMCUStatusInop",
			"xfsCDMCUStatusMissing", "xfsCDMCUStatusNoval",
            "xfsCDMCUStatusNoref", "xfsCDMCUStatusManip"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The status of the physical cash unit. ") ,
	SNMPPropertyOffset(24) ]
    sint32 xfsCDMSubDeviceCUPhysicalStatus2[];

};


//=========================================================================================
// xfsPTR
//=========================================================================================
[Description	("Status for Printer Device."),
 Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"),       
 SNMPGroup(12),
 SNMPConcreteClass(7)]
class xfsPTR : xfsDevice
{
	[ValueMap {"0", "1", "2", "3", "4", "5", "6"} ,
	Values	{"xfsPTRMediaPresent", "xfsPTRMediaNotPresent",
			"xfsPTRMediaJammed", "xfsPTRMediaNotSupported",
			"xfsPTRMediaUnknown", "xfsPTRMediaEntering",
			"xfsPTRMediaRetracted"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the media state. ") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsPTRStatusMedia;

	[ValueMap {"0", "1", "2", "3", "4", "5"} ,
	Values	{"xfsPTRPaperFull", "xfsPTRPaperLow",
			"xfsPTRPaperOut", "xfsPTRPaperNotSupported",
			"xfsPTRPaperUnknown", "xfsPTRPaperJammed"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the upper paper supply. ") ,
	SNMPPropertyOffset(2) ]
    sint32 xfsPTRStatusPaperSupply[];

	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsPTRTonerFull", "xfsPTRTonerLow", "xfsPTRTonerOut",
			"xfsPTRTonerNotSupported", "xfsPTRTonerUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the toner supply state.") ,
	SNMPPropertyOffset(3) ]
	sint32 xfsPTRStatusToner;

	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsPTRInkFull", "xfsPTRInkLow", "xfsPTRInkOut",
			"xfsPTRInkNotSupported", "xfsPTRInkUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the ink supply state. ") ,
	SNMPPropertyOffset(4) ]
	sint32 xfsPTRStatusInk;

	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsPPTRLampOK", "xfsPPTRLampFading", "xfsPPTRLampInOp",
			"xfsPPTRLampNotSupported", "xfsPPTRLampUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the imaging lamp state.") ,
	SNMPPropertyOffset(5) ]
	sint32 xfsPTRStatusLamp;

	[Read(TRUE), 
	Write(FALSE),
	Description	("It contains the number of media on stacker.") ,
	SNMPPropertyOffset(6) ]
	sint32 xfsPTRStatusMediaOnStacker;

	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsPTRRetractBinOK", "xfsPTRRetractBinFull",
                        "xfsPTRRetractBinNotSupported", "xfsPTRRetractBinUnknown",
			"xfsPTRRetractBinHigh"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("A series of values describing the status of each retract bin supported by the PTR. The first entry holds the value for bin one, the second for bin two and so on") ,
	SNMPPropertyOffset(7) ]
	sint32 xfsPTRDeviceRetractBin[];

	[Read(TRUE), 
	Write(FALSE),
	Description	("A series of values describing the number of media retracted to each bin supported by the PTR. The first entry holds the value for bin one, the second for bin two and so on.") ,
	SNMPPropertyOffset(8) ]
	sint32 xfsPTRDeviceRetractCount[];

	[implemented: ToSubClass, 
	Description("This method will negotiate for access to the device (using, for example, the APTRA Resource Management component)  and, when available, will invoke the XFS Reset command. The xfsPTRResetCompleteEvent is generated on completion of the operation."), 
	SNMPMethodOffset(1)]
	void xfsPTRReset([Description("The number of seconds to wait for successful negotiation of the device. If access to the device is not achieved within this time then the xfsPTRResetNegotiationTimeoutEvent will be generated."), in]sint32 WaitTime, [Description("specifies the manner in which the media should be handled"), in]sint32 Action, [Description("Number of the retract bin the media is retracted to. This number has to be between one and thenumber of bins supported by this device. It is only relevant if Action equals xfsPTRRetract"), in]sint32 Bin);

};


//=========================================================================================
// xfsALM
//=========================================================================================
[Description	("Status for Alarm Device."),
 Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"),       
 SNMPGroup(12),
 SNMPConcreteClass(8)]
class xfsALM : xfsDevice
{
	[Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the Alarm "
	"TRUE  set."
	"FALSE  reset") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsALMAlarmSet;

	[implemented: ToSubClass, 
	Description("This method will negotiate for access to the device (using, for example, the APTRA Resource Management component)  and, when available, will invoke the XFS Reset command. The xfsALMResetCompleteEvent is generated on completion of the operation."), 
	SNMPMethodOffset(1)]
	void xfsALMReset([Description("The number of seconds to wait for successful negotiation of the device. If access to the device is not achieved within this time then the xfsALMResetNegotiationTimeoutEvent will be generated."), in]sint32 WaitTime);
};

//=========================================================================================
// xfsCAM
//=========================================================================================
[Description	("Status for Camera Device."),
 Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"),       
 SNMPGroup(12),
 SNMPConcreteClass(9)]
class xfsCAM : xfsDevice
{
	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsCAMMediaOk", "xfsCAMMediaHigh", "xfsCAMMediaFull",
			"xfsCAMMediaNotSupported", "xfsCAMMediaUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the recording media of the cameras. A number of indexes are defined in the CEN XFS specification") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsCAMMedia[];
	
	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsCAMCameraNotSupported", "xfsCAMCameraOk", "xfsCAMCameraInoperative",
			"xfsCAMCameraUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the the cameras. A number of cameras are defined in the CEN XFS specification. ") ,
	SNMPPropertyOffset(2) ]
	sint32 xfsCAMCameras[];	
	
	[Read(TRUE), 
	Write(FALSE),
	Description	("Reports the number of pictures stored on the recording media of the camera. A number of indexes are defined in the CEN XFS specification. ") ,
	SNMPPropertyOffset(3) ]
	sint32 xfsCAMPictures[];		

	[implemented: ToSubClass, 
	Description("This method will negotiate for access to the device (using, for example, the APTRA Resource Management component)  and, when available, will invoke the XFS Reset command. The xfsCAMResetCompleteEvent is generated on completion of the operation."), 
	SNMPMethodOffset(1)]
	void xfsCAMReset([Description("The number of seconds to wait for successful negotiation of the device. If access to the device is not achieved within this time then the xfsCAMResetNegotiationTimeoutEvent will be generated."), in]sint32 WaitTime);
};



//=========================================================================================
// xfsVDM
//=========================================================================================
[Description	("Status for VDM."),
 Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider")]
class xfsVDM : xfsDevice
{
	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsVDMEnterPending", "xfsVDMActive", "xfsVDMExitPending",
			"xfsVDMInactive"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("")]
	sint32 xfsVDMServiceStatus;
	
	[Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the name of an application that will negotiate for entry and exit of VDM mode. Its VDM-related status can be obtained from the equivalent array offset of xfsVDMApplicationStatus") ]
	string xfsVDMApplicationNames[];	
	
	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsVDMEnterPending", "xfsVDMActive", "xfsVDMExitPending",
			"xfsVDMInactive"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies whether the particular application is ready for the system to enter or exit Vendor Dependent Mode")]
	sint32 xfsVDMApplicationStatus[];
};

//=========================================================================================
// xfsVDMDeviceStatusChangeEvent
//=========================================================================================
[Description	("Status changes of managed services are reported as system events to the "
		"XFS Agent.")]
class xfsVDMDeviceStatusChangeEvent : xfsDeviceStatusChangeEvent
{
	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsVDMEnterPending", "xfsVDMActive", "xfsVDMExitPending",
			"xfsVDMInactive"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("")]
	sint32 xfsVDMServiceStatus;
	
	[Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the name of an application that will negotiate for entry and exit of VDM mode. Its VDM-related status can be obtained from the equivalent array offset of xfsVDMApplicationStatus") ]
	string xfsVDMApplicationNames[];	
	
	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsVDMEnterPending", "xfsVDMActive", "xfsVDMExitPending",
			"xfsVDMInactive"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies whether the particular application is ready for the system to enter or exit Vendor Dependent Mode")]
	sint32 xfsVDMApplicationStatus[];

};


//=========================================================================================
// xfsCHK
//=========================================================================================
[Description	("Status for Check Device."),
 Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"),       
 SNMPGroup(12),
 SNMPConcreteClass(10)]
class xfsCHK : xfsDevice
{
	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsCHKMediaNotSupported", "xfsCHKMediaNotPresent", "xfsCHKMediaRequired",
			"xfsCHKMediaPresent", "xfsCHKMediaJammed"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Describes the status of the media ") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsCHKMedia;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsCHKInkNotSupported", "xfsCHKInkFull", "xfsCHKInkLow",
			"xfsCHKInkOut"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Describes the status of the ink ") ,
	SNMPPropertyOffset(2) ]
	sint32 xfsCHKInk;	

	[implemented: ToSubClass, 
	Description("This method will negotiate for access to the device (using, for example, the APTRA Resource Management component)  and, when available, will invoke the XFS Reset command. The xfsCHKResetCompleteEvent is generated on completion of the operation."), 
	SNMPMethodOffset(1)]
	void xfsCHKReset([Description("The number of seconds to wait for successful negotiation of the device. If access to the device is not achieved within this time then the xfsCHKResetNegotiationTimeoutEvent will be generated."), in]sint32 WaitTime, [Description("specifies the manner in which the media should be handled"), in]sint32 Action);

};


//=========================================================================================
// xfsTTU
//=========================================================================================
[Description	("Status for Text Terminal Device."),
 Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"),       
 SNMPGroup(12),
 SNMPConcreteClass(11)]
class xfsTTU : xfsDevice
{
	[ValueMap {"0", "1", "2"} ,
	Values	{"xfsTTUKeyboardNotAvailable", "xfsTTUKeyboardOn", "xfsTTUKeyboardOff"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the keyboard") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsTTUKeyboard;
	
	[ValueMap {"0", "1", "2"} ,
	Values	{"xfsTTUKeyboardLockNotAvailable", "xfsTTUKeyboardLockOn", "xfsTTUKeyboardLockOff"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the keyboard lock") ,
	SNMPPropertyOffset(2) ]
	sint32 xfsTTUKeyLock;
	
	[ValueMap {"0", "1", "2", "4", "8", "128"} ,
	Values	{"xfsTTULEDNotAvailable", "xfsTTULEDOff", "xfsTTULEDSlowFlash",
			"xfsTTULEDMediumFlash", "xfsTTULEDQuickFlash", "xfsTTULEDContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the LEDs") ,
	SNMPPropertyOffset(3) ]
	sint32 xfsTTULEDs[];
	
	[Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the horizontal size of the display") ,
	SNMPPropertyOffset(4) ]
	sint32 xfsTTUDisplaySizeX;
	
	[Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the vertical size of the display") ,
	SNMPPropertyOffset(5) ]
	sint32 xfsTTUDisplaySizeY;

	[implemented: ToSubClass, 
	Description("This method will negotiate for access to the device (using, for example, the APTRA Resource Management component)  and, when available, will invoke the XFS Reset command. The xfsTTUResetCompleteEvent is generated on completion of the operation."), 
	SNMPMethodOffset(1)]
	void xfsTTUReset([Description("The number of seconds to wait for successful negotiation of the device. If access to the device is not achieved within this time then the xfsTTUResetNegotiationTimeoutEvent will be generated."), in]sint32 WaitTime);
};


//=========================================================================================
// xfsCIM
//=========================================================================================
[Description	("Status for Cash In Device."),
 Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"),       
 SNMPGroup(12),
 SNMPConcreteClass(12)]
class xfsCIM : xfsDevice
{
	[ValueMap {"1", "2", "3", "4"} ,
	Values	{"xfsCIMDoorNotSupported", "xfsCIMDoorOpen",
			"xfsCIMDoorClosed", "xfsCIMDoorUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The state of the safe door. ") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsCIMStatusSafeDoor;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsCIMDispenserOK", "xfsCIMDispenserCUState",
			"xfsCIMDispenserCUStop", "xfsCIMDispenserCUUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The state of the dispenser. ") ,
	SNMPPropertyOffset(2) ]
	sint32 xfsCIMAcceptor;

	[ValueMap {"0", "1", "2", "4", "5"} ,
	Values	{"xfsCIMISEmpty", "xfsCIMISNotEmpty",
			"xfsCIMISFull", 
			"xfsCIMISUnknown", "xfsCIMISNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The state of the intermediate stacker. ") ,
	SNMPPropertyOffset(3) ]
	sint32 xfsCIMStatusIntermediateStacker;
	
	[ValueMap {"0", "1", "2", "4"} ,
	Values	{"xfsCIMCustomerAccess", "xfsCIMNoCustomerAccess",
			"xfsCIMAccessUnknown", "xfsCIMNoItems"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("This field inform the application whether items on the intermediate stacker have been in customer access.") ,
	SNMPPropertyOffset(4) ]
	sint32 xfsCIMStackerItems;	
	
	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsCIMBNROk", "xfsCIMBNRInoperative",
			"xfsCIMBNRUnknown", "xfsCIMBNRNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Supplies the state of the banknote reader ") ,
	SNMPPropertyOffset(5) ]
	sint32 xfsCIMBankNoteReader;	

	[Read(TRUE), 
	Write(FALSE),
	Description	("This field specifies the status of the drop box. TRUE means that some items are stored in the drop box. FALSE indicates that the drop box is empty ") ,
	SNMPPropertyOffset(6) ]
	sint32 xfsCIMDropBox;		

	
	[ValueMap{"1", "2", "4", "8", "16", "32", "64", "128", "256", "512", "1024", "2048", "4096", "8192"} ,
	Values	{"xfsCIMPositionInLeft", "xfsCIMPositionInRight",
			"xfsCIMPositionInCenter", "xfsCIMPositionInTop",
			"xfsCIMPositionInBottom", "xfsCIMPositionInFront",
			"xfsCIMPositionInRear", "xfsCIMPositionOutLeft", "xfsCIMPositionOutRight",
			"xfsCIMPositionOutCenter", "xfsCIMPositionOutTop",
			"xfsCIMPositionOutBottom", "xfsCIMPositionOutFront",
			"xfsCIMPositionOutRear"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Defines the input or output position for this offset.") ,
	SNMPPropertyOffset(7) ]
	sint32 xfsCIMStatusPositionName[];
	
	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsCIMShtClosed", "xfsCIMShtOpen",
			"xfsCIMShtJammed", "xfsCIMShtUnknown",
			"xfsCIMShtNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The state of the shutter of the position described in xfsCIMStatusPositionName[]. ") ,
	SNMPPropertyOffset(8) ]
	sint32 xfsCIMStatusPositionShutter[];

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsCIMPSEmpty", "xfsCIMPSNotEmpty",
			"xfsCIMPSUnknown", "xfsCIMPSNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The state of the cash tray of the position described in xfsCIMStatusPositionName[]. ") ,
	SNMPPropertyOffset(9) ]
	sint32 xfsCIMStatusPositionStatus[];

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsCIMTPOK", "xfsCIMTPInop",
			"xfsCIMTPUnknown", "xfsCIMTPNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The state of the transport mechanism of the position described in xfsCIMStatusPositionName[].") ,
	SNMPPropertyOffset(10) ]
	sint32 xfsCIMStatusPositionTransport[];

	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsCIMTPStateEmpty", "xfsCIMTPStateNotEmpty",
			"xfsCIMTPStateNotEmptyCust", "xfsCIMTPStateNotEmptyUnknown",
			"xfsCIMTPStateNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The state of the items in the transport. ") ,
	SNMPPropertyOffset(11) ]
	sint32 xfsCIMStatusPositionTransportStatus[];

	[implemented: ToSubClass, 
	Description(""), 
	SNMPMethodOffset(1)]
	void xfsCIMReset([Description("The number of seconds to wait for successful negotiation of the device. If access to the device is not achieved within this time then the xfsCIMResetNegotiationTimeoutEvent will be generated."), in]sint32 WaitTime, [Description("The Number of the cash unit to which items found inside the CIM are to be moved. If the items are to be moved to an output position this value is 0 and the output position is defined by RetractToPosition."), in]sint32 Number, [Description("Specifies the output position from which to retract the bills."), in]sint32 RetractFromPosition, [Description("If the cash unit specified by Number is a retract cash unit then this field is the logical retract position inside the container into which the cash is to be retracted.Ignored otherwise"), in]sint32 RetractAreaIndex, [Description("The output position to which items are to be moved. If the Number is non-zero then this field will be ignored. "), in]sint32 RetractToPosition);

};



//=========================================================================================
// xfsCIMSubDevice
//=========================================================================================

//=========================================================================================
//  The key for CIM SubDevice should be the name of the managed service that the subdevice belongs to
//  (xfsSubDeviceManagedServiceName) and suffix with the chars type ID:
//  "cas" for Cassette; "rej" for Reject bin; "ret" for Retract bin and followed by a three digits unsigned ID
//  (xfsSubDeviceIndex).
//=========================================================================================

[Description	("Sub device status for Cash Dispenser Unit Device."),
 Dynamic:ToInstance, 
 Provider("NCR_WMICoreProvider"),       
 SNMPGroup(12),
 SNMPConcreteClass(13)]
class xfsCIMSubDevice : xfsSubDevice
{
	[Read(TRUE), 
	Write(FALSE),
	Description	("Index number of the media bin structure")]
	uint32 xfsCIMSubDeviceNumber;
	
	[Read(TRUE), 
	Write(FALSE),
	Description	("Cash unit identifier.") ,
	SNMPPropertyOffset(1) ]
	string xfsCIMSubDeviceCULUnitID;

	[BitMap{"0", "1", "2", "3", "4"} ,
	BitValues	{"xfsCIMItemTypeAll", "xfsCIMItemTypeUnfit", "xfsCIMItemTypeIndividual",
				"xfsCIMItemTypeLevel2", "xfsCIMItemTypeLevel3"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the type of items the Cash Unit takes ") ,
	SNMPPropertyOffset(2) ]
	sint32 xfsCIMItemType;	
	
	[ValueMap {"1", "2", "3", "4","5","6"} ,
	Values	{"xfsCIMTypeRecycling", "xfsCIMTypeCashIn",
			"xfsCIMTypeRepContainer", "xfsCIMTypeRetractCassette","xfsCIMTypeRejectCassette","xfsCIMTypeCDMSpecific"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Type of the cash unit. ") ,
	SNMPPropertyOffset(3) ]
	sint32 xfsCIMSubDeviceCUType;

	[Read(TRUE), 
	Write(FALSE),
	Description	("A three character array storing the ISO format Currency ID. ") ,
	SNMPPropertyOffset(4) ]
	string xfsCIMSubDeviceCUCurrencyID;

	[Read(TRUE), 
	Write(FALSE),
	Description	("Currency exponent in ISO format ") ,
	SNMPPropertyOffset(5) ]
	string xfsCIMSubDeviceCUCurrencyExponent;
	
	[Read(TRUE), 
	Write(FALSE),
	Description	("Supplies the value of a single item in the cash unit.") ,
	SNMPPropertyOffset(6) ]
    sint32 xfsCIMSubDeviceCUValues;

	[Read(TRUE), 
	Write(FALSE),
	Description	("Count of items that have entered the cash unit") ,
	SNMPPropertyOffset(7) ]
    sint32 xfsCIMSubDeviceCULCashInCount;

	[Read(TRUE), 
	Write(FALSE),
	Description	("Initial number of items contained in the logical cash unit.") ,
	SNMPPropertyOffset(8) ]
    sint32 xfsCIMSubDeviceCULCount;
		
	[Read(TRUE), 
	Write(FALSE),
	Description	("Identification of note type.") ,
	SNMPPropertyOffset(9) ]
    string xfsCIMSubDeviceNoteID[];		

	[Read(TRUE), 
	Write(FALSE),
	Description	("Actual count of items") ,
	SNMPPropertyOffset(10) ]
    sint32 xfsCIMSubDeviceNoteCount[];	

	[Read(TRUE), 
	Write(FALSE),
	Description	("A maximum threshold value") ,
	SNMPPropertyOffset(11) ]
    sint32 xfsCIMSubDeviceCULMaximum;

	[Read(TRUE), 
	Write(FALSE),
	Description	("This field does not apply to reject or retract cash units. "
	"TRUE  items cannot be dispensed from the cash unit."
	"FALSE  items can be dispensed from the cash unit.") ,
	SNMPPropertyOffset(12) ]
	sint32 xfsCIMSubDeviceCUAppLock;

	[ValueMap {"0", "1", "2", "4", "5", "6", "7", "8", "9"} ,
	Values	{"xfsCIMCUStatusOK", "xfsCIMCUStatusFull",
			"xfsCIMCUStatusHigh", "xfsCIMCUStatusEmpty",
			"xfsCIMCUStatusInop",
			"xfsCIMCUStatusMissing", "xfsCIMCUStatusNoval",
			"xfsCIMCUStatusNoref", "xfsCIMCUStatusManip"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The status of the logical cash unit. ") ,
	SNMPPropertyOffset(13) ]
	sint32 xfsCIMSubDeviceCULogicalStatus;

	[Read(TRUE), 
	Write(FALSE),
	Description	("Specifies whether or not threshold events can be generated based on "
				"hardware sensor in the device. "
				"TRUE  threshold events generated on hardware sensors."
				"FALSE - threshold events NOT generated on hardware sensors,") ,
	SNMPPropertyOffset(14) ]
	sint32 xfsCIMSubDeviceCUHardwareSensor;

	[Read(TRUE), 
	Write(FALSE),
    Description     ("Specifies the number of physical cassettes associated with this logical ID"
                         "The following physical unit properties arrays") ,
	SNMPPropertyOffset(15) ]
    sint32 xfsCIMSubDeviceNumberOfPhysicalCassettes;

    [Read(TRUE), 
	Write(FALSE),
	Description	("A name identifying the physical location of the cash unit within the CIM."
                         "This field can by used by CIMs which are compound with a CDM to identify "
                         "shared cash units.") ,
	SNMPPropertyOffset(16) ]
    string xfsCIMSubDeviceCUPhysicalPositionName[];

	[Read(TRUE), 
	Write(FALSE),
	Description	("Physical Cash unit identifier. ") ,
	SNMPPropertyOffset(17) ]
    string xfsCIMSubDeviceCUPUnitID[];

	[Read(TRUE), 
	Write(FALSE),
	Description	("Initial number of items contained in the physical cash unit") ,
	SNMPPropertyOffset(18) ]
    string xfsCIMSubDeviceCUPCashInCount[];
		
	[Read(TRUE), 
	Write(FALSE),
	Description	("Actual number of items contained in the physical cash unit.") ,
	SNMPPropertyOffset(19) ]
    string xfsCIMSubDeviceCUPCount[];


	[Read(TRUE), 
	Write(FALSE),
	Description	("Maximum number of items the unit can hold") ,
	SNMPPropertyOffset(20) ]
    string xfsCIMSubDeviceCUPMaximum[];

	[Read(TRUE), 
	Write(FALSE),
	Description	("Specifies whether threshold events are generated based on hardware sensors on the device or via counts.") ,
	SNMPPropertyOffset(21) ]
    string xfsCIMSubDeviceCUPHardwareSensor[];
		
	[ValueMap {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"} ,
	Values	{"xfsCIMCUStatusOK", "xfsCIMCUStatusFull",
			"xfsCIMCUStatusHigh", "xfsCIMCUStatusLow",
			"xfsCIMCUStatusEmpty", "xfsCIMCUStatusInop",
			"xfsCIMCUStatusMissing", "xfsCIMCUStatusNoval",
            "xfsCIMCUStatusNoref", "xfsCIMCUStatusManip"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Depreciated, use xfsCIMSubDeviceCUPhysicalStatus2. The status of the physical cash unit. ") ,
	SNMPPropertyOffset(22) ]
    string xfsCIMSubDeviceCUPhysicalStatus[];

	[ValueMap {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"} ,
	Values	{"xfsCIMCUStatusOK", "xfsCIMCUStatusFull",
			"xfsCIMCUStatusHigh", "xfsCIMCUStatusLow",
			"xfsCIMCUStatusEmpty", "xfsCIMCUStatusInop",
			"xfsCIMCUStatusMissing", "xfsCIMCUStatusNoval",
            "xfsCIMCUStatusNoref", "xfsCIMCUStatusManip"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The status of the physical cash unit. ") ,
	SNMPPropertyOffset(23) ]
	sint32 xfsCIMSubDeviceCUPhysicalStatus2[];	
};





//=========================================================================================
// xfsIDCDeviceStatusChangeEvent
//=========================================================================================
[Description	("Status changes of managed services are reported as system events to the "
		"XFS Agent."),       
 SNMPGroup(12),
 SNMPTrapClass(3)]
class xfsIDCDeviceStatusChangeEvent : xfsDeviceStatusChangeEvent
{
	[ValueMap {"1", "2", "3", "4", "5", "6", "7"} ,
	Values {"xfsIDCMediaPresent", "xfsIDCMediaNotPresent", "xfsIDCMediaJammed",
		"xfsIDCMediaNotSupported", "xfsIDCMediaUnknown", "xfsIDCMediaEntering",
		"xfsIDCMediaLatched"} ,
	read: ToSubClass,
	Description	("It contains the media state. It is a numeric type field. ") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsIDCStatusMedia;

	[ValueMap {"1", "2", "3", "4"} ,
	Values {"xfsIDCRetainBinOK", "xfsIDCRetainBinNotSupported", "xfsIDCRetainBinFull",
		"xfsIDCRetainBinHigh"} ,
	read: ToSubClass,
	Description	("It contains the state of the ID card unit retain bin.") ,
	SNMPPropertyOffset(2) ]
	sint32 xfsIDCStatusRetainBin;

	[ValueMap {"1", "2", "3"} ,
	Values {"xfsIDCSecurityNotSupported", "xfsIDCSecurityNotReady",
		"xfsIDCSecurityOpen"} ,
	read: ToSubClass,
	Description	("It contains the state of the security unit. ") ,
	SNMPPropertyOffset(3) ]
	sint32 xfsIDCStatusSecurity;

	[Description	("It contains the number of cards retained. It is a numeric type "
			"field. The number of cards retained;"
			"applicable only to motor driven ID card units for non-motorized "
			"card units this value is 0."),
	read: ToSubClass ,
	SNMPPropertyOffset(4) ]
	sint32 xfsIDCStatusCardRetained;

	[ValueMap {"0", "1", "2", "3", "4", "5", "6", "7"} ,
	Values {"xfsIDCChipOnline", "xfsIDCChipPoweredOff", "xfsIDCChipBusy",
		"xfsIDCChipNoDevice", "xfsIDCChipHwError", "xfsIDCChipNoCard",
		"xfsIDCChipNotSupported", "xfsIDCChipUnknown"} ,
	read: ToSubClass,
	Description	("It contains the state of the chip controlled by this service. ") ,
	SNMPPropertyOffset(5) ]
	sint32 xfsIDCStatusChipPower;
};


[Description	("Indicates that the device could not be negotiated for within the time specified in the Reset operation"),
 SNMPGroup(12),
 SNMPTrapClass(4)]
class xfsIDCResetNegotiationTimeoutEvent:  xfsEvent
{
};



[Description	("Reports the outcome of the Reset operation."),       
 SNMPGroup(12),
 SNMPTrapClass(5)]
class xfsIDCResetCompleteEvent: xfsIDCDeviceStatusChangeEvent
{
	[Description	("The XFS response to the Reset command. ") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsResponse;
};




//=========================================================================================
// xfsDEPDeviceStatusChangeEvent
//=========================================================================================
[Description	("Status changes of managed services are reported as system events to the "
		"XFS Agent."),       
 SNMPGroup(12),
 SNMPTrapClass(6)]
class xfsDEPDeviceStatusChangeEvent : xfsDeviceStatusChangeEvent
{
	[ValueMap {"0", "1", "2", "3", "4", "5", "6"} ,
	Values	{"xfsDEPContainerOK", "xfsDEPContainerHigh", "xfsDEPContainerFull",
			"xfsDEPContainerInop", "xfsDEPContainerMissing", "xfsDEPContainerUnknown",
			"xfsDEPContainerNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the depository container state. ") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsDEPStatusContainer;

	[ValueMap {"0", "3", "5", "6"} ,
	Values	{"xfsDEPTransportOK", "xfsDEPTransportInop", "xfsDEPTransportUnknown",
			"xfsDEPTransportNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the depository transport mechanism. ") ,
	SNMPPropertyOffset(2) ]
	sint32 xfsDEPStatusTransport;

	[ValueMap {"0", "1", "2", "3", "4", "5", "6", "7"} ,
	Values	{"xfsDEPEnvSupplyOK", "xfsDEPEnvSupplyLow", "xfsDEPEnvSupplyEmpty",
			"xfsDEPEnvSupplyInop", "xfsDEPEnvSupplyMissing", "xfsDEPEnvSupplyUnknown",
			"xfsDEPEnvSupplyNotSupported", "xfsDEPEnvSupplyUnlocked"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the envelope supply unit. ") ,
	SNMPPropertyOffset(3) ]
	sint32 xfsDEPStatusEnvSupply;

	[ValueMap {"0", "3", "5", "6"} ,
	Values	{"xfsDEPEnvDispenserOK", "xfsDEPEnvDispenserInop", "xfsDEPEnvDispenserUnknown",
			"xfsDEPEnvDispenserNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the envelope dispenser. ") ,
	SNMPPropertyOffset(3) ]
	sint32 xfsDEPStatusEnvDispenser;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsDEPPrinterOK", "xfsDEPPrinterInop", "xfsDEPPrinterUnknown",
			"xfsDEPPrinterNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the printer.") ,
	SNMPPropertyOffset(4) ]
	sint32 xfsDEPStatusPrinter;

	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsDEPTonerFull", "xfsDEPTonerLow", "xfsDEPTonerOut", "xfsDEPTonerUnknown",
			"xfsDEPTonerNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the toner (or ink) of the printer. ") ,
	SNMPPropertyOffset(5) ]
	sint32 xfsDEPStatusToner;

	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsDEPShutterClosed", "xfsDEPShutterOpen", "xfsDEPShutterJammed",
			"xfsDEPShutterUnknown", "xfsDEPShutterNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the shutter or door. ") ,
	SNMPPropertyOffset(6) ]
	sint32 xfsDEPStatusShutter;

	[Read(TRUE), 
	Write(FALSE),
	Description	("It contains the number of envelopes or bags in the deposit container. It "
				"is a numeric type field.") ,
	SNMPPropertyOffset(7) ]
	sint32 xfsDEPNumberOfDeposits;

};

[Description	("Indicates that the device could not be negotiated for within the time specified in the Reset operation"),       
 SNMPGroup(12),
 SNMPTrapClass(7)]
class xfsDEPResetNegotiationTimeoutEvent:  xfsEvent
{
};

[Description	("Reports the outcome of the Reset operation."),       
 SNMPGroup(12),
 SNMPTrapClass(8)]
class xfsDEPResetCompleteEvent: xfsDEPDeviceStatusChangeEvent
{
	[Description	("The XFS response to the Reset command. ") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsResponse;
};


//=========================================================================================
// xfsPINDeviceStatusChangeEvent
//=========================================================================================
[Description	("Status changes of managed services are reported as system events to the "
		"XFS Agent."),       
 SNMPGroup(12),
 SNMPTrapClass(9)]
class xfsPINDeviceStatusChangeEvent : xfsDeviceStatusChangeEvent
{
	[ValueMap {"0", "1", "2", "3", "4", "5"} ,
	Values	{"xfsPINEncReady", "xfsPINEncNotReady", "xfsPINEncNotInitialized",
			"xfsPINEncBusy", "xfsPINEncUndefined", "xfsPINEncInitialized"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the encryptor module state. ") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsPINStatusEncStat;

	[ValueMap {"0", "1", "2", "4"} ,
	Values	{"xfsPINCertNotSupp", "xfsPINCertPrimary", "xfsPINCertSeconday",
			"xfsPINCertNotReady"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the certificate state. ") ,
	SNMPPropertyOffset(2) ]
	sint32 xfsPINStatusCertificateState;
};




[Description	("Indicates that the device could not be negotiated for within the time specified in the Reset operation"),       
 SNMPGroup(12),
 SNMPTrapClass(10)]
class xfsPINResetNegotiationTimeoutEvent:  xfsEvent
{
};

[Description	("Reports the outcome of the Reset operation."),       
 SNMPGroup(12),
 SNMPTrapClass(11)]
class xfsPINResetCompleteEvent: xfsPINDeviceStatusChangeEvent
{
	[Description	("The XFS response to the Reset command. ") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsResponse;
};



//=========================================================================================
// xfsSIUDeviceStatusChangeEvent
//=========================================================================================
[Description	("Status changes of managed services are reported as system events to the "
		"XFS Agent."),       
 SNMPGroup(12),
 SNMPTrapClass(12)]
class xfsSIUDeviceStatusChangeEvent : xfsDeviceStatusChangeEvent
{
	[ValueMap {"0", "1", "2", "4"} ,
	Values	{"xfsSIUOperatorSwitchNotAvailable", "xfsSIUOperatorSwitchRun",
			"xfsSIUOperatorSwitchMaintenance", "xfsSIUOperatorSwitchSupervisor"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the operator switch sensor.") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsSIUStatusOperatorSwitchSensors;

	[ValueMap {"0", "1", "2"} ,
	Values	{"xfsSIUSensorNotAvailable", "xfsSIUSensorOff", "xfsSIUSensorOn"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the tamper sensor. ") ,
	SNMPPropertyOffset(2) ]
	sint32 xfsSIUStatusTamperSensors;

	[ValueMap {"0", "1", "2"} ,
	Values	{"xfsSIUSensorNotAvailable", "xfsSIUSensorOff", "xfsSIUSensorOn"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the internal tamper sensor.") ,
	SNMPPropertyOffset(3) ]
	sint32 xfsSIUStatusIntTamperSensors;

	[ValueMap {"0", "1", "2"} ,
	Values	{"xfsSIUSensorNotAvailable", "xfsSIUSensorOff", "xfsSIUSensorOn"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the seismic sensor. ") ,
	SNMPPropertyOffset(4) ]
	sint32 xfsSIUSeismicSensors;

	[ValueMap {"0", "1", "2"} ,
	Values	{"xfsSIUSensorNotAvailable", "xfsSIUSensorOff", "xfsSIUSensorOn"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the heat sensor. ") ,
	SNMPPropertyOffset(5) ]
	sint32 xfsSIUStatusHeatSensors;

	[ValueMap {"0", "1", "2"} ,
	Values	{"xfsSIUProximityNotAvailable", "xfsSIUProximityPresent",
			"xfsSIUProximityNotPresent"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the proximity sensor. ") ,
	SNMPPropertyOffset(6) ]
	sint32 xfsSIUStatusProximitySensors;

	[ValueMap {"0", "1", "2", "4", "8", "16"} ,
	Values	{"xfsSIUAmbLightNotAvailable", "xfsSIUAmbLightVeryDark", "xfsSIUAmbLightDark",
			"xfsSIUAmbLightMediumLight", "xfsSIUAmbLightLight", "xfsSIUAmbLightVeryLight"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the ambient light sensor. ") ,
	SNMPPropertyOffset(7) ]
	sint32 xfsSIUStatusAmbLightSensors;

	[ValueMap {"0", "1", "2"} ,
	Values	{"xfsSIUEnhancedAudioNotAvailable", "xfsSIUEnhancedAudioPresent",
			"xfsSIUEnhancedAudioNotPresent"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the headphone connected to the Audio Jack. ") ,
	SNMPPropertyOffset(8) ]
	sint32 xfsSIUStatusEnhancedAudioSensors;

	[Read(TRUE), 
	Write(FALSE),
	Description	("This collection contains all sensor information in the order received from XFS. It allows access to any potential vendor specific sensors.") ,
	SNMPPropertyOffset(9) ]
	sint32 xfsSIUAllSensorsCollection[];
	
	[ValueMap {"0", "1", "2", "4", "8"} ,
	Values	{"xfsSIUDoorsNotAvailable", "xfsSIUDoorsClosed", "xfsSIUDoorsOpen",
			"xfsSIUDoorsLocked", "xfsSIUDoorsBolted"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the cabinet doors.") ,
	SNMPPropertyOffset(10) ]
	sint32 xfsSIUStatusCabinetDoors;

	[ValueMap {"0", "1", "2", "4", "8"} ,
	Values	{"xfsSIUDoorsNotAvailable", "xfsSIUDoorsClosed", "xfsSIUDoorsOpen",
			"xfsSIUDoorsLocked", "xfsSIUDoorsBolted"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the safe doors. ") ,
	SNMPPropertyOffset(11) ]
	sint32 xfsSIUStatusSafeDoors;

	[ValueMap {"0", "1", "2", "4", "16", "32", "64", "128"} ,
	Values	{"xfsSIUVandalShieldNotAvailable", "xfsSIUVandalShieldClosed",
			"xfsSIUVandalShieldOpen", "xfsSIUVandalShieldLocked",
			"xfsSIUVandalShieldService", "xfsSIUVandalShieldKeyboard",
			"xfsSIUVandalShieldAjar", "xfsSIUVandalShieldJammed"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the vandal shield. ") ,
	SNMPPropertyOffset(12) ]
	sint32 xfsSIUStatusVandalShieldDoors;
	
	[Read(TRUE), 
	Write(FALSE),
	Description	("This collection contains all door information in the order received from XFS. It allows access to any potential vendor specific sensors.") ,
	SNMPPropertyOffset(13) ]
	sint32 xfsSIUAllDoorsCollection[];	

	[ValueMap {"0", "1", "2"} ,
	Values	{"xfsSIUIndicatorsNotAvailable", "xfsSIUIndicatorsClosed",
			"xfsSIUIndicatorsOpen"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the open/closed indicator. ") ,
	SNMPPropertyOffset(14) ]
	sint32 xfsSIUStatusOpenCloseIndicators;

	[ValueMap {"0", "1", "2"} ,
	Values	{"xfsSIUIndicatorsNotAvailable", "xfsSIUIndicarorsOff",
			"xfsSIUIndicatorsOn"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the fascia light. ") ,
	SNMPPropertyOffset(15) ]
	sint32 xfsSIUStatusFasciaLightIndicators;

	[BitMap{"0", "1", "2", "3", "4", "5", "7"} ,
	BitValues	{"WFS_SIU_OFF", "WFS_SIU_KEYPRESS", "WFS_SIU_NOT_EXCLAMATION",
				"WFS_SIU_NOT_WARNING", "WFS_SIU_NOT_ERROR", "WFS_SIU_NOT_CRITICAL",
				"WFS_SIU_NOT_CONTINUOUS"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the audio indicator. It is a bit-mask numeric "
				"type field.") ,
	SNMPPropertyOffset(16) ]
	sint32 xfsSIUStatusAudioIndicators;

	[ValueMap {"0", "1", "2"} ,
	Values	{"xfsSIUIndicatorsNotAvailable", "xfsSIUIndicarorsOff",
			"xfsSIUIndicatorsOn"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the internal heating. ") ,
	SNMPPropertyOffset(17) ]
	sint32 xfsSIUStatusHeatingIndicators;
	
	[Read(TRUE), 
	Write(FALSE),
	Description	("This collection contains all indicator information in the order received from XFS. It allows access to any potential vendor specific sensors.") ,
	SNMPPropertyOffset(18) ]
	sint32 xfsSIUAllIndicatorsCollection[];	

	[MaxValue(1000), MinValue(0),
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the audio volume control. ") ,
	SNMPPropertyOffset(19) ]
	sint32 xfsSIUStatusVolumeAux;

	[BitMap{"0", "1", "2", "3", "4"} ,
	BitValues	{"WFS_SIU_AVAILABLE", "WFS_SIU_LOW", "WFS_SIU_ENGAGED",
				"WFS_SIU_POWERING", "WFS_SIU_RECOVERED"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the Uninterruptable Power Supply device. ") ,
	SNMPPropertyOffset(20) ]
	sint32 xfsSIUStatusUPSAux;

	[BitMap{"0", "1", "2", "3", "4", "5"} ,
	BitValues	{"WFS_SIU_GREEN_LED_ON", "WFS_SIU_GREEN_LED_OFF", "WFS_SIU_AMBER_LED_ON",
				"WFS_SIU_AMBER_LED_OFF", "WFS_SIU_RED_LED_ON", "WFS_SIU_RED_LED_OFF"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the Remote Status Monitor device. ") ,
	SNMPPropertyOffset(21) ]
	sint32 xfsSIUStatusRemoteStatusMonitorAux;

	[ValueMap {"0", "1", "2"} ,
	Values	{"xfsSIUAuxiliaryNotAvailable", "xfsSIUAuxiliaryOff",
			"xfsSIUAuxiliaryOn"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the Audible Alarm device. ") ,
	SNMPPropertyOffset(22) ]
	sint32 xfsSIUStatusAudibleAlarmAux;

	[ValueMap {"0", "1", "2", "3", "8", "16", "32"} ,
	Values	{"xfsSIUEnhancedAudioControlAuxNotAvailable",
			"xfsSIUEnhancedAudioControlAuxPublicAudioManaual",
			"xfsSIUEnhancedAudioControlAuxPublicAudioAuto",
			"xfsSIUEnhancedAudioControlAuxPublicAudioSemiAuto",
			"xfsSIUEnhancedAudioControlAuxPrivateAudioManual",
			"xfsSIUEnhancedAudioControlAuxPrivateAudioAuto",
			"xfsSIUEnhancedAudioControlAuxPrivateAudioSemiAuto"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the Audio Jack Controller. ") ,
	SNMPPropertyOffset(23) ]
	sint32 xfsSIUStatusEnhancedAudioControlAux;
	
	[Read(TRUE), 
	Write(FALSE),
	Description	("This collection contains all auxiliary information in the order received from XFS. It allows access to any potential vendor specific sensors.") ,
	SNMPPropertyOffset(24) ]
	sint32 xfsSIUAllAuxiliariesCollection[];

	[ValueMap {"0", "1", "4", "8", "16", "32"} ,
	Values	{"xfsSIUGuideLightsNotAvailable", "xfsSIUGuideLightsOff",
			"xfsSIUGuideLightsSlowFlash", "xfsSIUGuideLightsMediumFlash",
			"xfsSIUGuideLightsQuickFlash", "xfsSIUGuideLightsContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the Card Unit (IDC) guidelight. ") ,
	SNMPPropertyOffset(25) ]
	sint32 xfsSIUStatusCardUnitGuideLights;

	[ValueMap {"0", "1", "4", "8", "16", "32"} ,
	Values	{"xfsSIUGuideLightsNotAvailable", "xfsSIUGuideLightsOff",
			"xfsSIUGuideLightsSlowFlash", "xfsSIUGuideLightsMediumFlash",
			"xfsSIUGuideLightsQuickFlash", "xfsSIUGuideLightsContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the PIN pad unit guidelight. ") ,
	SNMPPropertyOffset(26) ]
	sint32 xfsSIUStatusPinpadGuideLights;

	[ValueMap {"0", "1", "4", "8", "16", "32"} ,
	Values	{"xfsSIUGuideLightsNotAvailable", "xfsSIUGuideLightsOff",
			"xfsSIUGuideLightsSlowFlash", "xfsSIUGuideLightsMediumFlash",
			"xfsSIUGuideLightsQuickFlash", "xfsSIUGuideLightsContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the Note Dispenser unit guidelight. ") ,
	SNMPPropertyOffset(27) ]
	sint32 xfsSIUStatusNotesDispenserGuideLights;

	[ValueMap {"0", "1", "4", "8", "16", "32"} ,
	Values	{"xfsSIUGuideLightsNotAvailable", "xfsSIUGuideLightsOff",
			"xfsSIUGuideLightsSlowFlash", "xfsSIUGuideLightsMediumFlash",
			"xfsSIUGuideLightsQuickFlash", "xfsSIUGuideLightsContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the Coin Dispenser unit guidelight. ") ,
	SNMPPropertyOffset(28) ]
	sint32 xfsSIUStatusCoinDispenserGuideLights;

	[ValueMap {"0", "1", "4", "8", "16", "32"} ,
	Values	{"xfsSIUGuideLightsNotAvailable", "xfsSIUGuideLightsOff",
			"xfsSIUGuideLightsSlowFlash", "xfsSIUGuideLightsMediumFlash",
			"xfsSIUGuideLightsQuickFlash", "xfsSIUGuideLightsContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the Receipt Printer unit guidelight. ") ,
	SNMPPropertyOffset(29) ]
	sint32 xfsSIUStatusReceiptPrinterGuideLights;

	[ValueMap {"0", "1", "4", "8", "16", "32"} ,
	Values	{"xfsSIUGuideLightsNotAvailable", "xfsSIUGuideLightsOff",
			"xfsSIUGuideLightsSlowFlash", "xfsSIUGuideLightsMediumFlash",
			"xfsSIUGuideLightsQuickFlash", "xfsSIUGuideLightsContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the Passbook Printer unit guidelight. ") ,
	SNMPPropertyOffset(30) ]
	sint32 xfsSIUStatusPassbookPrinterGuideLights;

	[ValueMap {"0", "1", "4", "8", "16", "32"} ,
	Values	{"xfsSIUGuideLightsNotAvailable", "xfsSIUGuideLightsOff",
			"xfsSIUGuideLightsSlowFlash", "xfsSIUGuideLightsMediumFlash",
			"xfsSIUGuideLightsQuickFlash", "xfsSIUGuideLightsContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the Env Depository unit guidelight. ") ,
	SNMPPropertyOffset(31) ]
	sint32 xfsSIUStatusEnvDepositoryGuideLights;

	[ValueMap {"0", "1", "4", "8", "16", "32"} ,
	Values	{"xfsSIUGuideLightsNotAvailable", "xfsSIUGuideLightsOff",
			"xfsSIUGuideLightsSlowFlash", "xfsSIUGuideLightsMediumFlash",
			"xfsSIUGuideLightsQuickFlash", "xfsSIUGuideLightsContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the Cheque unit guidelight. ") ,
	SNMPPropertyOffset(32) ]
	sint32 xfsSIUStatusChequeUnitGuidelights;

	[ValueMap {"0", "1", "4", "8", "16", "32"} ,
	Values	{"xfsSIUGuideLightsNotAvailable", "xfsSIUGuideLightsOff",
			"xfsSIUGuideLightsSlowFlash", "xfsSIUGuideLightsMediumFlash",
			"xfsSIUGuideLightsQuickFlash", "xfsSIUGuideLightsContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the Bill Acceptor unit guidelight. ") ,
	SNMPPropertyOffset(33) ]
	sint32 xfsSIUStatusBillAcceptorGuideLights;

	[ValueMap {"0", "1", "4", "8", "16", "32"} ,
	Values	{"xfsSIUGuideLightsNotAvailable", "xfsSIUGuideLightsOff",
			"xfsSIUGuideLightsSlowFlash", "xfsSIUGuideLightsMediumFlash",
			"xfsSIUGuideLightsQuickFlash", "xfsSIUGuideLightsContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the Env Dispenser unit guidelight. ") ,
	SNMPPropertyOffset(34) ]
	sint32 xfsSIUStatusEnvDispenserGuideLights;

	[ValueMap {"0", "1", "4", "8", "16", "32"} ,
	Values	{"xfsSIUGuideLightsNotAvailable", "xfsSIUGuideLightsOff",
			"xfsSIUGuideLightsSlowFlash", "xfsSIUGuideLightsMediumFlash",
			"xfsSIUGuideLightsQuickFlash", "xfsSIUGuideLightsContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the Document Printer unit guidelight. ") ,
	SNMPPropertyOffset(35) ]
	sint32 xfsSIUStatusDocumentPrinterGuideLights;

	[ValueMap {"0", "1", "4", "8", "16", "32"} ,
	Values	{"xfsSIUGuideLightsNotAvailable", "xfsSIUGuideLightsOff",
			"xfsSIUGuideLightsSlowFlash", "xfsSIUGuideLightsMediumFlash",
			"xfsSIUGuideLightsQuickFlash", "xfsSIUGuideLightsContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the Coin Acceptor unit guidelight. ") ,
	SNMPPropertyOffset(36) ]
	sint32 xfsSIUStatusCoinAcceptorGuideLights;

	[ValueMap {"0", "1", "4", "8", "16", "32"} ,
	Values	{"xfsSIUGuideLightsNotAvailable", "xfsSIUGuideLightsOff",
			"xfsSIUGuideLightsSlowFlash", "xfsSIUGuideLightsMediumFlash",
			"xfsSIUGuideLightsQuickFlash", "xfsSIUGuideLightsContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the Scanner unit guidelight. ") ,
	SNMPPropertyOffset(37) ]
	sint32 xfsSIUStatusScannerGuideLights;

	[ValueMap {"0", "1", "4", "8", "16", "32"} ,
	Values	{"xfsSIUGuideLightsNotAvailable", "xfsSIUGuideLightsOff",
			"xfsSIUGuideLightsSlowFlash", "xfsSIUGuideLightsMediumFlash",
			"xfsSIUGuideLightsQuickFlash", "xfsSIUGuideLightsContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the fourteenth Spare device guidelight. ") ,
	SNMPPropertyOffset(38) ]
	sint32 xfsSIUStatusSpare1GuideLights;

	[ValueMap {"0", "1", "4", "8", "16", "32"} ,
	Values	{"xfsSIUGuideLightsNotAvailable", "xfsSIUGuideLightsOff",
			"xfsSIUGuideLightsSlowFlash", "xfsSIUGuideLightsMediumFlash",
			"xfsSIUGuideLightsQuickFlash", "xfsSIUGuideLightsContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the fifteenth Spare device guidelight. ") ,
	SNMPPropertyOffset(39) ]
	sint32 xfsSIUStatusSpare2GuideLights;

	[ValueMap {"0", "1", "4", "8", "16", "32"} ,
	Values	{"xfsSIUGuideLightsNotAvailable", "xfsSIUGuideLightsOff",
			"xfsSIUGuideLightsSlowFlash", "xfsSIUGuideLightsMediumFlash",
			"xfsSIUGuideLightsQuickFlash", "xfsSIUGuideLightsContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the sixteenth Spare device guidelight. ") ,
	SNMPPropertyOffset(40) ]
	sint32 xfsSIUStatusSpare3GuideLights;

	[Read(TRUE), 
	Write(FALSE),
	Description	("This collection contains all guidance light information in the order received from XFS. It allows access to any potential vendor specific sensors.") ,
	SNMPPropertyOffset(41) ]
	sint32 xfsSIUAllGuidanceLightCollection[];	
};

[Description	("Indicates that the device could not be negotiated for within the time specified in the Reset operation"),       
 SNMPGroup(12),
 SNMPTrapClass(13)]
class xfsSIUResetNegotiationTimeoutEvent:  xfsEvent
{
};

[Description	("Reports the outcome of the Reset operation."),       
 SNMPGroup(12),
 SNMPTrapClass(14)]
class xfsSIUResetCompleteEvent: xfsSIUDeviceStatusChangeEvent
{
	[Description	("The XFS response to the Reset command. ") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsResponse;
};



//=========================================================================================
// xfsCDMDeviceStatusChangeEvent
//=========================================================================================
[Description	("Status changes of managed services are reported as system events to the "
		"XFS Agent."),       
 SNMPGroup(12),
 SNMPTrapClass(15)]
class xfsCDMDeviceStatusChangeEvent : xfsDeviceStatusChangeEvent
{
	[ValueMap {"1", "2", "3", "5"} ,
	Values	{"xfsCDMDoorNotSupported", "xfsCDMDoorOpen",
			"xfsCDMDoorClosed", "xfsCDMDoorUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The state of the safe door. ") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsCDMStatusSafeDoor;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsCDMDispenserOK", "xfsCDMDispenserCUState",
			"xfsCDMDispenserCUStop", "xfsCDMDispenserCUUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The state of the dispenser. ") ,
	SNMPPropertyOffset(2) ]
	sint32 xfsCDMStatusDispenser;

	[ValueMap {"0", "1", "2", "3", "4", "5"} ,
	Values	{"xfsCDMISEmpty", "xfsCDMISNotEmpty",
			"xfsCDMISNotEmptyCust", "xfsCDMISNotEmptyUnk",
			"xfsCDMISUnknown", "xfsCDMISNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The state of the intermediate stacker. ") ,
	SNMPPropertyOffset(3) ]
	sint32 xfsCDMStatusIntermediateStacker;
	
	[BitMap{"0", "1", "2", "6", "7", "11", "12"} ,
	BitValues	{"xfsCDMPositionLeft", "xfsCDMPositionRight", "xfsCDMPositionCenter",
				"xfsCDMPositionTop", "xfsCDMPositionBottom", "xfsCDMPositionFront",
				"xfsCDMPositionRear"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Defines the output position as one of the following values") ,
	SNMPPropertyOffset(4) ]
	sint32 xfsCDMStatusPositionName[];	
	
	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsCDMShtClosed", "xfsCDMShtOpen",
			"xfsCDMShtJammed", "xfsCDMShtUnknown",
			"xfsCDMShtNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The state of the shutter of the position described in xfsCDMStatusPositionName[]. ") ,
	SNMPPropertyOffset(5) ]
	sint32 xfsCDMStatusPositionShutter[];

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsCDMPSEmpty", "xfsCDMPSNotEmpty",
			"xfsCDMPSUnknown", "xfsCDMPSNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The state of the cash tray of the position described in xfsCDMStatusPositionName[]. ") ,
	SNMPPropertyOffset(6) ]
	sint32 xfsCDMStatusPositionStatus[];

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsCDMTPOK", "xfsCDMTPInop",
			"xfsCDMTPUnknown", "xfsCDMTPNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The state of the transport mechanism of the position described in xfsCDMStatusPositionName[].") ,
	SNMPPropertyOffset(7) ]
	sint32 xfsCDMStatusPositionTransport[];

	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsCDMTPStateEmpty", "xfsCDMTPStateNotEmpty",
			"xfsCDMTPStateNotEmptyCust", "xfsCDMTPStateNotEmptyUnknown",
			"xfsCDMTPStateNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The state of the items in the transport. ") ,
	SNMPPropertyOffset(8) ]
	sint32 xfsCDMStatusPositionTransportStatus[];

};


[Description	("Indicates that the device could not be negotiated for within the time specified in the Reset operation"),       
 SNMPGroup(12),
 SNMPTrapClass(16)]
class xfsCDMResetNegotiationTimeoutEvent:  xfsEvent
{
};

[Description	("Reports the outcome of the Reset operation."),       
 SNMPGroup(12),
 SNMPTrapClass(17)]
class xfsCDMResetCompleteEvent: xfsCDMDeviceStatusChangeEvent
{
	[Description	("The XFS response to the Reset command. ") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsResponse;
};

//=========================================================================================
// xfsCDMSubDeviceStatusChangeEvent
//=========================================================================================
[Description	("Status changes of managed services are reported as system events to the "
		"XFS Agent."),       
 SNMPGroup(12),
 SNMPTrapClass(18)]
class xfsCDMSubDeviceStatusChangeEvent : xfsEvent
{
	[Read(TRUE), 
	Write(FALSE),
	Description	("Index number of the media bin structure")]
	uint32 xfsCDMSubDeviceNumber;
	
	[Read(TRUE), 
	Write(FALSE),
	Description	("Cash unit identifier. It is an OCTET STRING field.") ,
	SNMPPropertyOffset(1) ]
	string xfsCDMSubDeviceCULUnitID;

	[Read(TRUE), 
	Write(FALSE),
	Description	("A name which helps to identify the logical type of the cash unit.") ,
	SNMPPropertyOffset(2) ]
	string xfsCDMSubDeviceCUName;

	[ValueMap {"1", "2", "3", "4", "5", "6", "7", "8", "11", "12"} ,
	Values	{"xfsCDMTypeNA", "xfsCDMTypeRejectCassette",
			"xfsCDMTypeBillCassette", "xfsCDMTypeCoinCylinder",
			"xfsCDMTypeCoinDispenser", "xfsCDMTypeRetractCassette",
			"xfsCDMTypeCoupon", "xfsCDMTypeDocument",
			"xfsCDMTypeRepContainer", "xfsCDMTypeRecycling"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Type of the cash unit. ") ,
	SNMPPropertyOffset(3) ]
	sint32 xfsCDMSubDeviceCUType;

	[Read(TRUE), 
	Write(FALSE),
	Description	("A three character array storing the ISO format Currency ID. ") ,
	SNMPPropertyOffset(4) ]
	string xfsCDMSubDeviceCUCurrencyID;

	[Read(TRUE), 
	Write(FALSE),
	Description	("Currency exponent in ISO format ") ,
	SNMPPropertyOffset(5) ]
	string xfsCDMSubDeviceCUCurrencyExponent;
	
	[Read(TRUE), 
	Write(FALSE),
	Description	("Supplies the value of a single item in the cash unit.") ,
	SNMPPropertyOffset(6) ]
    sint32 xfsCDMSubDeviceCUValues;

	[Read(TRUE), 
	Write(FALSE),
	Description	("Initial number of items contained in the logical cash unit.") ,
	SNMPPropertyOffset(7) ]
    sint32 xfsCDMSubDeviceCULInitialCount;

	[Read(TRUE), 
	Write(FALSE),
	Description	("Initial number of items contained in the logical cash unit.") ,
	SNMPPropertyOffset(8) ]
        sint32 xfsCDMSubDeviceCULCount;

	[Read(TRUE), 
	Write(FALSE),
	Description	("Number of items from this logical cash unit that went to the "
	"reject cassette.") ,
	SNMPPropertyOffset(9) ]
    sint32 xfsCDMSubDeviceCULRejectCount;

	[Read(TRUE), 
	Write(FALSE),
	Description	("A minimum threshold value for the logical cash unit. Not applicable for "
	"Retract and Reject Cash Units.") ,
	SNMPPropertyOffset(10) ]
    sint32 xfsCDMSubDeviceCUMinimum;

	[Read(TRUE), 
	Write(FALSE),
	Description	("A maximum threshold value for the logical cash unit. It is only "
	"applicable for Reject Cash Units.") ,
	SNMPPropertyOffset(11) ]
    sint32 xfsCDMSubDeviceCULMaximum;

	[Read(TRUE), 
	Write(FALSE),
	Description	("This field does not apply to reject or retract cash units. "
	"TRUE  items cannot be dispensed from the cash unit."
	"FALSE  items can be dispensed from the cash unit.") ,
	SNMPPropertyOffset(12) ]
	sint32 xfsCDMSubDeviceCUAppLock;

	[ValueMap {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"} ,
	Values	{"xfsCDMCUStatusOK", "xfsCDMCUStatusFull",
			"xfsCDMCUStatusHigh", "xfsCDMCUStatusLow",
			"xfsCDMCUStatusEmpty", "xfsCDMCUStatusInop",
			"xfsCDMCUStatusMissing", "xfsCDMCUStatusNoval",
			"xfsCDMCUStatusNoref", "xfsCDMCUStatusManip"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The status of the logical cash unit. ") ,
	SNMPPropertyOffset(13) ]
	sint32 xfsCDMSubDeviceCULogicalStatus;

	[Read(TRUE), 
	Write(FALSE),
	Description	("Specifies whether or not threshold events can be generated based on "
				"hardware sensor in the device. "
				"TRUE  threshold events generated on hardware sensors."
				"FALSE - threshold events NOT generated on hardware sensors,") ,
	SNMPPropertyOffset(14) ]
	sint32 xfsCDMSubDeviceCUHardwareSensor;

	[Read(TRUE), 
	Write(FALSE),
    Description     ("Specifies the number of physical cassettes associated with this logical ID"
                         "The following physical unit properties arrays") ,
	SNMPPropertyOffset(15) ]
    sint32 xfsCDMSubDeviceNumberOfPhysicalCassettes;

    [Read(TRUE), 
	Write(FALSE),
	Description	("A name identifying the physical location of the cash unit within the CDM."
                         "This field can by used by CDMs which are compound with a CIM to identify "
                         "shared cash units.") ,
	SNMPPropertyOffset(16) ]
    string xfsCDMSubDeviceCUPhysicalPositionName[];

	[Read(TRUE), 
	Write(FALSE),
	Description	("Physical Cash unit identifier. ") ,
	SNMPPropertyOffset(17) ]
    string xfsCDMSubDeviceCUPUnitID[];

	[Read(TRUE), 
	Write(FALSE),
	Description	("Initial number of items contained in the physical cash unit") ,
	SNMPPropertyOffset(18) ]
    string xfsCDMSubDeviceCUPInitialCount[];
		
	[Read(TRUE), 
	Write(FALSE),
	Description	("Actual number of items contained in the physical cash unit.") ,
	SNMPPropertyOffset(19) ]
    string xfsCDMSubDeviceCUPCount[];

	[Read(TRUE), 
	Write(FALSE),
	Description	("number of items from this unit that are in the reject bin.") ,
	SNMPPropertyOffset(20) ]
    string xfsCDMSubDeviceCUPRejectCount[];

	[Read(TRUE), 
	Write(FALSE),
	Description	("Maximum number of items the unit can hold") ,
	SNMPPropertyOffset(21) ]
    string xfsCDMSubDeviceCUPMaximum[];

	[Read(TRUE), 
	Write(FALSE),
	Description	("Specifies whether threshold events are generated based on hardware sensors on the device or via counts.") ,
	SNMPPropertyOffset(22) ]
    string xfsCDMSubDeviceCUPHardwareSensor[];
		
	[ValueMap {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"} ,
	Values	{"xfsCDMCUStatusOK", "xfsCDMCUStatusFull",
			"xfsCDMCUStatusHigh", "xfsCDMCUStatusLow",
			"xfsCDMCUStatusEmpty", "xfsCDMCUStatusInop",
			"xfsCDMCUStatusMissing", "xfsCDMCUStatusNoval",
            "xfsCDMCUStatusNoref", "xfsCDMCUStatusManip"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Depreciated, use xfsCDMSubDeviceCUPhysicalStatus2. The status of the physical cash unit. ") ,
	SNMPPropertyOffset(23) ]
    string xfsCDMSubDeviceCUPhysicalStatus[];

	[ValueMap {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"} ,
	Values	{"xfsCDMCUStatusOK", "xfsCDMCUStatusFull",
			"xfsCDMCUStatusHigh", "xfsCDMCUStatusLow",
			"xfsCDMCUStatusEmpty", "xfsCDMCUStatusInop",
			"xfsCDMCUStatusMissing", "xfsCDMCUStatusNoval",
            "xfsCDMCUStatusNoref", "xfsCDMCUStatusManip"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The status of the physical cash unit. ") ,
	SNMPPropertyOffset(24) ]
    sint32 xfsCDMSubDeviceCUPhysicalStatus2[];
};


//=========================================================================================
// xfsPTRDeviceStatusChangeEvent
//=========================================================================================
[Description	("Status changes of managed services are reported as system events to the "
		"XFS Agent."),       
 SNMPGroup(12),
 SNMPTrapClass(19)]
class xfsPTRDeviceStatusChangeEvent : xfsDeviceStatusChangeEvent
{
	[ValueMap {"0", "1", "2", "3", "4", "5", "6"} ,
	Values	{"xfsPTRMediaPresent", "xfsPTRMediaNotPresent",
			"xfsPTRMediaJammed", "xfsPTRMediaNotSupported",
			"xfsPTRMediaUnknown", "xfsPTRMediaEntering",
			"xfsPTRMediaRetracted"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the media state. ") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsPTRStatusMedia;

	[ValueMap {"0", "1", "2", "3", "4", "5"} ,
	Values	{"xfsPTRPaperFull", "xfsPTRPaperLow",
			"xfsPTRPaperOut", "xfsPTRPaperNotSupported",
			"xfsPTRPaperUnknown", "xfsPTRPaperJammed"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the state of the upper paper supply. ") ,
	SNMPPropertyOffset(2) ]
    sint32 xfsPTRStatusPaperSupply[];

	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsPTRTonerFull", "xfsPTRTonerLow", "xfsPTRTonerOut",
			"xfsPTRTonerNotSupported", "xfsPTRTonerUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the toner supply state.") ,
	SNMPPropertyOffset(3) ]
	sint32 xfsPTRStatusToner;

	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsPTRInkFull", "xfsPTRInkLow", "xfsPTRInkOut",
			"xfsPTRInkNotSupported", "xfsPTRInkUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the ink supply state. ") ,
	SNMPPropertyOffset(4) ]
	sint32 xfsPTRStatusInk;

	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsPPTRLampOK", "xfsPPTRLampFading", "xfsPPTRLampInOp",
			"xfsPPTRLampNotSupported", "xfsPPTRLampUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("It contains the imaging lamp state.") ,
	SNMPPropertyOffset(5) ]
	sint32 xfsPTRStatusLamp;

	[Read(TRUE),
	Write(FALSE),
	Description	("It contains the number of media on stacker.") ,
	SNMPPropertyOffset(6) ]
	sint32 xfsPTRStatusMediaOnStacker;

	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsPTRRetractBinOK", "xfsPTRRetractBinFull",
             "xfsPTRRetractBinNotSupported", "xfsPTRRetractBinUnknown",
			 "xfsPTRRetractBinHigh"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("A series of values describing the status of each retract bin supported by the PTR. The first entry holds the value for bin one, the second for bin two and so on") ,
	SNMPPropertyOffset(7) ]
	sint32 xfsPTRDeviceRetractBin[];

	[Read(TRUE), 
	Write(FALSE),
	Description	("A series of values describing the number of media retracted to each bin supported by the PTR. The first entry holds the value for bin one, the second for bin two and so on.") ,
	SNMPPropertyOffset(8) ]
	sint32 xfsPTRDeviceRetractCount[];
};

[Description	("Indicates that the device could not be negotiated for within the time specified in the Reset operation"),       
 SNMPGroup(12),
 SNMPTrapClass(20)]
class xfsPTRResetNegotiationTimeoutEvent:  xfsEvent
{
};

[Description	("Reports the outcome of the Reset operation."),       
 SNMPGroup(12),
 SNMPTrapClass(21)]
class xfsPTRResetCompleteEvent: xfsPTRDeviceStatusChangeEvent
{
	[Description	("The XFS response to the Reset command. ") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsResponse;
};


//=========================================================================================
// xfsALMDeviceStatusChangeEvent
//=========================================================================================
[Description	("Status changes of managed services are reported as system events to the "
		"XFS Agent."),       
 SNMPGroup(12),
 SNMPTrapClass(22)]
class xfsALMDeviceStatusChangeEvent : xfsDeviceStatusChangeEvent
{
	[Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the Alarm "
	"TRUE  set."
	"FALSE  reset") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsALMAlarmSet;
};


[Description	("Indicates that the device could not be negotiated for within the time specified in the Reset operation"),       
 SNMPGroup(12),
 SNMPTrapClass(23)]
class xfsALMResetNegotiationTimeoutEvent:  xfsEvent
{
};

[Description	("Reports the outcome of the Reset operation."),       
 SNMPGroup(12),
 SNMPTrapClass(24)]
class xfsALMResetCompleteEvent: xfsALMDeviceStatusChangeEvent
{
	[Description	("The XFS response to the Reset command. ") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsResponse;
};


//=========================================================================================
// xfsCAMDeviceStatusChangeEvent
//=========================================================================================
[Description	("Status changes of managed services are reported as system events to the "
		"XFS Agent."),       
 SNMPGroup(12),
 SNMPTrapClass(25)]
class xfsCAMDeviceStatusChangeEvent : xfsDeviceStatusChangeEvent
{
	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsCAMMediaOk", "xfsCAMMediaHigh", "xfsCAMMediaFull",
			"xfsCAMMediaNotSupported", "xfsCAMMediaUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the recording media of the cameras. A number of indexes are defined in the CEN XFS specification") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsCAMMedia[];
	
	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsCAMCameraNotSupported", "xfsCAMCameraOk", "xfsCAMCameraInoperative",
			"xfsCAMCameraUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the the cameras. A number of cameras are defined in the CEN XFS specification. ") ,
	SNMPPropertyOffset(2) ]
	sint32 xfsCAMCameras[];	
	
	[Read(TRUE), 
	Write(FALSE),
	Description	("Reports the number of pictures stored on the recording media of the camera. A number of indexes are defined in the CEN XFS specification. ") ,
	SNMPPropertyOffset(3) ]
	sint32 xfsCAMPictures[];	
};

[Description	("Indicates that the device could not be negotiated for within the time specified in the Reset operation"),       
 SNMPGroup(12),
 SNMPTrapClass(26)]
class xfsCAMResetNegotiationTimeoutEvent:  xfsEvent
{
};

[Description	("Reports the outcome of the Reset operation."),       
 SNMPGroup(12),
 SNMPTrapClass(27)]
class xfsCAMResetCompleteEvent: xfsCAMDeviceStatusChangeEvent
{
	[Description	("The XFS response to the Reset command. ")]
	sint32 xfsResponse;
};



//=========================================================================================
// xfsCHKDeviceStatusChangeEvent
//=========================================================================================
[Description	("Status changes of managed services are reported as system events to the "
		"XFS Agent."),       
 SNMPGroup(12),
 SNMPTrapClass(28)]
class xfsCHKDeviceStatusChangeEvent : xfsDeviceStatusChangeEvent
{
	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsCHKMediaNotSupported", "xfsCHKMediaNotPresent", "xfsCHKMediaRequired",
			"xfsCHKMediaPresent", "xfsCHKMediaJammed"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Describes the status of the media ") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsCHKMedia;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsCHKInkNotSupported", "xfsCHKInkFull", "xfsCHKInkLow",
			"xfsCHKInkOut"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Describes the status of the ink ") ,
	SNMPPropertyOffset(2) ]
	sint32 xfsCHKInk;	
};

[Description	("Indicates that the device could not be negotiated for within the time specified in the Reset operation"),       
 SNMPGroup(12),
 SNMPTrapClass(29)]
class xfsCHKResetNegotiationTimeoutEvent:  xfsEvent
{
};

[Description	("Reports the outcome of the Reset operation."),       
 SNMPGroup(12),
 SNMPTrapClass(30)]
class xfsCHKResetCompleteEvent: xfsCHKDeviceStatusChangeEvent
{
	[Description	("The XFS response to the Reset command. ") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsResponse;
};

//=========================================================================================
// xfsTTUDeviceStatusChangeEvent
//=========================================================================================
[Description	("Status changes of managed services are reported as system events to the "
		"XFS Agent."),       
 SNMPGroup(12),
 SNMPTrapClass(31)]
class xfsTTUDeviceStatusChangeEvent : xfsDeviceStatusChangeEvent
{
	[ValueMap {"0", "1", "2"} ,
	Values	{"xfsTTUKeyboardNotAvailable", "xfsTTUKeyboardOn", "xfsTTUKeyboardOff"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the keyboard") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsTTUKeyboard;
	
	[ValueMap {"0", "1", "2"} ,
	Values	{"xfsTTUKeyboardLockNotAvailable", "xfsTTUKeyboardLockOn", "xfsTTUKeyboardLockOff"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the keyboard lock") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsTTUKeyLock;
	
	[ValueMap {"0", "1", "2", "4", "8", "128"} ,
	Values	{"xfsTTULEDNotAvailable", "xfsTTULEDOff", "xfsTTULEDSlowFlash",
			"xfsTTULEDMediumFlash", "xfsTTULEDQuickFlash", "xfsTTULEDContinuous"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the state of the LEDs") ,
	SNMPPropertyOffset(2) ]
	sint32 xfsTTULEDs[];
	
	[Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the horizontal size of the display") ,
	SNMPPropertyOffset(3) ]
	sint32 xfsTTUDisplaySizeX;
	
	[Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the vertical size of the display") ,
	SNMPPropertyOffset(4) ]
	sint32 xfsTTUDisplaySizeY;

};



[Description	("Indicates that the device could not be negotiated for within the time specified in the Reset operation"),       
 SNMPGroup(12),
 SNMPTrapClass(32)]
class xfsTTUResetNegotiationTimeoutEvent:  xfsEvent
{
};

[Description	("Reports the outcome of the Reset operation."),       
 SNMPGroup(12),
 SNMPTrapClass(33)]
class xfsTTUResetCompleteEvent: xfsTTUDeviceStatusChangeEvent
{
	[Description	("The XFS response to the Reset command. ") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsResponse;
};



//=========================================================================================
// xfsCIMDeviceStatusChangeEvent
//=========================================================================================
[Description	("Status changes of managed services are reported as system events to the "
		"XFS Agent."),       
 SNMPGroup(12),
 SNMPTrapClass(34)]
class xfsCIMDeviceStatusChangeEvent : xfsDeviceStatusChangeEvent
{
	[ValueMap {"1", "2", "3", "4"} ,
	Values	{"xfsCIMDoorNotSupported", "xfsCIMDoorOpen",
			"xfsCIMDoorClosed", "xfsCIMDoorUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The state of the safe door. ") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsCIMStatusSafeDoor;

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsCIMDispenserOK", "xfsCIMDispenserCUState",
			"xfsCIMDispenserCUStop", "xfsCIMDispenserCUUnknown"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The state of the dispenser. ") ,
	SNMPPropertyOffset(2) ]
	sint32 xfsCIMAcceptor;

	[ValueMap {"0", "1", "2", "4", "5"} ,
	Values	{"xfsCIMISEmpty", "xfsCIMISNotEmpty",
			"xfsCIMISFull", 
			"xfsCIMISUnknown", "xfsCIMISNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The state of the intermediate stacker. ") ,
	SNMPPropertyOffset(3) ]
	sint32 xfsCIMStatusIntermediateStacker;
	
	[ValueMap {"0", "1", "2", "4"} ,
	Values	{"xfsCIMCustomerAccess", "xfsCIMNoCustomerAccess",
			"xfsCIMAccessUnknown", "xfsCIMNoItems"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("This field inform the application whether items on the intermediate stacker have been in customer access.") ,
	SNMPPropertyOffset(4) ]
	sint32 xfsCIMStackerItems;	
	
	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsCIMBNROk", "xfsCIMBNRInoperative",
			"xfsCIMBNRUnknown", "xfsCIMBNRNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Supplies the state of the banknote reader ") ,
	SNMPPropertyOffset(5) ]
	sint32 xfsCIMBankNoteReader;	

	[Read(TRUE), 
	Write(FALSE),
	Description	("This field specifies the status of the drop box. TRUE means that some items are stored in the drop box. FALSE indicates that the drop box is empty ") ,
	SNMPPropertyOffset(6) ]
	sint32 xfsCIMDropBox;		


	[ValueMap{"1", "2", "4", "8", "16", "32", "64", "128", "256", "512", "1024", "2048", "4096", "8192"} ,
	Values	{"xfsCIMPositionInLeft", "xfsCIMPositionInRight",
			"xfsCIMPositionInCenter", "xfsCIMPositionInTop",
			"xfsCIMPositionInBottom", "xfsCIMPositionInFront",
			"xfsCIMPositionInRear", "xfsCIMPositionOutLeft", "xfsCIMPositionOutRight",
			"xfsCIMPositionOutCenter", "xfsCIMPositionOutTop",
			"xfsCIMPositionOutBottom", "xfsCIMPositionOutFront",
			"xfsCIMPositionOutRear"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Defines the input or output position for this offset.") ,
	SNMPPropertyOffset(7) ]
	sint32 xfsCIMStatusPositionName[];
	
	
	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsCIMShtClosed", "xfsCIMShtOpen",
			"xfsCIMShtJammed", "xfsCIMShtUnknown",
			"xfsCIMShtNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The state of the shutter of the position described in xfsCIMStatusPositionName[]. ") ,
	SNMPPropertyOffset(8) ]
	sint32 xfsCIMStatusPositionShutter[];

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsCIMPSEmpty", "xfsCIMPSNotEmpty",
			"xfsCIMPSUnknown", "xfsCIMPSNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The state of the cash tray of the position described in xfsCIMStatusPositionName[]. ") ,
	SNMPPropertyOffset(9) ]
	sint32 xfsCIMStatusPositionStatus[];

	[ValueMap {"0", "1", "2", "3"} ,
	Values	{"xfsCIMTPOK", "xfsCIMTPInop",
			"xfsCIMTPUnknown", "xfsCIMTPNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The state of the transport mechanism of the position described in xfsCIMStatusPositionName[].") ,
	SNMPPropertyOffset(10) ]
	sint32 xfsCIMStatusPositionTransport[];

	[ValueMap {"0", "1", "2", "3", "4"} ,
	Values	{"xfsCIMTPStateEmpty", "xfsCIMTPStateNotEmpty",
			"xfsCIMTPStateNotEmptyCust", "xfsCIMTPStateNotEmptyUnknown",
			"xfsCIMTPStateNotSupported"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The state of the items in the transport. ") ,
	SNMPPropertyOffset(11) ]
	sint32 xfsCIMStatusPositionTransportStatus[];
};

[Description	("Indicates that the device could not be negotiated for within the time specified in the Reset operation"),       
 SNMPGroup(12),
 SNMPTrapClass(35)]
class xfsCIMResetNegotiationTimeoutEvent:  xfsEvent
{
};

[Description	("Reports the outcome of the Reset operation."),       
 SNMPGroup(12),
 SNMPTrapClass(36)]
class xfsCIMResetCompleteEvent: xfsCIMDeviceStatusChangeEvent
{
	[Description	("The XFS response to the Reset command. ") ,
	SNMPPropertyOffset(1) ]
	sint32 xfsResponse;
};

//=========================================================================================
// xfsCIMSubDeviceStatusChangeEvent
//=========================================================================================
[Description	("Status changes of managed services are reported as system events to the "
		"XFS Agent."),       
 SNMPGroup(12),
 SNMPTrapClass(37)]
class xfsCIMSubDeviceStatusChangeEvent : xfsEvent
{
	[Read(TRUE), 
	Write(FALSE),
	Description	("Index number of the media bin structure")]
	uint32 xfsCIMSubDeviceNumber;
	
	[Read(TRUE), 
	Write(FALSE),
	Description	("Cash unit identifier.") ,
	SNMPPropertyOffset(1) ]
	string xfsCIMSubDeviceCULUnitID;

	[BitMap{"0", "1", "2", "3", "4"} ,
	BitValues	{"xfsCIMItemTypeAll", "xfsCIMItemTypeUnfit", "xfsCIMItemTypeIndividual",
				"xfsCIMItemTypeLevel2", "xfsCIMItemTypeLevel3"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Specifies the type of items the Cash Unit takes ") ,
	SNMPPropertyOffset(2) ]
	sint32 xfsCIMItemType;	
	
	[ValueMap {"1", "2", "3", "4"} ,
	Values	{"xfsCIMTypeRecycling", "xfsCIMTypeCashIn",
			"xfsCIMTypeRepContainer", "xfsCIMTypeRetractCassette"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Type of the cash unit. ") ,
	SNMPPropertyOffset(3) ]
	sint32 xfsCIMSubDeviceCUType;

	[Read(TRUE), 
	Write(FALSE),
	Description	("A three character array storing the ISO format Currency ID. ") ,
	SNMPPropertyOffset(4) ]
	string xfsCIMSubDeviceCUCurrencyID;

	[Read(TRUE), 
	Write(FALSE),
	Description	("Currency exponent in ISO format ") ,
	SNMPPropertyOffset(5) ]
	string xfsCIMSubDeviceCUCurrencyExponent;
	
	[Read(TRUE), 
	Write(FALSE),
	Description	("Supplies the value of a single item in the cash unit.") ,
	SNMPPropertyOffset(6) ]
    sint32 xfsCIMSubDeviceCUValues;

	[Read(TRUE), 
	Write(FALSE),
	Description	("Count of items that have entered the cash unit") ,
	SNMPPropertyOffset(7) ]
    sint32 xfsCIMSubDeviceCULCashInCount;

	[Read(TRUE), 
	Write(FALSE),
	Description	("Initial number of items contained in the logical cash unit.") ,
	SNMPPropertyOffset(8) ]
    sint32 xfsCIMSubDeviceCULCount;
		
	[Read(TRUE), 
	Write(FALSE),
	Description	("Identification of note type.") ,
	SNMPPropertyOffset(9) ]
    string xfsCIMSubDeviceNoteID[];		

	[Read(TRUE), 
	Write(FALSE),
	Description	("Actual count of items") ,
	SNMPPropertyOffset(10) ]
    sint32 xfsCIMSubDeviceNoteCount[];	

	[Read(TRUE), 
	Write(FALSE),
	Description	("A maximum threshold value") ,
	SNMPPropertyOffset(11) ]
        sint32 xfsCIMSubDeviceCULMaximum;

	[Read(TRUE), 
	Write(FALSE),
	Description	("This field does not apply to reject or retract cash units. "
	"TRUE  items cannot be dispensed from the cash unit."
	"FALSE  items can be dispensed from the cash unit.") ,
	SNMPPropertyOffset(12) ]
	sint32 xfsCIMSubDeviceCUAppLock;

	[ValueMap {"0", "1", "2", "4", "5", "6", "7", "8", "9"} ,
	Values	{"xfsCIMCUStatusOK", "xfsCIMCUStatusFull",
			"xfsCIMCUStatusHigh", "xfsCIMCUStatusEmpty",
			"xfsCIMCUStatusInop",
			"xfsCIMCUStatusMissing", "xfsCIMCUStatusNoval",
			"xfsCIMCUStatusNoref", "xfsCIMCUStatusManip"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The status of the logical cash unit. ") ,
	SNMPPropertyOffset(13) ]
	sint32 xfsCIMSubDeviceCULogicalStatus;

	[Read(TRUE), 
	Write(FALSE),
	Description	("Specifies whether or not threshold events can be generated based on "
				"hardware sensor in the device. "
				"TRUE  threshold events generated on hardware sensors."
				"FALSE - threshold events NOT generated on hardware sensors,") ,
	SNMPPropertyOffset(14) ]
	sint32 xfsCIMSubDeviceCUHardwareSensor;

	[Read(TRUE), 
	Write(FALSE),
    Description     ("Specifies the number of physical cassettes associated with this logical ID"
                         "The following physical unit properties arrays") ,
	SNMPPropertyOffset(15) ]
        sint32 xfsCIMSubDeviceNumberOfPhysicalCassettes;

    [Read(TRUE), 
	Write(FALSE),
	Description	("A name identifying the physical location of the cash unit within the CIM."
                         "This field can by used by CIMs which are compound with a CDM to identify "
                         "shared cash units.") ,
	SNMPPropertyOffset(16) ]
        string xfsCIMSubDeviceCUPhysicalPositionName[];

	[Read(TRUE), 
	Write(FALSE),
	Description	("Physical Cash unit identifier. ") ,
	SNMPPropertyOffset(17) ]
        string xfsCIMSubDeviceCUPUnitID[];

	[Read(TRUE), 
	Write(FALSE),
	Description	("Initial number of items contained in the physical cash unit") ,
	SNMPPropertyOffset(18) ]
        string xfsCIMSubDeviceCUPCashInCount[];
		
	[Read(TRUE), 
	Write(FALSE),
	Description	("Actual number of items contained in the physical cash unit.") ,
	SNMPPropertyOffset(19) ]
        string xfsCIMSubDeviceCUPCount[];


	[Read(TRUE), 
	Write(FALSE),
	Description	("Maximum number of items the unit can hold") ,
	SNMPPropertyOffset(40) ]
        string xfsCIMSubDeviceCUPMaximum[];

	[Read(TRUE), 
	Write(FALSE),
	Description	("Specifies whether threshold events are generated based on hardware sensors on the device or via counts.") ,
	SNMPPropertyOffset(41) ]
        string xfsCIMSubDeviceCUPHardwareSensor[];
		
	[ValueMap {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"} ,
	Values	{"xfsCIMCUStatusOK", "xfsCIMCUStatusFull",
			"xfsCIMCUStatusHigh", "xfsCIMCUStatusLow",
			"xfsCIMCUStatusEmpty", "xfsCIMCUStatusInop",
			"xfsCIMCUStatusMissing", "xfsCIMCUStatusNoval",
            "xfsCIMCUStatusNoref", "xfsCIMCUStatusManip"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("Depreciated, use xfsCIMSubDeviceCUPhysicalStatus2. The status of the physical cash unit. ") ,
	SNMPPropertyOffset(42) ]
        string xfsCIMSubDeviceCUPhysicalStatus[];

	[ValueMap {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"} ,
	Values	{"xfsCIMCUStatusOK", "xfsCIMCUStatusFull",
			"xfsCIMCUStatusHigh", "xfsCIMCUStatusLow",
			"xfsCIMCUStatusEmpty", "xfsCIMCUStatusInop",
			"xfsCIMCUStatusMissing", "xfsCIMCUStatusNoval",
            "xfsCIMCUStatusNoref", "xfsCIMCUStatusManip"} ,
	Read(TRUE), 
	Write(FALSE),
	Description	("The status of the physical cash unit. ") ,
	SNMPPropertyOffset(43) ]
    sint32 xfsCIMSubDeviceCUPhysicalStatus2[];		
};

//////////////////////////////////////////
//////////////////////////////////////////
// Nedbank Specific Classes
//////////////////////////////////////////
//////////////////////////////////////////

[Dynamic:ToInstance, Provider("NCR_WMICoreProvider"), 
Description("This represents a OutofService Duration class. It provides a mechanism to share and invoke the OutOfService Duration display in the Consumer Application from the Supervisor Application.")]
class Nedbank_OutOfServiceDuration : NCR_LogicalElement
{
	[read: ToSubClass ToInstance, 
	Description("The Duration in minutes that the Out Of Service Duration screen needs to be displayed")]
	uint32 Duration;
	
	[implemented: ToSubClass, 
	Description("Notifies that the Duration of the class has changed.")]
	void UpdateDuration([Description("Specifies the new Duration in minutes 0  - 59. Returns true if it executed successfully."), in]uint32 Duration);
};